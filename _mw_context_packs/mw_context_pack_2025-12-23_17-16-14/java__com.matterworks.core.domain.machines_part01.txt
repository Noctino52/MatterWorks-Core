=== BUNDLE: java__com.matterworks.core.domain.machines_part01 ===
Created: 2025-12-23T17:16:23.0543346+01:00



--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\BlockRegistry.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.database.dao.MachineDefinitionDAO;
import com.matterworks.core.ports.IWorldAccess;
import java.util.HashMap;
import java.util.Map;

public class BlockRegistry {

    private final IWorldAccess worldAdapter;
    private final MachineDefinitionDAO definitionDAO;
    private final Map<String, MachineStats> statsCache;

    public BlockRegistry(IWorldAccess worldAdapter, MachineDefinitionDAO definitionDAO) {
        this.worldAdapter = worldAdapter;
        this.definitionDAO = definitionDAO;
        this.statsCache = new HashMap<>();
    }

    public void loadFromDatabase() {
        System.out.println("ðŸ“‹ Caricamento definizioni blocchi dal DB...");
        Map<String, MachineStats> dbDefs = definitionDAO.loadAllDefinitions();
        statsCache.putAll(dbDefs);

        dbDefs.forEach((id, stats) ->
                System.out.println("   -> " + id + " [Tier " + stats.tier() + "]: "
                        + stats.dimensions() + " | $" + stats.basePrice())
        );
    }

    public MachineStats getStats(String blockId) {
        return statsCache.getOrDefault(blockId, MachineStats.fallback(blockId));
    }

    public Vector3Int getDimensions(String blockId) {
        if (statsCache.containsKey(blockId)) {
            return statsCache.get(blockId).dimensions();
        }

        // Hardcoded Fallback per stabilitÃ  in caso di DB mancante
        return switch (blockId) {
            case "nexus_core" -> new Vector3Int(3, 3, 3);
            case "chromator", "color_mixer", "splitter", "merger" -> new Vector3Int(2, 1, 1); // Merger aggiunto qui
            case "drill_mk1" -> new Vector3Int(1, 2, 1);
            default -> Vector3Int.one();
        };
    }

    public double getPrice(String blockId) {
        if (statsCache.containsKey(blockId)) {
            return statsCache.get(blockId).basePrice();
        }
        return 0.0;
    }

    public String getModelId(String blockId) {
        if (statsCache.containsKey(blockId)) {
            return statsCache.get(blockId).modelId();
        }
        return "model_missing";
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\Chromator.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.matter.Recipe;
import java.util.UUID;
import java.util.List;

public class Chromator extends ProcessorMachine {

    public Chromator(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, pos, typeId, metadata);
        this.dimensions = new Vector3Int(2, 1, 1);
    }

    @Override
    public boolean insertItem(MatterPayload item, GridPosition fromPos) {
        if (fromPos == null) return false;
        int targetSlot = getSlotForPosition(fromPos);
        if (targetSlot == -1) return false;

        boolean isDye = (item.color() != MatterColor.RAW);
        if (targetSlot == 0 && isDye) return false;
        if (targetSlot == 1 && !isDye) return false;

        return insertIntoBuffer(targetSlot, item);
    }

    @Override
    protected GridPosition getOutputPosition() {
        int x = pos.x(); int y = pos.y(); int z = pos.z();
        return switch (orientation) {
            case NORTH -> new GridPosition(x, y, z - 1);
            case SOUTH -> new GridPosition(x + 1, y, z + 1);
            case EAST -> new GridPosition(x + 1, y, z);
            case WEST -> new GridPosition(x - 1, y, z + 1);
            default -> pos;
        };
    }

    private int getSlotForPosition(GridPosition senderPos) {
        int x = pos.x(); int y = pos.y(); int z = pos.z();
        GridPosition s0, s1;
        switch (orientation) {
            case NORTH -> { s0 = new GridPosition(x, y, z + 1); s1 = new GridPosition(x + 1, y, z + 1); }
            case SOUTH -> { s0 = new GridPosition(x + 1, y, z - 1); s1 = new GridPosition(x, y, z - 1); }
            case EAST ->  { s0 = new GridPosition(x - 1, y, z); s1 = new GridPosition(x - 1, y, z + 1); }
            case WEST ->  { s0 = new GridPosition(x + 1, y, z + 1); s1 = new GridPosition(x + 1, y, z); }
            default -> { return -1; }
        }
        if (senderPos.equals(s0)) return 0;
        if (senderPos.equals(s1)) return 1;
        return -1;
    }

    @Override
    public void tick(long currentTick) {
        // 1. Tenta di espellere prima di ogni altra cosa
        super.tryEjectItem(currentTick);

        // 2. Se ha finito la ricetta, sposta nel buffer di output
        if (currentRecipe != null) {
            if (currentTick >= finishTick) {
                completeProcessing();
            }
            return;
        }

        // 3. Se il buffer di output Ã¨ pieno, non iniziare nulla
        if (outputBuffer.getCount() >= MAX_OUTPUT_STACK) return;

        // 4. Se ha gli ingredienti (Slot 0: Cubo, Slot 1: Colore), avvia ricetta
        if (inputBuffer.getCountInSlot(0) > 0 && inputBuffer.getCountInSlot(1) > 0) {
            MatterPayload cube = inputBuffer.getItemInSlot(0);
            MatterPayload dye = inputBuffer.getItemInSlot(1);

            inputBuffer.decreaseSlot(0, 1);
            inputBuffer.decreaseSlot(1, 1);

            MatterPayload result = new MatterPayload(cube.shape(), dye.color());
            this.currentRecipe = new Recipe("chroma_working", List.of(cube, dye), result, 1.5f, 0);
            this.finishTick = currentTick + 30; // 1.5 sec

            saveState();
        }
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\ColorMixer.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.matter.MatterShape;

import java.util.UUID;

public class ColorMixer extends ProcessorMachine {

    public ColorMixer(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, pos, typeId, metadata);
        this.dimensions = new Vector3Int(2, 1, 1);
        if (inputBuffer.getItemInSlot(0) == null) inputBuffer.insertIntoSlot(0, null);
        if (inputBuffer.getItemInSlot(1) == null) inputBuffer.insertIntoSlot(1, null);
    }

    @Override
    public boolean insertItem(MatterPayload item, GridPosition fromPos) {
        if (fromPos == null) return false;
        if (item.color() == MatterColor.RAW) return false;

        int targetSlot = getSlotForPosition(fromPos);
        if (targetSlot == -1) return false;

        // FIX: Usa la costante MAX_INPUT_STACK (64)
        if (inputBuffer.getCountInSlot(targetSlot) >= MAX_INPUT_STACK) return false;

        return insertIntoBuffer(targetSlot, item);
    }

    @Override
    protected GridPosition getOutputPosition() {
        int x = pos.x();
        int y = pos.y();
        int z = pos.z();

        // Restituisce il vicino del "Blocco Sinistro" rispetto alla faccia anteriore
        return switch (orientation) {
            // NORD: Fronte Ã¨ Z-min. Sinistra Ã¨ X (Ovest). Output deve essere a (x, z-1).
            case NORTH -> new GridPosition(x, y, z - 1);

            // SUD: Fronte Ã¨ Z-max. Sinistra Ã¨ X+1 (Est). Output deve essere a (x+1, z+1).
            case SOUTH -> new GridPosition(x + 1, y, z + 1);

            // EST: Fronte Ã¨ X-max. Sinistra Ã¨ Z (Nord). Output deve essere a (x+1, z).
            case EAST -> new GridPosition(x + 1, y, z);

            // OVEST: Fronte Ã¨ X-min. Sinistra Ã¨ Z+1 (Sud). Output deve essere a (x-1, z+1).
            case WEST -> new GridPosition(x - 1, y, z + 1);

            default -> pos;
        };
    }

    private int getSlotForPosition(GridPosition senderPos) {
        int x = pos.x();
        int y = pos.y();
        int z = pos.z();
        GridPosition slot0Pos = null, slot1Pos = null;

        switch (orientation) {
            case NORTH: slot0Pos = new GridPosition(x, y, z + 1); slot1Pos = new GridPosition(x + 1, y, z + 1); break;
            case SOUTH: slot0Pos = new GridPosition(x + 1, y, z - 1); slot1Pos = new GridPosition(x, y, z - 1); break;
            case EAST:  slot0Pos = new GridPosition(x - 1, y, z); slot1Pos = new GridPosition(x - 1, y, z + 1); break;
            case WEST:  slot0Pos = new GridPosition(x + 1, y, z + 1); slot1Pos = new GridPosition(x + 1, y, z); break;
            default: return -1;
        }

        if (senderPos.equals(slot0Pos)) return 0;
        if (senderPos.equals(slot1Pos)) return 1;
        return -1;
    }

    @Override
    public void tick(long currentTick) {
        super.tryEjectItem(currentTick);
        if (currentRecipe != null) {
            if (currentTick >= finishTick) completeProcessing();
            return;
        }
        if (outputBuffer.getCount() >= MAX_OUTPUT_STACK) return;

        int count0 = inputBuffer.getCountInSlot(0);
        int count1 = inputBuffer.getCountInSlot(1);

        if (count0 > 0 && count1 > 0) {
            MatterPayload c1 = inputBuffer.getItemInSlot(0);
            MatterPayload c2 = inputBuffer.getItemInSlot(1);
            if (c1.color() == c2.color()) return;

            inputBuffer.decreaseSlot(0, 1);
            inputBuffer.decreaseSlot(1, 1);

            MatterColor mixed = MatterColor.mix(c1.color(), c2.color());
            MatterPayload result = new MatterPayload(MatterShape.SPHERE, mixed);
            this.currentRecipe = new com.matterworks.core.domain.matter.Recipe("mix_" + mixed.name(), java.util.List.of(c1, c2), result, 1.5f, 0);
            this.finishTick = currentTick + 30;
            saveState();
            System.out.println("ðŸŒ€ Mixer: Mixing " + c1.color() + " + " + c2.color() + " -> " + mixed);
        }
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\ConveyorBelt.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.matter.MatterPayload;

import java.util.UUID;

public class ConveyorBelt extends PlacedMachine {

    private MatterPayload currentItem;
    private long arrivalTick = -1;
    private static final int TRANSPORT_TIME = 20;

    public ConveyorBelt(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.dimensions = Vector3Int.one();

        if (this.metadata.has("currentItem")) {
            this.currentItem = MatterPayload.fromJson(this.metadata.getAsJsonObject("currentItem"));
            this.arrivalTick = 0;
        }
    }

    @Override
    public void tick(long currentTick) {
        if (currentItem == null) return;
        if (arrivalTick == -1) arrivalTick = currentTick + TRANSPORT_TIME;

        if (currentTick >= arrivalTick) {
            pushToNeighbor(currentTick);
        }
    }

    public boolean insertItem(MatterPayload item, long currentTick) {
        if (this.currentItem != null) return false;
        this.currentItem = item;
        this.arrivalTick = currentTick + TRANSPORT_TIME;
        this.metadata.add("currentItem", item.serialize());
        markDirty();
        return true;
    }

    private void pushToNeighbor(long currentTick) {
        if (gridManager == null) return;
        Vector3Int dirVec = orientation.toVector();
        GridPosition targetPos = new GridPosition(
                pos.x() + dirVec.x(),
                pos.y() + dirVec.y(),
                pos.z() + dirVec.z()
        );
        PlacedMachine neighbor = getNeighborAt(targetPos);
        boolean moved = false;

        if (neighbor instanceof ConveyorBelt nextBelt) {
            moved = nextBelt.insertItem(currentItem, currentTick);
        }
        else if (neighbor instanceof NexusMachine nexus) {
            moved = nexus.insertItem(currentItem, this.pos);
        }
        else if (neighbor instanceof ProcessorMachine processor) {
            moved = processor.insertItem(currentItem, this.pos);
        }
        else if (neighbor instanceof Splitter splitter) {
            // Passiamo this.pos per permettere allo splitter di validare l'ingresso
            moved = splitter.insertItem(currentItem, this.pos);
        }
        else if (neighbor instanceof Merger merger) {
            moved = merger.insertItem(currentItem, this.pos);
        }
        // --- FIX LOGICA: Riconoscimento Lift e Dropper ---
        else if (neighbor instanceof LiftMachine lift) {
            // Il Lift controlla internamente se la Y corrisponde alla base
            moved = lift.insertItem(currentItem, this.pos);
        }
        else if (neighbor instanceof DropperMachine dropper) {
            // Il Dropper controlla internamente se la Y corrisponde all'ingresso alto
            moved = dropper.insertItem(currentItem, this.pos);
        }
        // -------------------------------------------------

        if (moved) {
            this.currentItem = null;
            this.arrivalTick = -1;
            this.metadata.remove("currentItem");
            markDirty();
        }
    }

    @Override
    public JsonObject serialize() {
        super.serialize();
        if (currentItem != null) this.metadata.add("currentItem", currentItem.serialize());
        else this.metadata.remove("currentItem");
        return this.metadata;
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\DrillMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.inventory.MachineInventory;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.matter.MatterShape;
import com.matterworks.core.infrastructure.CoreConfig;

import java.util.UUID;

public class DrillMachine extends PlacedMachine {

    private int tierLevel;
    private float productionSpeed;
    private long nextSpawnTick = -1;
    private final MachineInventory outputBuffer;

    private MatterColor resourceToMine = MatterColor.RAW;

    public DrillMachine(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata, int tierLevel) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.tierLevel = tierLevel;
        this.productionSpeed = tierLevel * 1.0f;
        this.dimensions = new Vector3Int(1, 2, 1);

        int capacity = CoreConfig.getInt("machine.inventory.capacity", 64);
        this.outputBuffer = new MachineInventory(capacity);

        // Caricamento Dati
        if (this.metadata != null) {
            if (this.metadata.has("items")) {
                this.outputBuffer.loadState(this.metadata);
            }
            if (this.metadata.has("mining_resource")) {
                try {
                    this.resourceToMine = MatterColor.valueOf(this.metadata.get("mining_resource").getAsString());
                } catch (Exception e) {
                    this.resourceToMine = MatterColor.RAW;
                }
            }
        }
    }

    public void setResourceToMine(MatterColor resource) {
        this.resourceToMine = resource;
        saveInternalState(); // Salva subito
    }

    @Override
    public void tick(long currentTick) {
        if (nextSpawnTick == -1) {
            nextSpawnTick = currentTick + (long)(20 / productionSpeed);
        }

        if (currentTick >= nextSpawnTick) {
            produceItem();
            nextSpawnTick = currentTick + (long)(20 / productionSpeed);
        }
        tryEjectItem(currentTick);
    }

    private void produceItem() {
        MatterShape shape = (this.resourceToMine == MatterColor.RAW) ? MatterShape.CUBE : null;
        MatterPayload newItem = new MatterPayload(shape, this.resourceToMine);

        if (outputBuffer.insert(newItem)) {
            saveInternalState(); // Usa il metodo sicuro
        }
    }

    private void tryEjectItem(long currentTick) {
        if (outputBuffer.isEmpty()) return;

        // FIX: Usa getNeighborAt per trovare il nastro del proprietario corretto
        // (Assumendo che tu abbia applicato la patch Multi-Tenant precedente)
        Vector3Int dir = orientation.toVector();
        GridPosition targetPos = new GridPosition(pos.x() + dir.x(), pos.y() + dir.y(), pos.z() + dir.z());

        // Se non hai ancora il metodo getNeighborAt nella classe padre, usa:
        // PlacedMachine neighbor = gridManager.getMachineAt(this.ownerId, targetPos);
        PlacedMachine neighbor = getNeighborAt(targetPos);

        if (neighbor instanceof ConveyorBelt belt) {
            MatterPayload item = outputBuffer.extractFirst();
            if (item != null) {
                if (belt.insertItem(item, currentTick)) {
                    saveInternalState(); // FIX: Usa il metodo sicuro invece di sovrascrivere
                } else {
                    outputBuffer.insert(item); // Rollback se il nastro Ã¨ pieno
                }
            }
        }
    }

    /**
     * Metodo centrale per aggiornare i metadati senza perdere pezzi.
     * Unisce lo stato dell'inventario con la configurazione della risorsa.
     */
    private void saveInternalState() {
        // 1. Ottieni il JSON dell'inventario
        JsonObject invState = outputBuffer.serialize();

        // 2. Fai il merge dentro this.metadata invece di sovrascriverlo brutalmente
        this.metadata.add("items", invState.get("items"));
        this.metadata.add("capacity", invState.get("capacity"));

        // 3. Assicura che la risorsa sia sempre salvata
        this.metadata.addProperty("mining_resource", resourceToMine.name());

        // 4. Marca per il salvataggio DB
        markDirty();
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\DropperMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.inventory.MachineInventory;
import com.matterworks.core.domain.matter.MatterPayload;
import java.util.UUID;

public class DropperMachine extends PlacedMachine {

    private final MachineInventory buffer;
    private static final int TRANSPORT_TIME = 5;
    private int cooldown = 0;

    public DropperMachine(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.dimensions = new Vector3Int(1, 2, 1);
        this.buffer = new MachineInventory(1);

        if (this.metadata.has("items")) {
            this.buffer.loadState(this.metadata);
        }
    }

    @Override
    public void tick(long currentTick) {
        if (cooldown > 0) {
            cooldown--;
            return;
        }

        if (!buffer.isEmpty() && buffer.getItemInSlot(0) != null) {
            MatterPayload payload = buffer.getItemInSlot(0);

            // Output: Livello Y=0 (Base), spostato nella direzione dell'orientamento
            GridPosition outPos = this.pos.add(this.orientation.toVector());
            PlacedMachine neighbor = getNeighborAt(outPos);

            if (neighbor == null) return;

            boolean moved = false;

            // Logica instanceof per i vicini
            if (neighbor instanceof ConveyorBelt belt) {
                moved = belt.insertItem(payload, currentTick);
            }
            else if (neighbor instanceof NexusMachine nexus) {
                moved = nexus.insertItem(payload, this.pos);
            }
            else if (neighbor instanceof ProcessorMachine proc) {
                moved = proc.insertItem(payload, this.pos);
            }
            else if (neighbor instanceof Splitter split) {
                moved = split.insertItem(payload, this.pos);
            }
            else if (neighbor instanceof Merger merger) {
                moved = merger.insertItem(payload, this.pos);
            }
            else if (neighbor instanceof LiftMachine lift) {
                moved = lift.insertItem(payload, this.pos);
            }
            else if (neighbor instanceof DropperMachine dropper) {
                moved = dropper.insertItem(payload, this.pos);
            }

            if (moved) {
                buffer.extractFirst();
                cooldown = TRANSPORT_TIME;
                updateMetadata();
            }
        }
    }

    // Rimossa @Override
    public boolean insertItem(MatterPayload item, GridPosition fromPos) {
        if (fromPos == null) return false;

        // Controllo 1: L'input deve essere al livello superiore (y+1)
        if (fromPos.y() != this.pos.y() + 1) {
            return false;
        }

        // Controllo 2: Buffer pieno
        if (!buffer.isEmpty()) {
            return false;
        }

        // Controllo 3: ACCETTA SOLO ConveyorBelt
        PlacedMachine sender = getNeighborAt(fromPos);
        if (!(sender instanceof ConveyorBelt)) {
            return false;
        }

        boolean success = buffer.insertIntoSlot(0, item);
        if (success) {
            updateMetadata();
        }
        return success;
    }

    private void updateMetadata() {
        this.metadata = buffer.serialize();
        this.metadata.addProperty("orientation", this.orientation.name());
        markDirty();
    }

    @Override
    public JsonObject serialize() {
        updateMetadata();
        return this.metadata;
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\IGridComponent.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.ports.IWorldAccess;

public interface IGridComponent {

    void onPlace(IWorldAccess world);

    void onRemove(IWorldAccess world);

    default void onRemove() {
        onRemove(null);
    }

    JsonObject serialize();

    Vector3Int getDimensions();
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\LiftMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.inventory.MachineInventory;
import com.matterworks.core.domain.matter.MatterPayload;
import java.util.UUID;

public class LiftMachine extends PlacedMachine {

    private final MachineInventory buffer;
    private static final int TRANSPORT_TIME = 5;
    private int cooldown = 0;

    public LiftMachine(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.dimensions = new Vector3Int(1, 2, 1);
        this.buffer = new MachineInventory(1);

        if (this.metadata.has("items")) {
            this.buffer.loadState(this.metadata);
        }
    }

    @Override
    public void tick(long currentTick) {
        if (cooldown > 0) {
            cooldown--;
            return;
        }

        // Usa getItemInSlot(0) invece di peek()
        if (!buffer.isEmpty() && buffer.getItemInSlot(0) != null) {
            MatterPayload payload = buffer.getItemInSlot(0);

            // Output: Livello Y+1 (Alto), spostato nella direzione dell'orientamento
            GridPosition outPos = this.pos.add(0, 1, 0).add(this.orientation.toVector());
            PlacedMachine neighbor = getNeighborAt(outPos);

            if (neighbor == null) return;

            boolean moved = false;

            // Logica instanceof per gestire l'inserimento (copiata dal pattern ConveyorBelt)
            if (neighbor instanceof ConveyorBelt belt) {
                // Passiamo la posizione di Uscita Alta come sorgente
                moved = belt.insertItem(payload, currentTick);
            }
            else if (neighbor instanceof NexusMachine nexus) {
                moved = nexus.insertItem(payload, this.pos.add(0, 1, 0));
            }
            else if (neighbor instanceof ProcessorMachine proc) {
                moved = proc.insertItem(payload, this.pos.add(0, 1, 0));
            }
            else if (neighbor instanceof Splitter split) {
                moved = split.insertItem(payload, this.pos.add(0, 1, 0));
            }
            else if (neighbor instanceof Merger merger) {
                moved = merger.insertItem(payload, this.pos.add(0, 1, 0));
            }
            // Supporto concatenazione Lift->Lift o Lift->Dropper
            else if (neighbor instanceof LiftMachine lift) {
                moved = lift.insertItem(payload, this.pos.add(0, 1, 0));
            }
            else if (neighbor instanceof DropperMachine dropper) {
                moved = dropper.insertItem(payload, this.pos.add(0, 1, 0));
            }

            if (moved) {
                buffer.extractFirst();
                cooldown = TRANSPORT_TIME;
                updateMetadata();
            }
        }
    }

    // Rimossa @Override perchÃ© PlacedMachine non ha questo metodo astratto
    public boolean insertItem(MatterPayload item, GridPosition fromPos) {
        if (fromPos == null) return false;

        // Controllo 1: L'input deve essere a livello del terreno (y=0 relativo)
        if (fromPos.y() != this.pos.y()) {
            return false;
        }

        // Controllo 2: Il buffer deve avere spazio
        if (!buffer.isEmpty()) {
            return false;
        }

        // Controllo 3: ACCETTA SOLO ConveyorBelt (Specifica GDD)
        PlacedMachine sender = getNeighborAt(fromPos);
        if (!(sender instanceof ConveyorBelt)) {
            return false;
        }

        // Usa insertIntoSlot per coerenza
        boolean success = buffer.insertIntoSlot(0, item);
        if (success) {
            updateMetadata();
        }
        return success;
    }

    private void updateMetadata() {
        this.metadata = buffer.serialize();
        this.metadata.addProperty("orientation", this.orientation.name());
        markDirty();
    }

    @Override
    public JsonObject serialize() {
        updateMetadata();
        return this.metadata;
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\MachineStats.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.matterworks.core.common.Vector3Int;

/**
 * DTO che rappresenta i dati statici di una macchina caricati dal DB.
 * Allineato con la tabella 'item_definitions' e 'machine_definitions'.
 */
public record MachineStats(
        String id,          // ID dell'item
        Vector3Int dimensions,
        double basePrice,
        int tier,           // NEW
        String modelId,     // NEW
        String category
) {
    public static MachineStats fallback(String id) {
        return new MachineStats(id, Vector3Int.one(), 0.0, 1, "model_missing", "UNKNOWN");
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\Merger.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.inventory.MachineInventory;
import com.matterworks.core.domain.matter.MatterPayload;

import java.util.UUID;

public class Merger extends PlacedMachine {

    private final MachineInventory internalBuffer;
    private long outputCooldownTick = -1;
    private static final int TRANSPORT_TIME = 10;

    // Logica Round Robin & Starvation
    private int preferredInputIndex = 0; // 0 = Anchor Input (A), 1 = Extension Input (B)
    private int starvationTicks = 0;     // Conta da quanto tempo l'input preferito non fornisce items
    private static final int STARVATION_THRESHOLD = 5; // Dopo 5 tick (0.25s) senza input preferito, switcha

    public Merger(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.dimensions = new Vector3Int(2, 1, 1);
        this.internalBuffer = new MachineInventory(1);

        if (this.metadata.has("items")) {
            this.internalBuffer.loadState(this.metadata);
        }
        if (this.metadata.has("preferredInput")) {
            this.preferredInputIndex = this.metadata.get("preferredInput").getAsInt();
        }
        if (!internalBuffer.isEmpty()) {
            this.outputCooldownTick = 0;
        }
    }

    /**
     * Gestisce l'inserimento dagli Input (Belt).
     * Accetta SOLO conveyor belt.
     * Implementa logica Round Robin con fallback.
     */
    public boolean insertItem(MatterPayload item, GridPosition fromPos) {
        if (item == null) return false;
        if (!internalBuffer.isEmpty()) return false; // Buffer pieno, la macchina Ã¨ occupata

        // 1. Validazione Sorgente (Requirement: ACCETTA SOLO BELT)
        PlacedMachine sender = getNeighborAt(fromPos);
        if (!(sender instanceof ConveyorBelt)) {
            return false;
        }

        // 2. Identificazione Slot di Input (A o B)
        int inputIndex = getInputIndexFromPos(fromPos);
        if (inputIndex == -1) return false; // Posizione non valida (non Ã¨ uno degli input posteriori)

        // 3. Logica Round Robin "Smart"
        // Se l'input che sta arrivando NON Ã¨ quello preferito...
        if (inputIndex != preferredInputIndex) {
            // ...lo accettiamo SOLO se abbiamo raggiunto la soglia di starvation (l'altro Ã¨ vuoto)
            // Oppure, per fluiditÃ , se stiamo aspettando l'altro ma questo Ã¨ pronto,
            // tecnicamente il tick loop gestisce lo switch, quindi qui rifiutiamo
            // per forzare l'alternanza corretta quando entrambi spingono.
            return false;
        }

        // 4. Inserimento
        if (internalBuffer.insertIntoSlot(0, item)) {
            // Successo! Switchiamo la preferenza all'altro input per il prossimo item
            togglePreference();
            this.outputCooldownTick = 0; // Resetta timer output
            this.starvationTicks = 0;    // Reset starvation
            saveState();
            return true;
        }

        return false;
    }

    @Override
    public void tick(long currentTick) {
        // Logica Output
        if (!internalBuffer.isEmpty()) {
            if (outputCooldownTick == 0) {
                outputCooldownTick = currentTick + TRANSPORT_TIME;
            }
            if (currentTick >= outputCooldownTick) {
                attemptPushOutput(currentTick);
            }
        } else {
            // Logica Starvation (Solo se vuoto e in attesa)
            // Se stiamo aspettando l'input preferito ma non arriva nulla, incrementiamo il contatore.
            starvationTicks++;
            if (starvationTicks >= STARVATION_THRESHOLD) {
                togglePreference(); // Cambia input preferito perchÃ© l'attuale Ã¨ troppo lento/vuoto
                starvationTicks = 0;
                // Non salviamo stato qui per performance, Ã¨ una variabile volatile di runtime
            }
        }
    }

    private void attemptPushOutput(long currentTick) {
        GridPosition outPos = getOutputPosition();
        PlacedMachine neighbor = getNeighborAt(outPos);
        MatterPayload payload = internalBuffer.getItemInSlot(0);

        if (payload == null || neighbor == null) return;

        boolean pushed = false;

        // Logica standard di push (simile a Conveyor/Splitter)
        if (neighbor instanceof ConveyorBelt belt) {
            pushed = belt.insertItem(payload, currentTick);
        } else if (neighbor instanceof NexusMachine nexus) {
            pushed = nexus.insertItem(payload, this.pos);
        } else if (neighbor instanceof ProcessorMachine proc) {
            pushed = proc.insertItem(payload, this.pos);
        } else if (neighbor instanceof Splitter split) {
            pushed = split.insertItem(payload, this.pos);
        }

        if (pushed) {
            internalBuffer.decreaseSlot(0, 1);
            outputCooldownTick = -1;
            saveState();
        }
    }

    private void togglePreference() {
        this.preferredInputIndex = (this.preferredInputIndex + 1) % 2;
    }

    /**
     * Determina se la posizione di provenienza Ã¨ Input A (0) o Input B (1).
     * Basato sulla geometria 1x1x2 (Width=2).
     * Input A: Retro dell'Anchor.
     * Input B: Retro dell'Estensione.
     */
    private int getInputIndexFromPos(GridPosition checkPos) {
        GridPosition anchorInput = pos.add(orientation.opposite().toVector());
        if (checkPos.equals(anchorInput)) return 0;

        GridPosition extensionPos = getExtensionPosition();
        GridPosition extensionInput = extensionPos.add(orientation.opposite().toVector());
        if (checkPos.equals(extensionInput)) return 1;

        return -1;
    }

    private GridPosition getExtensionPosition() {
        int x = pos.x(); int y = pos.y(); int z = pos.z();
        return switch (orientation) {
            case NORTH -> new GridPosition(x + 1, y, z); // Estensione a destra visiva
            case SOUTH -> new GridPosition(x - 1, y, z);
            case EAST  -> new GridPosition(x, y, z + 1);
            case WEST  -> new GridPosition(x, y, z - 1);
            default -> pos;
        };
    }

    private GridPosition getOutputPosition() {
        // Output Ã¨ sempre davanti all'Anchor
        return pos.add(orientation.toVector());
    }

    private void saveState() {
        JsonObject invData = internalBuffer.serialize();
        this.metadata.add("items", invData.get("items"));
        this.metadata.addProperty("preferredInput", preferredInputIndex);
        markDirty();
    }

    @Override
    public JsonObject serialize() {
        saveState();
        return super.serialize();
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\NexusMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.inventory.MachineInventory;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.shop.MarketManager;

import java.util.UUID;

public class NexusMachine extends PlacedMachine {

    private final MachineInventory storage;
    private long nextSaleTick = -1;
    private static final int SALE_INTERVAL = 10;

    public NexusMachine(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.dimensions = new Vector3Int(3, 3, 3);
        this.storage = new MachineInventory(100);

        if (this.metadata.has("items")) {
            this.storage.loadState(this.metadata);
        }
    }

    @Override
    public void tick(long currentTick) {
        if (storage.isEmpty()) return;
        if (nextSaleTick == -1) nextSaleTick = currentTick + SALE_INTERVAL;

        if (currentTick >= nextSaleTick) {
            sellNextItem();
            nextSaleTick = currentTick + SALE_INTERVAL;
        }
    }

    /**
     * Metodo legacy (non dovrebbe essere usato dai nastri, ma per sicurezza)
     */
    public boolean insertItem(MatterPayload item) {
        return false; // Il Nexus ora richiede una posizione di origine!
    }

    /**
     * NUOVO: Inserimento con validazione geometrica rigorosa.
     */
    public boolean insertItem(MatterPayload item, GridPosition fromPos) {
        if (item.shape() == null) return false; // Rifiuta liquidi/dye
        if (fromPos == null) return false;

        // Validazione Porta: Deve entrare da una delle 6 porte centrali
        if (!isValidInputPort(fromPos)) {
            return false;
        }

        boolean success = storage.insert(item);
        if (success) {
            this.metadata = storage.serialize();
            markDirty();
        }
        return success;
    }

    private boolean isValidInputPort(GridPosition from) {
        int x = pos.x();
        int y = pos.y();
        int z = pos.z();

        // Coordinate relative (delta)
        int dx = from.x() - x;
        int dy = from.y() - y;
        int dz = from.z() - z;

        // Il Nexus accetta input solo ai livelli Y=0 e Y=1 (relativi alla base)
        if (dy < 0 || dy > 1) return false;

        // Logica Porte Centrali (Il Nexus Ã¨ 3x3, centro Ã¨ offset 1)
        // Nord (z-1) -> Entra in (1, y, 0) -> Delta da origine: x=1, z=-1
        if (dx == 1 && dz == -1) return true;
        // Sud (z+3) -> Entra in (1, y, 2) -> Delta da origine: x=1, z=3
        if (dx == 1 && dz == 3) return true;
        // Ovest (x-1) -> Entra in (0, y, 1) -> Delta da origine: x=-1, z=1
        if (dx == -1 && dz == 1) return true;
        // Est (x+3) -> Entra in (2, y, 1) -> Delta da origine: x=3, z=1
        if (dx == 3 && dz == 1) return true;

        return false;
    }

    private void sellNextItem() {
        if (gridManager == null) return;
        MarketManager market = gridManager.getMarketManager();
        if (market == null) return;

        MatterPayload itemToSell = storage.extractFirst();
        if (itemToSell != null) {
            market.sellItem(itemToSell, this.getOwnerId());
            this.metadata = storage.serialize();
            markDirty();
        }
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\PlacedMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.Direction;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.managers.GridManager;
import com.matterworks.core.ports.IWorldAccess;

import java.util.UUID;

public abstract class PlacedMachine implements IGridComponent {

    protected Long dbId;
    protected UUID ownerId;
    protected String typeId;
    protected GridPosition pos;
    protected Direction orientation;
    protected Vector3Int dimensions;
    protected JsonObject metadata;
    protected GridManager gridManager;
    protected boolean isDirty = false;

    public PlacedMachine(Long dbId, UUID ownerId, String typeId, GridPosition pos, JsonObject metadata) {
        this.dbId = dbId;
        this.ownerId = ownerId;
        this.typeId = typeId;
        this.pos = pos;
        this.metadata = metadata != null ? metadata : new JsonObject();

        this.orientation = Direction.NORTH;
        if (this.metadata.has("orientation")) {
            try {
                this.orientation = Direction.valueOf(this.metadata.get("orientation").getAsString());
            } catch (Exception ignored) {
                this.orientation = Direction.NORTH;
            }
        }

        this.dimensions = new Vector3Int(1, 1, 1);
    }

    @Override
    public Vector3Int getDimensions() {
        if (orientation == Direction.EAST || orientation == Direction.WEST) {
            return new Vector3Int(dimensions.z(), dimensions.y(), dimensions.x());
        }
        return dimensions;
    }

    protected PlacedMachine getNeighborAt(GridPosition targetPos) {
        if (gridManager == null) return null;
        return gridManager.getMachineAt(this.ownerId, targetPos);
    }

    public void setOrientation(Direction orientation) {
        this.orientation = orientation != null ? orientation : Direction.NORTH;
        this.metadata.addProperty("orientation", this.orientation.name());
        markDirty();
    }

    public UUID getOwnerId() { return ownerId; }
    public GridPosition getPos() { return pos; }
    public String getTypeId() { return typeId; }
    public Direction getOrientation() { return orientation; }

    public Long getDbId() { return dbId; }
    public void setDbId(Long id) { this.dbId = id; }

    public void setGridContext(GridManager gm) { this.gridManager = gm; }

    public void markDirty() { this.isDirty = true; }
    public boolean isDirty() { return isDirty; }
    public void cleanDirty() { this.isDirty = false; }

    public abstract void tick(long currentTick);

    @Override
    public void onPlace(IWorldAccess world) {
    }

    @Override
    public void onRemove(IWorldAccess world) {
        onRemove();
    }

    public void onRemove() {
    }

    @Override
    public JsonObject serialize() {
        metadata.addProperty("orientation", orientation.name());
        return metadata;
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\ProcessorMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.domain.inventory.MachineInventory;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.matter.Recipe;
import java.util.UUID;

public abstract class ProcessorMachine extends PlacedMachine {

    protected final MachineInventory inputBuffer;
    protected final MachineInventory outputBuffer;
    protected Recipe currentRecipe;
    protected long finishTick = -1;

    protected static final int MAX_INPUT_STACK = 64;
    protected static final int MAX_OUTPUT_STACK = 64;

    public ProcessorMachine(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.inputBuffer = new MachineInventory(2);
        this.outputBuffer = new MachineInventory(1);

        if (this.metadata.has("input")) this.inputBuffer.loadState(this.metadata.getAsJsonObject("input"));
        if (this.metadata.has("output")) this.outputBuffer.loadState(this.metadata.getAsJsonObject("output"));
    }

    protected abstract GridPosition getOutputPosition();
    public abstract boolean insertItem(MatterPayload item, GridPosition fromPos);

    protected boolean insertIntoBuffer(int slotIndex, MatterPayload item) {
        if (inputBuffer.getCountInSlot(slotIndex) >= MAX_INPUT_STACK) return false;
        if (inputBuffer.insertIntoSlot(slotIndex, item)) {
            saveState();
            return true;
        }
        return false;
    }

    protected void completeProcessing() {
        if (currentRecipe != null && outputBuffer.insert(currentRecipe.output())) {
            this.currentRecipe = null;
            this.finishTick = -1;
            saveState();
        }
    }

    protected void tryEjectItem(long currentTick) {
        if (outputBuffer.isEmpty() || gridManager == null) return;

        GridPosition targetPos = getOutputPosition();
        PlacedMachine neighbor = getNeighborAt(targetPos);

        if (neighbor instanceof ConveyorBelt belt) {
            MatterPayload item = outputBuffer.extractFirst();
            if (item != null) {
                if (belt.insertItem(item, currentTick)) {
                    saveState();
                } else {
                    outputBuffer.insert(item); // Rollback se nastro pieno
                }
            }
        } else if (neighbor instanceof NexusMachine nexus) {
            MatterPayload item = outputBuffer.extractFirst();
            if (item != null) {
                if (nexus.insertItem(item, targetPos)) {
                    saveState();
                } else {
                    outputBuffer.insert(item);
                }
            }
        }
    }

    protected void saveState() {
        this.metadata.add("input", inputBuffer.serialize());
        this.metadata.add("output", outputBuffer.serialize());
        markDirty();
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\Splitter.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.inventory.MachineInventory;
import com.matterworks.core.domain.matter.MatterPayload;

import java.util.UUID;

public class Splitter extends PlacedMachine {

    private final MachineInventory internalBuffer;
    private long arrivalTick = -1;
    private int outputIndex = 0; // 0 = Uscita A, 1 = Uscita B
    private static final int TRANSPORT_TIME = 10;

    public Splitter(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.dimensions = new Vector3Int(2, 1, 1);
        this.internalBuffer = new MachineInventory(1);

        if (this.metadata.has("items")) {
            this.internalBuffer.loadState(this.metadata);
        }
        if (this.metadata.has("outputIndex")) {
            this.outputIndex = this.metadata.get("outputIndex").getAsInt();
        }
        if (!internalBuffer.isEmpty()) {
            this.arrivalTick = 0;
        }
    }

    /**
     * Inserimento Items.
     * Accetta input SOLO dal retro dell'Anchor E SOLO se proviene da un nastro.
     */
    public boolean insertItem(MatterPayload item, GridPosition fromPos) {
        if (item == null) return false;
        if (!internalBuffer.isEmpty()) return false;

        // 1. Validazione Posizione (Retro dell'Anchor)
        GridPosition inputSpot = pos.add(orientation.opposite().toVector());
        if (!fromPos.equals(inputSpot)) return false;

        // 2. Validazione Tipo Sorgente (Requirement 1: Solo Belt)
        PlacedMachine sender = getNeighborAt(fromPos);
        if (!(sender instanceof ConveyorBelt)) {
            return false; // Rifiuta input diretti da Drills, Processors, o altri Splitter
        }

        // Inserimento
        if (internalBuffer.insertIntoSlot(0, item)) {
            this.arrivalTick = 0;
            saveState();
            return true;
        }
        return false;
    }

    @Override
    public void tick(long currentTick) {
        if (internalBuffer.isEmpty()) return;

        if (arrivalTick == 0) {
            arrivalTick = currentTick + TRANSPORT_TIME;
        }

        if (currentTick >= arrivalTick) {
            attemptSmartPush(currentTick);
        }
    }

    /**
     * Logica Smart Round Robin (Requirement 2):
     * Tenta l'uscita preferita. Se fallisce, tenta l'alternativa.
     */
    private void attemptSmartPush(long currentTick) {
        // Calcolo Uscite
        GridPosition outA = pos.add(orientation.toVector()); // Davanti Anchor
        GridPosition extensionPos = getExtensionPosition();
        GridPosition outB = extensionPos.add(orientation.toVector()); // Davanti Estensione

        GridPosition[] targets = { outA, outB };
        GridPosition[] sources = { pos, extensionPos };

        // Indice primario (Round Robin attuale)
        int primaryIdx = outputIndex % 2;
        int secondaryIdx = (outputIndex + 1) % 2;

        boolean success = false;

        // Tenta PRIMA l'uscita designata dal Round Robin
        if (pushItem(targets[primaryIdx], sources[primaryIdx], currentTick)) {
            // Se riesce, avanza l'indice normalmente
            outputIndex = secondaryIdx;
            success = true;
        }
        // Se fallisce (bloccata/piena), tenta l'ALTRA uscita (Smart Overflow)
        else if (pushItem(targets[secondaryIdx], sources[secondaryIdx], currentTick)) {
            // Se riesce nell'alternativa, NON avanziamo l'indice
            // (CosÃ¬ al prossimo giro riproverÃ  ancora quella che era bloccata, mantenendo il bilanciamento)
            success = true;
        }

        if (success) {
            internalBuffer.decreaseSlot(0, 1);
            arrivalTick = -1;
            saveState();
        }
    }

    private boolean pushItem(GridPosition targetPos, GridPosition sourcePos, long currentTick) {
        PlacedMachine neighbor = getNeighborAt(targetPos);
        MatterPayload payload = internalBuffer.getItemInSlot(0);

        if (payload == null || neighbor == null) return false;

        if (neighbor instanceof ConveyorBelt belt) {
            return belt.insertItem(payload, currentTick);
        }
        else if (neighbor instanceof NexusMachine nexus) {
            return nexus.insertItem(payload, sourcePos);
        }
        else if (neighbor instanceof ProcessorMachine proc) {
            return proc.insertItem(payload, sourcePos);
        }
        else if (neighbor instanceof Splitter split) {
            return split.insertItem(payload, sourcePos);
        }

        return false;
    }

    private GridPosition getExtensionPosition() {
        int x = pos.x(); int y = pos.y(); int z = pos.z();
        return switch (orientation) {
            case NORTH -> new GridPosition(x + 1, y, z);
            case SOUTH -> new GridPosition(x - 1, y, z);
            case EAST  -> new GridPosition(x, y, z + 1);
            case WEST  -> new GridPosition(x, y, z - 1);
            default -> pos;
        };
    }

    private void saveState() {
        JsonObject invData = internalBuffer.serialize();
        this.metadata.add("items", invData.get("items"));
        this.metadata.addProperty("outputIndex", outputIndex);
        markDirty();
    }

    @Override
    public JsonObject serialize() {
        saveState();
        return super.serialize();
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\domain\machines\StructuralBlock.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.ports.IWorldAccess;
import java.util.UUID;

public class StructuralBlock extends PlacedMachine {

    public StructuralBlock(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.dimensions = new Vector3Int(1, 1, 1);
    }

    /**
     * Costruttore di comodo per il piazzamento diretto.
     */
    public StructuralBlock(UUID ownerId, GridPosition pos, String nativeBlockId) {
        super(null, ownerId, "STRUCTURE_GENERIC", pos, new JsonObject());
        this.metadata.addProperty("native_id", nativeBlockId);
        this.dimensions = new Vector3Int(1, 1, 1);
        // Segniamo come sporco per assicurarci che venga salvato al prossimo autosave se necessario
        markDirty();
    }

    public String getNativeBlockId() {
        if (this.metadata.has("native_id")) {
            return this.metadata.get("native_id").getAsString();
        }
        return "hytale:stone"; // Fallback di sicurezza
    }

    @Override
    public void tick(long currentTick) {
        // Nessuna logica di tick: Ã¨ un blocco strutturale inerte.
    }

    @Override
    public void onPlace(IWorldAccess world) {
        // Delega all'adattatore Hytale il piazzamento del blocco fisico
        if (world != null) {
            world.setBlock(pos, getNativeBlockId());
        }
    }

    @Override
    public void onRemove() {
        // Nessuna logica di rimozione complessa (inventari, etc.)
    }

    // La serializzazione Ã¨ gestita dalla classe padre PlacedMachine che salva 'metadata'
}
