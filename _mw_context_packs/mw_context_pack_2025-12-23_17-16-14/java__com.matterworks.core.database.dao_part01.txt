=== BUNDLE: java__com.matterworks.core.database.dao_part01 ===
Created: 2025-12-23T17:16:22.8501712+01:00



--------------------------------
FILE: src\main\java\com\matterworks\core\database\dao\InventoryDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.UUID;

public class InventoryDAO {

    private final DatabaseManager db;

    public InventoryDAO(DatabaseManager db) {
        this.db = db;
    }

    public int getItemCount(UUID playerUuid, String itemId) {
        String sql = "SELECT quantity FROM player_inventory WHERE player_uuid = ? AND item_id = ?";
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setBytes(1, UuidUtils.asBytes(playerUuid));
            ps.setString(2, itemId);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) return rs.getInt("quantity");
            }
        } catch (SQLException e) { e.printStackTrace(); }
        return 0;
    }

    public void modifyItemCount(UUID playerUuid, String itemId, int delta) {
        // UPSERT: Se esiste aggiorna, se no inserisce.
        // GREATEST(0, ...) assicura che non andiamo mai in negativo nel DB
        String sql = """
            INSERT INTO player_inventory (player_uuid, item_id, quantity) 
            VALUES (?, ?, ?) 
            ON DUPLICATE KEY UPDATE quantity = GREATEST(0, quantity + VALUES(quantity))
        """;

        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setBytes(1, UuidUtils.asBytes(playerUuid));
            ps.setString(2, itemId);
            // Se delta Ã¨ negativo (es. -1), l'inventario scende. Se positivo, sale.
            ps.setInt(3, Math.max(0, delta)); // Nota: per l'insert iniziale assumiamo positivo o 0

            // Correzione per la logica SQL pura:
            // La query sopra funziona bene per INSERT. Ma per l'UPDATE vogliamo sommare il delta.
            // Sostituiamo con una query piÃ¹ esplicita per gestire il delta correttamente in Java

            doModify(conn, playerUuid, itemId, delta);

        } catch (SQLException e) { e.printStackTrace(); }
    }

    private void doModify(Connection conn, UUID uuid, String itemId, int delta) throws SQLException {
        // 1. Controlla esistenza
        String checkSql = "SELECT quantity FROM player_inventory WHERE player_uuid = ? AND item_id = ?";
        int current = 0;
        boolean exists = false;

        try (PreparedStatement ps = conn.prepareStatement(checkSql)) {
            ps.setBytes(1, UuidUtils.asBytes(uuid));
            ps.setString(2, itemId);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    current = rs.getInt("quantity");
                    exists = true;
                }
            }
        }

        int newVal = Math.max(0, current + delta);

        if (exists) {
            String update = "UPDATE player_inventory SET quantity = ? WHERE player_uuid = ? AND item_id = ?";
            try (PreparedStatement ps = conn.prepareStatement(update)) {
                ps.setInt(1, newVal);
                ps.setBytes(2, UuidUtils.asBytes(uuid));
                ps.setString(3, itemId);
                ps.executeUpdate();
            }
        } else if (newVal > 0) {
            String insert = "INSERT INTO player_inventory (player_uuid, item_id, quantity) VALUES (?, ?, ?)";
            try (PreparedStatement ps = conn.prepareStatement(insert)) {
                ps.setBytes(1, UuidUtils.asBytes(uuid));
                ps.setString(2, itemId);
                ps.setInt(3, newVal);
                ps.executeUpdate();
            }
        }
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\database\dao\MachineDefinitionDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.domain.machines.MachineStats;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

public class MachineDefinitionDAO {

    private final DatabaseManager db;

    // Query JOIN aggiornata con le nuove colonne
    private static final String SELECT_JOINED_STATS = """
        SELECT 
            i.id, 
            i.category,
            i.base_price, 
            i.tier,
            i.model_id,
            m.width, 
            m.height, 
            m.depth
        FROM item_definitions i
        JOIN machine_definitions m ON i.id = m.type_id
    """;

    public MachineDefinitionDAO(DatabaseManager db) {
        this.db = db;
    }

    public Map<String, MachineStats> loadAllDefinitions() {
        Map<String, MachineStats> statsMap = new HashMap<>();

        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(SELECT_JOINED_STATS);
             ResultSet rs = ps.executeQuery()) {

            while (rs.next()) {
                String id = rs.getString("id");

                // Lettura nuovi campi
                String category = rs.getString("category");
                double price = rs.getDouble("base_price");
                int tier = rs.getInt("tier");
                String modelId = rs.getString("model_id");

                Vector3Int dim = new Vector3Int(
                        rs.getInt("width"),
                        rs.getInt("height"),
                        rs.getInt("depth")
                );

                statsMap.put(id, new MachineStats(id, dim, price, tier, modelId, category));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return statsMap;
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\database\dao\PlayerDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils;
import com.matterworks.core.domain.player.PlayerProfile;

import java.lang.reflect.Type;
import java.sql.*;
import java.util.*;

public class PlayerDAO {

    private final DatabaseManager db;
    private final Gson gson = new Gson();

    private static final String UPSERT_SQL = """
        INSERT INTO players (uuid, username, money, void_coins, prestige_level, rank, tech_unlocks)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        ON DUPLICATE KEY UPDATE
            username = VALUES(username),
            money = VALUES(money),
            void_coins = VALUES(void_coins),
            prestige_level = VALUES(prestige_level),
            rank = VALUES(rank),
            tech_unlocks = VALUES(tech_unlocks)
    """;

    private static final String SELECT_SQL = "SELECT * FROM players WHERE uuid = ?";

    public PlayerDAO(DatabaseManager db) {
        this.db = db;
    }

    public void save(PlayerProfile p) {
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(UPSERT_SQL)) {

            ps.setBytes(1, UuidUtils.asBytes(p.getPlayerId()));
            ps.setString(2, p.getUsername());
            ps.setDouble(3, p.getMoney());
            ps.setInt(4, p.getVoidCoins());
            ps.setInt(5, p.getPrestigeLevel());
            ps.setString(6, p.getRank().name());

            String techJson = gson.toJson(p.getUnlockedTechs() != null ? p.getUnlockedTechs() : Set.of());
            ps.setString(7, techJson);

            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public PlayerProfile load(UUID uuid) {
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(SELECT_SQL)) {

            ps.setBytes(1, UuidUtils.asBytes(uuid));
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) return null;

                PlayerProfile p = new PlayerProfile(uuid);
                p.setUsername(rs.getString("username"));
                p.setMoney(rs.getDouble("money"));
                p.setVoidCoins(rs.getInt("void_coins"));
                p.setPrestigeLevel(rs.getInt("prestige_level"));

                String rankStr = rs.getString("rank");
                if (rankStr != null) {
                    try { p.setRank(PlayerProfile.PlayerRank.valueOf(rankStr)); }
                    catch (Exception ignored) { p.setRank(PlayerProfile.PlayerRank.PLAYER); }
                } else {
                    p.setRank(PlayerProfile.PlayerRank.PLAYER);
                }

                String techJson = rs.getString("tech_unlocks");
                if (techJson != null && !techJson.isBlank()) {
                    try {
                        Type setType = new TypeToken<HashSet<String>>(){}.getType();
                        Set<String> unlocks = gson.fromJson(techJson, setType);
                        if (unlocks != null) unlocks.forEach(p::addTech);
                    } catch (Exception ex) {
                        System.err.println("âš ï¸ Warning: tech_unlocks invalid for " + uuid + " -> using empty set.");
                    }
                }

                return p;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public List<PlayerProfile> loadAll() {
        List<PlayerProfile> players = new ArrayList<>();
        String sql = "SELECT uuid FROM players";
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql);
             ResultSet rs = ps.executeQuery()) {

            while (rs.next()) {
                UUID id = UuidUtils.asUuid(rs.getBytes("uuid"));
                PlayerProfile p = load(id);
                if (p != null) players.add(p);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return players;
    }

    // ==========================================================
    // SESSIONS (player_sessions)
    // ==========================================================

    public void openSession(UUID uuid) {
        if (uuid == null) return;

        try (Connection conn = db.getConnection()) {
            conn.setAutoCommit(false);
            try {
                try (PreparedStatement closeOld = conn.prepareStatement(
                        "UPDATE player_sessions SET logout_at = CURRENT_TIMESTAMP WHERE player_uuid = ? AND logout_at IS NULL")) {
                    closeOld.setBytes(1, UuidUtils.asBytes(uuid));
                    closeOld.executeUpdate();
                }

                try (PreparedStatement ins = conn.prepareStatement(
                        "INSERT INTO player_sessions (player_uuid, login_at, logout_at) VALUES (?, CURRENT_TIMESTAMP, NULL)")) {
                    ins.setBytes(1, UuidUtils.asBytes(uuid));
                    ins.executeUpdate();
                }

                try (PreparedStatement upd = conn.prepareStatement(
                        "UPDATE players SET last_login = CURRENT_TIMESTAMP WHERE uuid = ?")) {
                    upd.setBytes(1, UuidUtils.asBytes(uuid));
                    upd.executeUpdate();
                }

                conn.commit();
            } catch (SQLException ex) {
                conn.rollback();
                ex.printStackTrace();
            } finally {
                conn.setAutoCommit(true);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public void closeSession(UUID uuid) {
        if (uuid == null) return;

        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(
                     "UPDATE player_sessions SET logout_at = CURRENT_TIMESTAMP WHERE player_uuid = ? AND logout_at IS NULL")) {

            ps.setBytes(1, UuidUtils.asBytes(uuid));
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public boolean hasOpenSession(UUID uuid) {
        if (uuid == null) return false;

        String sql = "SELECT 1 FROM player_sessions WHERE player_uuid = ? AND logout_at IS NULL LIMIT 1";
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {

            ps.setBytes(1, UuidUtils.asBytes(uuid));
            try (ResultSet rs = ps.executeQuery()) {
                return rs.next();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return false;
    }

    public Long getLastLogoutMillis(UUID uuid) {
        if (uuid == null) return null;

        String sql = "SELECT MAX(logout_at) AS last_out FROM player_sessions WHERE player_uuid = ? AND logout_at IS NOT NULL";
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {

            ps.setBytes(1, UuidUtils.asBytes(uuid));
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) return null;
                Timestamp ts = rs.getTimestamp("last_out");
                return ts != null ? ts.getTime() : null;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\database\dao\PlotDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils;
import com.matterworks.core.model.PlotObject;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class PlotDAO {

    private final DatabaseManager dbManager;

    public PlotDAO(DatabaseManager dbManager) {
        this.dbManager = dbManager;
    }

    public Long findPlotIdByOwner(UUID ownerId) {
        String sql = "SELECT id FROM plots WHERE owner_id = ?";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setBytes(1, UuidUtils.asBytes(ownerId));
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) return rs.getLong("id");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    // --- FIX: Ora restituisce Long (ID Generato) ---
    public Long createPlot(UUID ownerId, int x, int z, int worldId) {
        String sql = "INSERT INTO plots (owner_id, x, z, world_id, allocation_index, world_x, world_z, expansion_tier, is_active) VALUES (?, ?, ?, ?, 0, 0, 0, 0, 1)";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setBytes(1, UuidUtils.asBytes(ownerId));
            stmt.setInt(2, x);
            stmt.setInt(3, z);
            stmt.setInt(4, worldId);

            int affectedRows = stmt.executeUpdate();
            if (affectedRows > 0) {
                try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        Long id = generatedKeys.getLong(1);
                        System.out.println("âœ… Plot creato con ID: " + id + " per " + ownerId);
                        return id;
                    }
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public Long insertMachine(UUID ownerId, String typeId, int x, int y, int z, String metadataJson) {
        Long plotId = findPlotIdByOwner(ownerId);
        if (plotId == null) {
            System.err.println("âŒ Nessun plot trovato per salvare la macchina!");
            return null;
        }

        String sql = "INSERT INTO plot_machines (plot_id, type_id, x, y, z, metadata) VALUES (?, ?, ?, ?, ?, ?)";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setLong(1, plotId);
            stmt.setString(2, typeId);
            stmt.setInt(3, x);
            stmt.setInt(4, y);
            stmt.setInt(5, z);
            stmt.setString(6, metadataJson);

            int affected = stmt.executeUpdate();
            if (affected > 0) {
                try (ResultSet rs = stmt.getGeneratedKeys()) {
                    if (rs.next()) return rs.getLong(1);
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public List<PlotObject> loadMachines(UUID ownerId) {
        List<PlotObject> machines = new ArrayList<>();
        String sql = "SELECT pm.id, pm.plot_id, pm.type_id, pm.x, pm.y, pm.z, pm.metadata FROM plot_machines pm JOIN plots p ON pm.plot_id = p.id WHERE p.owner_id = ?";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setBytes(1, UuidUtils.asBytes(ownerId));
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    String metaStr = rs.getString("metadata");
                    JsonObject metaJson = new JsonObject();
                    if (metaStr != null && !metaStr.isBlank()) {
                        try { metaJson = JsonParser.parseString(metaStr).getAsJsonObject(); }
                        catch (Exception ignored) {}
                    }
                    machines.add(new PlotObject(
                            rs.getLong("id"), rs.getLong("plot_id"),
                            rs.getInt("x"), rs.getInt("y"), rs.getInt("z"),
                            rs.getString("type_id"), metaJson
                    ));
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return machines;
    }

    public void removeMachine(Long dbId) {
        if (dbId == null) return;
        String sql = "DELETE FROM plot_machines WHERE id = ?";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, dbId);
            stmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\database\dao\PlotObjectDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.model.PlotObject;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class PlotObjectDAO {

    private final DatabaseManager db;

    // --- FIX: USIAMO UPSERT INVECE DI INSERT ---
    // Se la combinazione (plot_id, x, y, z) esiste giÃ  (Unique Key),
    // aggiorniamo solo i metadati e il tipo, invece di dare errore.
    private static final String UPSERT_SQL = """
        INSERT INTO plot_objects (plot_id, x, y, z, type_id, meta_data)
        VALUES (?, ?, ?, ?, ?, ?)
        ON DUPLICATE KEY UPDATE 
            meta_data = VALUES(meta_data),
            type_id = VALUES(type_id)
    """;

    private static final String SELECT_SQL = "SELECT * FROM plot_objects WHERE plot_id = ?";
    private static final String DELETE_SQL = "DELETE FROM plot_objects WHERE id = ?";

    public PlotObjectDAO(DatabaseManager db) {
        this.db = db;
    }

    public void placeMachine(PlotObject obj) {
        // Usiamo Statement.RETURN_GENERATED_KEYS per ottenere l'ID se Ã¨ un nuovo inserimento
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(UPSERT_SQL, Statement.RETURN_GENERATED_KEYS)) {

            ps.setLong(1, obj.getPlotId());
            ps.setInt(2, obj.getX());
            ps.setInt(3, obj.getY());
            ps.setInt(4, obj.getZ());
            ps.setString(5, obj.getTypeId());
            // Gestione metadati sicura
            ps.setString(6, obj.getMetaData() != null ? obj.getMetaData().toString() : "{}");

            ps.executeUpdate();

            // Se Ã¨ stato un INSERT (nuova macchina), prendiamo l'ID.
            // Se Ã¨ stato un UPDATE, l'ID non cambia (lo abbiamo giÃ  in obj.id solitamente).
            try (ResultSet rs = ps.getGeneratedKeys()) {
                if (rs.next()) {
                    long newId = rs.getLong(1);
                    // Aggiorniamo l'ID solo se ne abbiamo ricevuto uno valido (cioÃ¨ era un insert)
                    if (newId > 0) {
                        obj.setId(newId);
                    }
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public List<PlotObject> loadPlotMachines(Long plotId) {
        List<PlotObject> machines = new ArrayList<>();
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(SELECT_SQL)) {

            ps.setLong(1, plotId);

            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    PlotObject obj = new PlotObject();
                    obj.setId(rs.getLong("id"));
                    obj.setPlotId(plotId);
                    obj.setX(rs.getInt("x"));
                    obj.setY(rs.getInt("y"));
                    obj.setZ(rs.getInt("z"));
                    obj.setTypeId(rs.getString("type_id"));

                    // Parsing JSON sicuro
                    String metaStr = rs.getString("meta_data");
                    if (metaStr != null) {
                        obj.setMetaDataFromString(metaStr);
                    }

                    machines.add(obj);
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return machines;
    }

    public void deleteMachine(Long dbId) {
        if (dbId == null) return;

        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(DELETE_SQL)) {

            ps.setLong(1, dbId);
            ps.executeUpdate();
            System.out.println("ðŸ—‘ï¸ DB: Cancellata riga ID " + dbId);

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\database\dao\PlotResourceDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.common.GridPosition;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.domain.matter.MatterColor;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

public class PlotResourceDAO {

    private final DatabaseManager db;

    public PlotResourceDAO(DatabaseManager db) {
        this.db = db;
    }

    // UPDATE: Long plotId
    public void addResource(Long plotId, int x, int z, MatterColor type) {
        String sql = "INSERT INTO plot_resources (plot_id, x, z, resource_type) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE resource_type = VALUES(resource_type)";

        try (Connection conn = db.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, plotId); // setLong
            stmt.setInt(2, x);
            stmt.setInt(3, z);
            stmt.setString(4, type.name());
            stmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // UPDATE: Long plotId
    public Map<GridPosition, MatterColor> loadResources(Long plotId) {
        Map<GridPosition, MatterColor> resources = new HashMap<>();
        String sql = "SELECT x, z, resource_type FROM plot_resources WHERE plot_id = ?";

        try (Connection conn = db.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, plotId); // setLong

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    int x = rs.getInt("x");
                    int z = rs.getInt("z");
                    String typeStr = rs.getString("resource_type");

                    try {
                        MatterColor color = MatterColor.valueOf(typeStr);
                        resources.put(new GridPosition(x, 0, z), color);
                    } catch (IllegalArgumentException e) {
                        System.err.println("âš ï¸ Risorsa ignota nel DB: " + typeStr);
                    }
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return resources;
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\database\dao\TechDefinitionDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.managers.TechManager.TechNode;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class TechDefinitionDAO {

    private final DatabaseManager db;
    private final Gson gson = new Gson();

    public TechDefinitionDAO(DatabaseManager db) {
        this.db = db;
    }

    public List<TechNode> loadAllNodes() {
        List<TechNode> nodes = new ArrayList<>();
        String sql = "SELECT node_id, name_display, cost_money, parent_node_ids, unlock_machine_ids FROM tech_definitions";

        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql);
             ResultSet rs = ps.executeQuery()) {

            while (rs.next()) {
                String id = rs.getString("node_id");
                String name = rs.getString("name_display");
                double cost = rs.getDouble("cost_money");

                // Deserializzazione liste JSON
                List<String> parents = parseJsonList(rs.getString("parent_node_ids"));
                List<String> unlocks = parseJsonList(rs.getString("unlock_machine_ids"));

                nodes.add(new TechNode(id, name, cost, parents, unlocks));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return nodes;
    }

    private List<String> parseJsonList(String json) {
        if (json == null || json.isBlank() || json.equals("null")) {
            return new ArrayList<>();
        }
        try {
            return gson.fromJson(json, new TypeToken<List<String>>(){}.getType());
        } catch (Exception e) {
            System.err.println("âš ï¸ JSON Parse Error in TechDefinitionDAO: " + json);
            return new ArrayList<>();
        }
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\database\dao\TransactionDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils;
import com.matterworks.core.domain.player.PlayerProfile;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class TransactionDAO {

    private final DatabaseManager db;

    private static final String INSERT_SQL = """
        INSERT INTO transactions (
            player_uuid, username, money_balance, void_coins_balance, prestige_level, 
            action_type, currency, amount, item_id, occurred_at
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
    """;

    public TransactionDAO(DatabaseManager db) {
        this.db = db;
    }

    public void logTransaction(PlayerProfile p, String type, String currency, BigDecimal amount, String itemId) {
        new Thread(() -> {
            try (Connection conn = db.getConnection();
                 PreparedStatement ps = conn.prepareStatement(INSERT_SQL)) {

                ps.setBytes(1, UuidUtils.asBytes(p.getPlayerId()));
                ps.setString(2, p.getUsername());
                ps.setBigDecimal(3, BigDecimal.valueOf(p.getMoney()));
                ps.setInt(4, p.getVoidCoins());
                ps.setInt(5, p.getPrestigeLevel());
                ps.setString(6, type);
                ps.setString(7, currency);
                ps.setBigDecimal(8, amount);
                ps.setString(9, itemId);

                ps.executeUpdate();

            } catch (SQLException e) {
                System.err.println("FAILED TO LOG TRANSACTION: " + e.getMessage());
            }
        }).start();
    }
}


--------------------------------
FILE: src\main\java\com\matterworks\core\database\dao\VerificationCodeDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils;
import com.matterworks.core.domain.player.LinkCode; // Importante: Usa il Dominio

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.UUID;

public class VerificationCodeDAO {

    private final DatabaseManager db;

    private static final String INSERT_CODE = """
        INSERT INTO verification_codes (code, player_uuid, expires_at)
        VALUES (?, ?, ?)
    """;

    public VerificationCodeDAO(DatabaseManager db) {
        this.db = db;
    }

    public void saveCode(UUID playerUuid, LinkCode linkCode) {
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(INSERT_CODE)) {

            ps.setString(1, linkCode.code());
            ps.setBytes(2, UuidUtils.asBytes(playerUuid));
            // Convertiamo il long (millisecondi) in Timestamp SQL
            ps.setTimestamp(3, new Timestamp(linkCode.expirationTime()));

            ps.executeUpdate();

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
