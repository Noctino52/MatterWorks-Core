

--------------------------------
FILE: Main.java
--------------------------------
package com.matterworks;

//TIP To <b>Run</b> code, press <shortcut actionId="Run"/> or
// click the <icon src="AllIcons.Actions.Execute"/> icon in the gutter.
public class Main {
    public static void main(String[] args) {
        //TIP Press <shortcut actionId="ShowIntentionActions"/> with your caret at the highlighted text
        // to see how IntelliJ IDEA suggests fixing it.
        System.out.printf("Hello and welcome!");

        for (int i = 1; i <= 5; i++) {
            //TIP Press <shortcut actionId="Debug"/> to start debugging your code. We have set one <icon src="AllIcons.Debugger.Db_set_breakpoint"/> breakpoint
            // for you, but you can always add more by pressing <shortcut actionId="ToggleLineBreakpoint"/>.
            System.out.println("i = " + i);
        }
    }
}


--------------------------------
FILE: Main.java
--------------------------------
package com.matterworks.core;

import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.domain.machines.BlockRegistry;
import com.matterworks.core.database.dao.MachineDefinitionDAO;
import com.matterworks.core.domain.player.PlayerProfile;
import com.matterworks.core.infrastructure.CoreConfig;
import com.matterworks.core.infrastructure.MariaDBAdapter;
import com.matterworks.core.infrastructure.swing.MatterWorksGUI;
import com.matterworks.core.managers.GridManager;
import com.matterworks.core.managers.WorldIntegrityValidator;
import com.matterworks.core.ports.IRepository;
import com.matterworks.core.ports.IWorldAccess;
import com.matterworks.core.synchronization.FactoryLoop;
import com.matterworks.core.synchronization.GridSaverService;

import javax.swing.SwingUtilities;
import java.awt.GraphicsEnvironment;
import java.util.UUID;

public class Main {

    public static void main(String[] args) throws InterruptedException {
        System.out.println("ðŸ„ MatterWorks Core Starting...");
        CoreConfig.load();

        String url = "jdbc:mariadb://dev.matterworks.org:3306/matterworks_core?allowPublicKeyRetrieval=true&useSSL=false";
        DatabaseManager dbManager = new DatabaseManager(url, "Noctino52", "Yy72s7mRnVs3");

        IWorldAccess world = new MockWorld();
        MachineDefinitionDAO defDao = new MachineDefinitionDAO(dbManager);
        BlockRegistry blockRegistry = new BlockRegistry(world, defDao);
        blockRegistry.loadFromDatabase();

        WorldIntegrityValidator validator = new WorldIntegrityValidator(dbManager, blockRegistry);
        if (!validator.validateWorldIntegrity()) {
            System.err.println("ðŸš¨ ATTENZIONE: Il mondo contiene collisioni!");
        }

        IRepository repository = new MariaDBAdapter(dbManager);
        GridManager gridManager = new GridManager(repository, world, blockRegistry);
        GridSaverService saverService = new GridSaverService(gridManager, repository);

        FactoryLoop gameLoop = new FactoryLoop(gridManager);
        gameLoop.start();

        UUID playerUuid = UUID.fromString("550e8400-e29b-41d4-a716-446655440000");
        ensurePlayerExists(dbManager, playerUuid);

        // Ora questo metodo esiste e carica il plot nella simulazione globale
        gridManager.loadPlotFromDB(playerUuid);

        if (!GraphicsEnvironment.isHeadless()) {
            SwingUtilities.invokeLater(() -> {
                new MatterWorksGUI(
                        gridManager,
                        blockRegistry,
                        playerUuid,
                        () -> {
                            System.out.println("ðŸ’¾ Saving...");
                            saverService.autoSaveTask();
                        },
                        repository
                );
            });
        }

        while (true) {
            Thread.sleep(10000);
            saverService.autoSaveTask();
        }
    }

    private static void ensurePlayerExists(DatabaseManager db, UUID uuid) {
        com.matterworks.core.database.dao.PlayerDAO playerDao = new com.matterworks.core.database.dao.PlayerDAO(db);
        PlayerProfile p = playerDao.load(uuid);
        if (p == null) {
            p = new PlayerProfile(uuid);
            p.setUsername("Noctino_Dev");
            p.setMoney(1000.0);
            p.setRank(PlayerProfile.PlayerRank.ADMIN);
            playerDao.save(p);
        }
    }

    static class MockWorld implements IWorldAccess {
        @Override public void setBlock(com.matterworks.core.common.GridPosition pos, String id) {}
        @Override public boolean isBlockSolid(com.matterworks.core.common.GridPosition pos) { return true; }
        @Override public void createVisuals(com.matterworks.core.common.GridPosition pos, String id) {}
        @Override public com.matterworks.core.common.Vector3Int fetchExternalBlockDimensions(String id) { return com.matterworks.core.common.Vector3Int.one(); }
    }
}


--------------------------------
FILE: Direction.java
--------------------------------
package com.matterworks.core.common;

public enum Direction {
    NORTH(0, 0, -1),
    EAST(1, 0, 0),
    SOUTH(0, 0, 1),
    WEST(-1, 0, 0),
    UP(0, 1, 0),
    DOWN(0, -1, 0);

    private final int x, y, z;

    Direction(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public Vector3Int toVector() {
        return new Vector3Int(x, y, z);
    }

    public Direction opposite() {
        return switch(this) {
            case NORTH -> SOUTH;
            case SOUTH -> NORTH;
            case EAST -> WEST;
            case WEST -> EAST;
            case UP -> DOWN;
            case DOWN -> UP;
        };
    }
}


--------------------------------
FILE: GridPosition.java
--------------------------------
package com.matterworks.core.common;

/**
 * Value Object immutabile che rappresenta una coordinata 3D nel mondo.
 * Usato come chiave primaria nelle HashMap del GridManager per accesso O(1).
 */
public record GridPosition(int x, int y, int z) {

    /**
     * Factory method statico per leggibilitÃ  (opzionale ma comodo).
     * Uso: GridPosition.of(10, 64, 10)
     */
    public static GridPosition of(int x, int y, int z) {
        return new GridPosition(x, y, z);
    }

    /**
     * Metodo di utilitÃ  per calcolare posizioni relative (es. "il blocco sopra").
     * Utile per logica di nastri trasportatori o controlli di adiacenza.
     */
    public GridPosition add(int dx, int dy, int dz) {
        return new GridPosition(x + dx, y + dy, z + dz);
    }

    public GridPosition add(Vector3Int vec) {
        return new GridPosition(x + vec.x(), y + vec.y(), z + vec.z());
    }

    // Nota: equals(), hashCode() e toString() sono generati automaticamente dal Record.
}


--------------------------------
FILE: Vector3Int.java
--------------------------------
package com.matterworks.core.common;

/**
 * Value Object semplice per le dimensioni (Width, Height, Depth).
 * Usato da IGridComponent.
 */
public record Vector3Int(int x, int y, int z) {
    public static Vector3Int one() { return new Vector3Int(1, 1, 1); }
}


--------------------------------
FILE: DatabaseManager.java
--------------------------------
package com.matterworks.core.database;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.sql.Connection;
import java.sql.SQLException;

public class DatabaseManager {

    private final HikariDataSource dataSource;

    public DatabaseManager(String jdbcUrl, String username, String password) {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(username);
        config.setPassword(password);

        // Ottimizzazioni per Gaming (Bassa latenza)
        config.setMaximumPoolSize(10);
        config.setMinimumIdle(2);
        config.setIdleTimeout(30000);
        config.setConnectionTimeout(2000); // Fail fast se il DB Ã¨ giÃ¹

        this.dataSource = new HikariDataSource(config);
    }

    public Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }

    public void close() {
        if (dataSource != null) {
            dataSource.close();
        }
    }
}


--------------------------------
FILE: UuidUtils.java
--------------------------------
package com.matterworks.core.database;

import java.nio.ByteBuffer;
import java.util.UUID;

public class UuidUtils {

    public static byte[] asBytes(UUID uuid) {
        if (uuid == null) return null;
        ByteBuffer bb = ByteBuffer.wrap(new byte[16]);
        bb.putLong(uuid.getMostSignificantBits());
        bb.putLong(uuid.getLeastSignificantBits());
        return bb.array();
    }

    public static UUID asUuid(byte[] bytes) {
        if (bytes == null || bytes.length != 16) return null;
        ByteBuffer bb = ByteBuffer.wrap(bytes);
        long firstLong = bb.getLong();
        long secondLong = bb.getLong();
        return new UUID(firstLong, secondLong);
    }
}


--------------------------------
FILE: InventoryDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.UUID;

public class InventoryDAO {

    private final DatabaseManager db;

    public InventoryDAO(DatabaseManager db) {
        this.db = db;
    }

    public int getItemCount(UUID playerUuid, String itemId) {
        String sql = "SELECT quantity FROM player_inventory WHERE player_uuid = ? AND item_id = ?";
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setBytes(1, UuidUtils.asBytes(playerUuid));
            ps.setString(2, itemId);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) return rs.getInt("quantity");
            }
        } catch (SQLException e) { e.printStackTrace(); }
        return 0;
    }

    public void modifyItemCount(UUID playerUuid, String itemId, int delta) {
        // UPSERT: Se esiste aggiorna, se no inserisce.
        // GREATEST(0, ...) assicura che non andiamo mai in negativo nel DB
        String sql = """
            INSERT INTO player_inventory (player_uuid, item_id, quantity) 
            VALUES (?, ?, ?) 
            ON DUPLICATE KEY UPDATE quantity = GREATEST(0, quantity + VALUES(quantity))
        """;

        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setBytes(1, UuidUtils.asBytes(playerUuid));
            ps.setString(2, itemId);
            // Se delta Ã¨ negativo (es. -1), l'inventario scende. Se positivo, sale.
            ps.setInt(3, Math.max(0, delta)); // Nota: per l'insert iniziale assumiamo positivo o 0

            // Correzione per la logica SQL pura:
            // La query sopra funziona bene per INSERT. Ma per l'UPDATE vogliamo sommare il delta.
            // Sostituiamo con una query piÃ¹ esplicita per gestire il delta correttamente in Java

            doModify(conn, playerUuid, itemId, delta);

        } catch (SQLException e) { e.printStackTrace(); }
    }

    private void doModify(Connection conn, UUID uuid, String itemId, int delta) throws SQLException {
        // 1. Controlla esistenza
        String checkSql = "SELECT quantity FROM player_inventory WHERE player_uuid = ? AND item_id = ?";
        int current = 0;
        boolean exists = false;

        try (PreparedStatement ps = conn.prepareStatement(checkSql)) {
            ps.setBytes(1, UuidUtils.asBytes(uuid));
            ps.setString(2, itemId);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    current = rs.getInt("quantity");
                    exists = true;
                }
            }
        }

        int newVal = Math.max(0, current + delta);

        if (exists) {
            String update = "UPDATE player_inventory SET quantity = ? WHERE player_uuid = ? AND item_id = ?";
            try (PreparedStatement ps = conn.prepareStatement(update)) {
                ps.setInt(1, newVal);
                ps.setBytes(2, UuidUtils.asBytes(uuid));
                ps.setString(3, itemId);
                ps.executeUpdate();
            }
        } else if (newVal > 0) {
            String insert = "INSERT INTO player_inventory (player_uuid, item_id, quantity) VALUES (?, ?, ?)";
            try (PreparedStatement ps = conn.prepareStatement(insert)) {
                ps.setBytes(1, UuidUtils.asBytes(uuid));
                ps.setString(2, itemId);
                ps.setInt(3, newVal);
                ps.executeUpdate();
            }
        }
    }
}


--------------------------------
FILE: MachineDefinitionDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.domain.machines.MachineStats;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

public class MachineDefinitionDAO {

    private final DatabaseManager db;

    // JOIN per prendere Prezzo (item_definitions) e Dimensioni (machine_definitions)
    private static final String SELECT_JOINED_STATS = """
        SELECT 
            i.id, 
            i.base_price, 
            i.category,
            m.width, 
            m.height, 
            m.depth
        FROM item_definitions i
        JOIN machine_definitions m ON i.id = m.type_id
    """;

    public MachineDefinitionDAO(DatabaseManager db) {
        this.db = db;
    }

    public Map<String, MachineStats> loadAllDefinitions() {
        Map<String, MachineStats> statsMap = new HashMap<>();

        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(SELECT_JOINED_STATS);
             ResultSet rs = ps.executeQuery()) {

            while (rs.next()) {
                String id = rs.getString("id");
                double price = rs.getDouble("base_price");

                Vector3Int dim = new Vector3Int(
                        rs.getInt("width"),
                        rs.getInt("height"),
                        rs.getInt("depth")
                );

                statsMap.put(id, new MachineStats(dim, price, id));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return statsMap;
    }
}


--------------------------------
FILE: PlayerDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils;
import com.matterworks.core.domain.player.PlayerProfile;
import java.lang.reflect.Type;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.UUID;

public class PlayerDAO {

    private final DatabaseManager db;
    private final Gson gson = new Gson();

    private static final String UPSERT_SQL = """
        INSERT INTO players (uuid, username, money, rank, tech_unlocks) 
        VALUES (?, ?, ?, ?, ?)
        ON DUPLICATE KEY UPDATE 
            username = VALUES(username),
            money = VALUES(money),
            rank = VALUES(rank),
            tech_unlocks = VALUES(tech_unlocks),
            last_login = CURRENT_TIMESTAMP
    """;

    private static final String SELECT_SQL = "SELECT * FROM players WHERE uuid = ?";

    public PlayerDAO(DatabaseManager db) {
        this.db = db;
    }

    public void save(PlayerProfile p) {
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(UPSERT_SQL)) {

            ps.setBytes(1, UuidUtils.asBytes(p.getPlayerId()));
            ps.setString(2, p.getUsername());
            ps.setDouble(3, p.getMoney());
            ps.setString(4, p.getRank().name());

            // Assicuriamoci di salvare sempre un array []
            String json = gson.toJson(p.getUnlockedTechs());
            ps.setString(5, json);

            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public PlayerProfile load(UUID uuid) {
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(SELECT_SQL)) {

            ps.setBytes(1, UuidUtils.asBytes(uuid));
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    PlayerProfile p = new PlayerProfile(uuid);
                    p.setUsername(rs.getString("username"));
                    p.setMoney(rs.getDouble("money"));

                    String rankStr = rs.getString("rank");
                    if (rankStr != null) {
                        try {
                            p.setRank(PlayerProfile.PlayerRank.valueOf(rankStr));
                        } catch (IllegalArgumentException e) {
                            p.setRank(PlayerProfile.PlayerRank.PLAYER);
                        }
                    }

                    // --- FIX: Parsing Sicuro del JSON ---
                    String techJson = rs.getString("tech_unlocks");
                    if (techJson != null && !techJson.isBlank()) {
                        try {
                            // Se techJson Ã¨ "{}" (oggetto) invece di "[]" (array), questo fallirebbe senza catch
                            Type setType = new TypeToken<HashSet<String>>(){}.getType();
                            Set<String> unlocks = gson.fromJson(techJson, setType);
                            if (unlocks != null) {
                                unlocks.forEach(p::addTech);
                            }
                        } catch (Exception e) {
                            System.err.println("âš ï¸ Warning: Formato tech_unlocks errato nel DB per " + uuid + ". Uso set vuoto.");
                            // Non facciamo nulla, p ha giÃ  un set vuoto di default
                        }
                    }

                    return p;
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public List<PlayerProfile> loadAll() {
        List<PlayerProfile> players = new ArrayList<>();
        String sql = "SELECT uuid FROM players";
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql);
             ResultSet rs = ps.executeQuery()) {
            while (rs.next()) {
                PlayerProfile p = load(UuidUtils.asUuid(rs.getBytes("uuid")));
                if (p != null) players.add(p);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return players;
    }
}


--------------------------------
FILE: PlotDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils;
import com.matterworks.core.model.PlotObject;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class PlotDAO {

    private final DatabaseManager dbManager;

    public PlotDAO(DatabaseManager dbManager) {
        this.dbManager = dbManager;
    }

    public Long findPlotIdByOwner(UUID ownerId) {
        String sql = "SELECT id FROM plots WHERE owner_id = ?";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setBytes(1, UuidUtils.asBytes(ownerId));
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) return rs.getLong("id");
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    // --- FIX: Ora restituisce Long (ID Generato) ---
    public Long createPlot(UUID ownerId, int x, int z, int worldId) {
        String sql = "INSERT INTO plots (owner_id, x, z, world_id, allocation_index, world_x, world_z, expansion_tier, is_active) VALUES (?, ?, ?, ?, 0, 0, 0, 0, 1)";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setBytes(1, UuidUtils.asBytes(ownerId));
            stmt.setInt(2, x);
            stmt.setInt(3, z);
            stmt.setInt(4, worldId);

            int affectedRows = stmt.executeUpdate();
            if (affectedRows > 0) {
                try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        Long id = generatedKeys.getLong(1);
                        System.out.println("âœ… Plot creato con ID: " + id + " per " + ownerId);
                        return id;
                    }
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public Long insertMachine(UUID ownerId, String typeId, int x, int y, int z, String metadataJson) {
        Long plotId = findPlotIdByOwner(ownerId);
        if (plotId == null) {
            System.err.println("âŒ Nessun plot trovato per salvare la macchina!");
            return null;
        }

        String sql = "INSERT INTO plot_machines (plot_id, type_id, x, y, z, metadata) VALUES (?, ?, ?, ?, ?, ?)";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setLong(1, plotId);
            stmt.setString(2, typeId);
            stmt.setInt(3, x);
            stmt.setInt(4, y);
            stmt.setInt(5, z);
            stmt.setString(6, metadataJson);

            int affected = stmt.executeUpdate();
            if (affected > 0) {
                try (ResultSet rs = stmt.getGeneratedKeys()) {
                    if (rs.next()) return rs.getLong(1);
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public List<PlotObject> loadMachines(UUID ownerId) {
        List<PlotObject> machines = new ArrayList<>();
        String sql = "SELECT pm.id, pm.plot_id, pm.type_id, pm.x, pm.y, pm.z, pm.metadata FROM plot_machines pm JOIN plots p ON pm.plot_id = p.id WHERE p.owner_id = ?";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setBytes(1, UuidUtils.asBytes(ownerId));
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    String metaStr = rs.getString("metadata");
                    JsonObject metaJson = new JsonObject();
                    if (metaStr != null && !metaStr.isBlank()) {
                        try { metaJson = JsonParser.parseString(metaStr).getAsJsonObject(); }
                        catch (Exception ignored) {}
                    }
                    machines.add(new PlotObject(
                            rs.getLong("id"), rs.getLong("plot_id"),
                            rs.getInt("x"), rs.getInt("y"), rs.getInt("z"),
                            rs.getString("type_id"), metaJson
                    ));
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return machines;
    }

    public void removeMachine(Long dbId) {
        if (dbId == null) return;
        String sql = "DELETE FROM plot_machines WHERE id = ?";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, dbId);
            stmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


--------------------------------
FILE: PlotObjectDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.model.PlotObject;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class PlotObjectDAO {

    private final DatabaseManager db;

    // --- FIX: USIAMO UPSERT INVECE DI INSERT ---
    // Se la combinazione (plot_id, x, y, z) esiste giÃ  (Unique Key),
    // aggiorniamo solo i metadati e il tipo, invece di dare errore.
    private static final String UPSERT_SQL = """
        INSERT INTO plot_objects (plot_id, x, y, z, type_id, meta_data)
        VALUES (?, ?, ?, ?, ?, ?)
        ON DUPLICATE KEY UPDATE 
            meta_data = VALUES(meta_data),
            type_id = VALUES(type_id)
    """;

    private static final String SELECT_SQL = "SELECT * FROM plot_objects WHERE plot_id = ?";
    private static final String DELETE_SQL = "DELETE FROM plot_objects WHERE id = ?";

    public PlotObjectDAO(DatabaseManager db) {
        this.db = db;
    }

    public void placeMachine(PlotObject obj) {
        // Usiamo Statement.RETURN_GENERATED_KEYS per ottenere l'ID se Ã¨ un nuovo inserimento
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(UPSERT_SQL, Statement.RETURN_GENERATED_KEYS)) {

            ps.setLong(1, obj.getPlotId());
            ps.setInt(2, obj.getX());
            ps.setInt(3, obj.getY());
            ps.setInt(4, obj.getZ());
            ps.setString(5, obj.getTypeId());
            // Gestione metadati sicura
            ps.setString(6, obj.getMetaData() != null ? obj.getMetaData().toString() : "{}");

            ps.executeUpdate();

            // Se Ã¨ stato un INSERT (nuova macchina), prendiamo l'ID.
            // Se Ã¨ stato un UPDATE, l'ID non cambia (lo abbiamo giÃ  in obj.id solitamente).
            try (ResultSet rs = ps.getGeneratedKeys()) {
                if (rs.next()) {
                    long newId = rs.getLong(1);
                    // Aggiorniamo l'ID solo se ne abbiamo ricevuto uno valido (cioÃ¨ era un insert)
                    if (newId > 0) {
                        obj.setId(newId);
                    }
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public List<PlotObject> loadPlotMachines(Long plotId) {
        List<PlotObject> machines = new ArrayList<>();
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(SELECT_SQL)) {

            ps.setLong(1, plotId);

            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    PlotObject obj = new PlotObject();
                    obj.setId(rs.getLong("id"));
                    obj.setPlotId(plotId);
                    obj.setX(rs.getInt("x"));
                    obj.setY(rs.getInt("y"));
                    obj.setZ(rs.getInt("z"));
                    obj.setTypeId(rs.getString("type_id"));

                    // Parsing JSON sicuro
                    String metaStr = rs.getString("meta_data");
                    if (metaStr != null) {
                        obj.setMetaDataFromString(metaStr);
                    }

                    machines.add(obj);
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return machines;
    }

    public void deleteMachine(Long dbId) {
        if (dbId == null) return;

        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(DELETE_SQL)) {

            ps.setLong(1, dbId);
            ps.executeUpdate();
            System.out.println("ðŸ—‘ï¸ DB: Cancellata riga ID " + dbId);

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


--------------------------------
FILE: PlotResourceDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.common.GridPosition;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.domain.matter.MatterColor;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

public class PlotResourceDAO {

    private final DatabaseManager db;

    public PlotResourceDAO(DatabaseManager db) {
        this.db = db;
    }

    // UPDATE: Long plotId
    public void addResource(Long plotId, int x, int z, MatterColor type) {
        String sql = "INSERT INTO plot_resources (plot_id, x, z, resource_type) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE resource_type = VALUES(resource_type)";

        try (Connection conn = db.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, plotId); // setLong
            stmt.setInt(2, x);
            stmt.setInt(3, z);
            stmt.setString(4, type.name());
            stmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // UPDATE: Long plotId
    public Map<GridPosition, MatterColor> loadResources(Long plotId) {
        Map<GridPosition, MatterColor> resources = new HashMap<>();
        String sql = "SELECT x, z, resource_type FROM plot_resources WHERE plot_id = ?";

        try (Connection conn = db.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, plotId); // setLong

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    int x = rs.getInt("x");
                    int z = rs.getInt("z");
                    String typeStr = rs.getString("resource_type");

                    try {
                        MatterColor color = MatterColor.valueOf(typeStr);
                        resources.put(new GridPosition(x, 0, z), color);
                    } catch (IllegalArgumentException e) {
                        System.err.println("âš ï¸ Risorsa ignota nel DB: " + typeStr);
                    }
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return resources;
    }
}


--------------------------------
FILE: TechDefinitionDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.managers.TechManager.TechNode;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class TechDefinitionDAO {

    private final DatabaseManager db;
    private final Gson gson = new Gson();

    public TechDefinitionDAO(DatabaseManager db) {
        this.db = db;
    }

    public List<TechNode> loadAllNodes() {
        List<TechNode> nodes = new ArrayList<>();
        String sql = "SELECT node_id, name_display, cost_money, parent_node_ids, unlock_machine_ids FROM tech_definitions";

        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql);
             ResultSet rs = ps.executeQuery()) {

            while (rs.next()) {
                String id = rs.getString("node_id");
                String name = rs.getString("name_display");
                double cost = rs.getDouble("cost_money");

                // Deserializzazione liste JSON
                List<String> parents = parseJsonList(rs.getString("parent_node_ids"));
                List<String> unlocks = parseJsonList(rs.getString("unlock_machine_ids"));

                nodes.add(new TechNode(id, name, cost, parents, unlocks));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return nodes;
    }

    private List<String> parseJsonList(String json) {
        if (json == null || json.isBlank() || json.equals("null")) {
            return new ArrayList<>();
        }
        try {
            return gson.fromJson(json, new TypeToken<List<String>>(){}.getType());
        } catch (Exception e) {
            System.err.println("âš ï¸ JSON Parse Error in TechDefinitionDAO: " + json);
            return new ArrayList<>();
        }
    }
}


--------------------------------
FILE: TransactionDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.UUID;

public class TransactionDAO {

    private final DatabaseManager db;

    private static final String INSERT_SQL = """
        INSERT INTO transactions (player_uuid, action_type, currency, amount, item_id, occurred_at)
        VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
    """;

    public TransactionDAO(DatabaseManager db) {
        this.db = db;
    }

    /**
     * Logga una transazione economica.
     * @param uuid Chi?
     * @param type Cosa ha fatto? (es. "MARKET_SELL", "TECH_BUY")
     * @param currency Valuta ("MONEY", "VOID_COINS")
     * @param amount Quanto? (Positivo = guadagno, Negativo = spesa)
     * @param itemId Opzionale (null se non rilevante)
     */
    public void logTransaction(UUID uuid, String type, String currency, BigDecimal amount, String itemId) {
        // Eseguiamo in un thread separato per non bloccare il gioco (Fire & Forget)
        // In un server vero useremmo un ExecutorService, qui per semplicitÃ  va bene cosÃ¬
        new Thread(() -> {
            try (Connection conn = db.getConnection();
                 PreparedStatement ps = conn.prepareStatement(INSERT_SQL)) {

                ps.setBytes(1, UuidUtils.asBytes(uuid));
                ps.setString(2, type);
                ps.setString(3, currency);
                ps.setBigDecimal(4, amount);
                ps.setString(5, itemId); // PuÃ² essere null

                ps.executeUpdate();

            } catch (SQLException e) {
                System.err.println("FAILED TO LOG TRANSACTION: " + e.getMessage());
                // Non crashare il gioco per un log fallito, ma stampalo
            }
        }).start();
    }
}


--------------------------------
FILE: VerificationCodeDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils;
import com.matterworks.core.domain.player.LinkCode; // Importante: Usa il Dominio

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.UUID;

public class VerificationCodeDAO {

    private final DatabaseManager db;

    private static final String INSERT_CODE = """
        INSERT INTO verification_codes (code, player_uuid, expires_at)
        VALUES (?, ?, ?)
    """;

    public VerificationCodeDAO(DatabaseManager db) {
        this.db = db;
    }

    public void saveCode(UUID playerUuid, LinkCode linkCode) {
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(INSERT_CODE)) {

            ps.setString(1, linkCode.code());
            ps.setBytes(2, UuidUtils.asBytes(playerUuid));
            // Convertiamo il long (millisecondi) in Timestamp SQL
            ps.setTimestamp(3, new Timestamp(linkCode.expirationTime()));

            ps.executeUpdate();

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


--------------------------------
FILE: MachineFactory.java
--------------------------------
package com.matterworks.core.domain.factory;

import com.matterworks.core.common.GridPosition;
import com.matterworks.core.domain.machines.*;
import com.matterworks.core.model.PlotObject;

import java.util.UUID;

public class MachineFactory {

    public static PlacedMachine createFromModel(PlotObject model, UUID ownerId) {
        GridPosition pos = new GridPosition(model.getX(), model.getY(), model.getZ());

        return switch (model.getTypeId()) {
            case "drill_mk1" -> new DrillMachine(
                    model.getId(),
                    ownerId,
                    pos,
                    "drill_mk1",
                    model.getMetaData(),
                    1
            );

            case "conveyor_belt" -> new ConveyorBelt(
                    model.getId(),
                    ownerId,
                    pos,
                    "conveyor_belt",
                    model.getMetaData()
            );

            // NEW: Creazione Nexus
            case "nexus_core" -> new NexusMachine(
                    model.getId(),
                    ownerId,
                    pos,
                    "nexus_core",
                    model.getMetaData()
            );
            case "chromator" -> new Chromator(
                    model.getId(),
                    ownerId,
                    pos,
                    "chromator",
                    model.getMetaData()
            );
            case "color_mixer" -> new ColorMixer(model.getId(), ownerId, pos, "color_mixer", model.getMetaData());


            default -> {
                System.err.println("Unknown machine type: " + model.getTypeId());
                yield null;
            }
        };
    }
}


--------------------------------
FILE: MachineInventory.java
--------------------------------
package com.matterworks.core.domain.inventory;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.matterworks.core.domain.matter.MatterPayload;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class MachineInventory {

    // Classe interna per rappresentare uno Slot con quantitÃ 
    private static class InventorySlot {
        MatterPayload item;
        int count;

        InventorySlot(MatterPayload item, int count) {
            this.item = item;
            this.count = count;
        }
    }

    private final List<InventorySlot> slots;
    private final int slotCount;
    private final int MAX_STACK_SIZE = 64; // Limite stack per slot

    public MachineInventory(int slotCount) {
        this.slotCount = slotCount;
        this.slots = new ArrayList<>(slotCount);
        // Inizializza slot vuoti
        for (int i = 0; i < slotCount; i++) {
            slots.add(null);
        }
    }

    // --- GESTIONE SLOT (STACKING LOGIC) ---

    public MatterPayload getItemInSlot(int slotIndex) {
        if (slotIndex < 0 || slotIndex >= slots.size()) return null;
        InventorySlot slot = slots.get(slotIndex);
        return (slot != null) ? slot.item : null;
    }

    public int getCountInSlot(int slotIndex) {
        if (slotIndex < 0 || slotIndex >= slots.size()) return 0;
        InventorySlot slot = slots.get(slotIndex);
        return (slot != null) ? slot.count : 0;
    }

    /**
     * Tenta di inserire un item in uno slot specifico gestendo lo stacking.
     */
    public boolean insertIntoSlot(int slotIndex, MatterPayload newItem) {
        if (newItem == null) return false;

        // Assicuriamoci che la lista sia dimensionata
        while (slots.size() <= slotIndex) slots.add(null);

        InventorySlot currentSlot = slots.get(slotIndex);

        // CASO 1: Slot vuoto -> Crea nuovo stack
        if (currentSlot == null) {
            slots.set(slotIndex, new InventorySlot(newItem, 1));
            return true;
        }

        // CASO 2: Slot occupato -> Controlla se Ã¨ lo stesso item e se c'Ã¨ spazio
        if (isSameItem(currentSlot.item, newItem)) {
            if (currentSlot.count < MAX_STACK_SIZE) {
                currentSlot.count++;
                return true;
            }
        }

        // CASO 3: Item diverso o Stack pieno -> Rifiuta
        return false;
    }

    /**
     * Decrementa la quantitÃ  in uno slot (Consumo ricetta).
     */
    public void decreaseSlot(int slotIndex, int amount) {
        if (slotIndex < 0 || slotIndex >= slots.size()) return;

        InventorySlot slot = slots.get(slotIndex);
        if (slot != null) {
            slot.count -= amount;
            if (slot.count <= 0) {
                slots.set(slotIndex, null); // Slot svuotato
            }
        }
    }

    // --- METODI LEGACY (Per Belt/Drill che non usano slot specifici) ---

    public boolean insert(MatterPayload m) {
        // Cerca il primo slot valido (Vuoto o Stesso tipo con spazio)
        for (int i = 0; i < slots.size(); i++) {
            if (insertIntoSlot(i, m)) return true;
        }
        return false;
    }

    public MatterPayload extractFirst() {
        // Cerca il primo slot non vuoto e decrementa
        for (int i = 0; i < slots.size(); i++) {
            InventorySlot slot = slots.get(i);
            if (slot != null && slot.count > 0) {
                MatterPayload item = slot.item;
                decreaseSlot(i, 1);
                return item;
            }
        }
        return null;
    }

    public boolean isEmpty() {
        for (InventorySlot s : slots) if (s != null) return false;
        return true;
    }

    public int getCount() {
        // Ritorna la somma totale degli item
        int total = 0;
        for (InventorySlot s : slots) if (s != null) total += s.count;
        return total;
    }

    // --- HELPER ---

    private boolean isSameItem(MatterPayload a, MatterPayload b) {
        return a.color() == b.color() && a.shape() == b.shape();
        // Nota: Ignoriamo effetti per ora per semplicitÃ  di stacking
    }

    // --- SERIALIZZAZIONE (Aggiornata con COUNT) ---

    public JsonObject serialize() {
        JsonObject json = new JsonObject();
        json.addProperty("capacity", slotCount);

        JsonArray itemsArr = new JsonArray();
        for (InventorySlot slot : slots) {
            if (slot != null) {
                JsonObject slotJson = slot.item.serialize();
                slotJson.addProperty("count", slot.count); // Salviamo quanti ce ne sono
                itemsArr.add(slotJson);
            } else {
                itemsArr.add((JsonElement) null);
            }
        }
        json.add("items", itemsArr);
        return json;
    }

    public void loadState(JsonObject json) {
        if (json == null || !json.has("items")) return;

        slots.clear();
        for(int i=0; i<slotCount; i++) slots.add(null);

        JsonArray itemsArr = json.getAsJsonArray("items");
        for (int i = 0; i < itemsArr.size() && i < slotCount; i++) {
            JsonElement el = itemsArr.get(i);
            if (el.isJsonObject()) {
                JsonObject obj = el.getAsJsonObject();
                MatterPayload mp = MatterPayload.fromJson(obj);
                int count = obj.has("count") ? obj.get("count").getAsInt() : 1;
                slots.set(i, new InventorySlot(mp, count));
            }
        }
    }
}


--------------------------------
FILE: BlockRegistry.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.database.dao.MachineDefinitionDAO;
import com.matterworks.core.ports.IWorldAccess;

import java.util.HashMap;
import java.util.Map;

public class BlockRegistry {

    private final IWorldAccess worldAdapter;
    private final MachineDefinitionDAO definitionDAO;

    // Cache aggiornata: String -> MachineStats
    private final Map<String, MachineStats> statsCache;

    public BlockRegistry(IWorldAccess worldAdapter, MachineDefinitionDAO definitionDAO) {
        this.worldAdapter = worldAdapter;
        this.definitionDAO = definitionDAO;
        this.statsCache = new HashMap<>();
    }

    public void loadFromDatabase() {
        System.out.println("ðŸ“‹ Caricamento prezzi e dimensioni dal DB...");
        Map<String, MachineStats> dbDefs = definitionDAO.loadAllDefinitions();

        dbDefs.forEach((id, stats) -> {
            statsCache.put(id, stats);
            System.out.println("   -> " + id + ": " + stats.dimensions() + " | $" + stats.basePrice());
        });
    }

    public MachineStats getStats(String blockId) {
        return statsCache.getOrDefault(blockId, MachineStats.fallback(blockId));
    }

    public Vector3Int getDimensions(String blockId) {
        if (statsCache.containsKey(blockId)) {
            return statsCache.get(blockId).dimensions();
        }
        // Fallback su Hytale (senza prezzo)
        Vector3Int dim = worldAdapter.fetchExternalBlockDimensions(blockId);
        statsCache.put(blockId, new MachineStats(dim, 0.0, blockId));
        return dim;
    }

    public double getPrice(String blockId) {
        if (statsCache.containsKey(blockId)) {
            return statsCache.get(blockId).basePrice();
        }
        return 0.0; // Gratis se non definito (o fallback)
    }
}


--------------------------------
FILE: Chromator.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.matter.Recipe;
import java.util.UUID;
import java.util.List;

public class Chromator extends ProcessorMachine {

    public Chromator(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, pos, typeId, metadata);
        this.dimensions = new Vector3Int(2, 1, 1);
    }

    @Override
    public boolean insertItem(MatterPayload item, GridPosition fromPos) {
        if (fromPos == null) return false;
        int targetSlot = getSlotForPosition(fromPos);
        if (targetSlot == -1) return false;

        boolean isDye = (item.color() != MatterColor.RAW);
        if (targetSlot == 0 && isDye) return false;
        if (targetSlot == 1 && !isDye) return false;

        return insertIntoBuffer(targetSlot, item);
    }

    @Override
    protected GridPosition getOutputPosition() {
        int x = pos.x(); int y = pos.y(); int z = pos.z();
        return switch (orientation) {
            case NORTH -> new GridPosition(x, y, z - 1);
            case SOUTH -> new GridPosition(x + 1, y, z + 1);
            case EAST -> new GridPosition(x + 1, y, z);
            case WEST -> new GridPosition(x - 1, y, z + 1);
            default -> pos;
        };
    }

    private int getSlotForPosition(GridPosition senderPos) {
        int x = pos.x(); int y = pos.y(); int z = pos.z();
        GridPosition s0, s1;
        switch (orientation) {
            case NORTH -> { s0 = new GridPosition(x, y, z + 1); s1 = new GridPosition(x + 1, y, z + 1); }
            case SOUTH -> { s0 = new GridPosition(x + 1, y, z - 1); s1 = new GridPosition(x, y, z - 1); }
            case EAST ->  { s0 = new GridPosition(x - 1, y, z); s1 = new GridPosition(x - 1, y, z + 1); }
            case WEST ->  { s0 = new GridPosition(x + 1, y, z + 1); s1 = new GridPosition(x + 1, y, z); }
            default -> { return -1; }
        }
        if (senderPos.equals(s0)) return 0;
        if (senderPos.equals(s1)) return 1;
        return -1;
    }

    @Override
    public void tick(long currentTick) {
        // 1. Tenta di espellere prima di ogni altra cosa
        super.tryEjectItem(currentTick);

        // 2. Se ha finito la ricetta, sposta nel buffer di output
        if (currentRecipe != null) {
            if (currentTick >= finishTick) {
                completeProcessing();
            }
            return;
        }

        // 3. Se il buffer di output Ã¨ pieno, non iniziare nulla
        if (outputBuffer.getCount() >= MAX_OUTPUT_STACK) return;

        // 4. Se ha gli ingredienti (Slot 0: Cubo, Slot 1: Colore), avvia ricetta
        if (inputBuffer.getCountInSlot(0) > 0 && inputBuffer.getCountInSlot(1) > 0) {
            MatterPayload cube = inputBuffer.getItemInSlot(0);
            MatterPayload dye = inputBuffer.getItemInSlot(1);

            inputBuffer.decreaseSlot(0, 1);
            inputBuffer.decreaseSlot(1, 1);

            MatterPayload result = new MatterPayload(cube.shape(), dye.color());
            this.currentRecipe = new Recipe("chroma_working", List.of(cube, dye), result, 1.5f, 0);
            this.finishTick = currentTick + 30; // 1.5 sec

            saveState();
        }
    }
}


--------------------------------
FILE: ColorMixer.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.matter.MatterShape;

import java.util.UUID;

public class ColorMixer extends ProcessorMachine {

    public ColorMixer(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, pos, typeId, metadata);
        this.dimensions = new Vector3Int(2, 1, 1);
        if (inputBuffer.getItemInSlot(0) == null) inputBuffer.insertIntoSlot(0, null);
        if (inputBuffer.getItemInSlot(1) == null) inputBuffer.insertIntoSlot(1, null);
    }

    @Override
    public boolean insertItem(MatterPayload item, GridPosition fromPos) {
        if (fromPos == null) return false;
        if (item.color() == MatterColor.RAW) return false;

        int targetSlot = getSlotForPosition(fromPos);
        if (targetSlot == -1) return false;

        // FIX: Usa la costante MAX_INPUT_STACK (64)
        if (inputBuffer.getCountInSlot(targetSlot) >= MAX_INPUT_STACK) return false;

        return insertIntoBuffer(targetSlot, item);
    }

    @Override
    protected GridPosition getOutputPosition() {
        int x = pos.x();
        int y = pos.y();
        int z = pos.z();

        // Restituisce il vicino del "Blocco Sinistro" rispetto alla faccia anteriore
        return switch (orientation) {
            // NORD: Fronte Ã¨ Z-min. Sinistra Ã¨ X (Ovest). Output deve essere a (x, z-1).
            case NORTH -> new GridPosition(x, y, z - 1);

            // SUD: Fronte Ã¨ Z-max. Sinistra Ã¨ X+1 (Est). Output deve essere a (x+1, z+1).
            case SOUTH -> new GridPosition(x + 1, y, z + 1);

            // EST: Fronte Ã¨ X-max. Sinistra Ã¨ Z (Nord). Output deve essere a (x+1, z).
            case EAST -> new GridPosition(x + 1, y, z);

            // OVEST: Fronte Ã¨ X-min. Sinistra Ã¨ Z+1 (Sud). Output deve essere a (x-1, z+1).
            case WEST -> new GridPosition(x - 1, y, z + 1);

            default -> pos;
        };
    }

    private int getSlotForPosition(GridPosition senderPos) {
        int x = pos.x();
        int y = pos.y();
        int z = pos.z();
        GridPosition slot0Pos = null, slot1Pos = null;

        switch (orientation) {
            case NORTH: slot0Pos = new GridPosition(x, y, z + 1); slot1Pos = new GridPosition(x + 1, y, z + 1); break;
            case SOUTH: slot0Pos = new GridPosition(x + 1, y, z - 1); slot1Pos = new GridPosition(x, y, z - 1); break;
            case EAST:  slot0Pos = new GridPosition(x - 1, y, z); slot1Pos = new GridPosition(x - 1, y, z + 1); break;
            case WEST:  slot0Pos = new GridPosition(x + 1, y, z + 1); slot1Pos = new GridPosition(x + 1, y, z); break;
            default: return -1;
        }

        if (senderPos.equals(slot0Pos)) return 0;
        if (senderPos.equals(slot1Pos)) return 1;
        return -1;
    }

    @Override
    public void tick(long currentTick) {
        super.tryEjectItem(currentTick);
        if (currentRecipe != null) {
            if (currentTick >= finishTick) completeProcessing();
            return;
        }
        if (outputBuffer.getCount() >= MAX_OUTPUT_STACK) return;

        int count0 = inputBuffer.getCountInSlot(0);
        int count1 = inputBuffer.getCountInSlot(1);

        if (count0 > 0 && count1 > 0) {
            MatterPayload c1 = inputBuffer.getItemInSlot(0);
            MatterPayload c2 = inputBuffer.getItemInSlot(1);
            if (c1.color() == c2.color()) return;

            inputBuffer.decreaseSlot(0, 1);
            inputBuffer.decreaseSlot(1, 1);

            MatterColor mixed = MatterColor.mix(c1.color(), c2.color());
            MatterPayload result = new MatterPayload(MatterShape.SPHERE, mixed);
            this.currentRecipe = new com.matterworks.core.domain.matter.Recipe("mix_" + mixed.name(), java.util.List.of(c1, c2), result, 1.5f, 0);
            this.finishTick = currentTick + 30;
            saveState();
            System.out.println("ðŸŒ€ Mixer: Mixing " + c1.color() + " + " + c2.color() + " -> " + mixed);
        }
    }
}


--------------------------------
FILE: ConveyorBelt.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.matter.MatterPayload;

import java.util.UUID;

public class ConveyorBelt extends PlacedMachine {

    private MatterPayload currentItem;
    private long arrivalTick = -1;
    private static final int TRANSPORT_TIME = 20;

    public ConveyorBelt(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.dimensions = Vector3Int.one();

        if (this.metadata.has("currentItem")) {
            this.currentItem = MatterPayload.fromJson(this.metadata.getAsJsonObject("currentItem"));
            this.arrivalTick = 0;
        }
    }

    @Override
    public void tick(long currentTick) {
        if (currentItem == null) return;
        if (arrivalTick == -1) arrivalTick = currentTick + TRANSPORT_TIME;

        if (currentTick >= arrivalTick) {
            pushToNeighbor(currentTick);
        }
    }

    public boolean insertItem(MatterPayload item, long currentTick) {
        if (this.currentItem != null) return false;
        this.currentItem = item;
        this.arrivalTick = currentTick + TRANSPORT_TIME;
        this.metadata.add("currentItem", item.serialize());
        markDirty();
        return true;
    }

    private void pushToNeighbor(long currentTick) {
        if (gridManager == null) return;

        Vector3Int dirVec = orientation.toVector();
        GridPosition targetPos = new GridPosition(
                pos.x() + dirVec.x(),
                pos.y() + dirVec.y(),
                pos.z() + dirVec.z()
        );

        PlacedMachine neighbor = getNeighborAt(targetPos);
        boolean moved = false;

        if (neighbor instanceof ConveyorBelt nextBelt) {
            moved = nextBelt.insertItem(currentItem, currentTick);
        }
        else if (neighbor instanceof NexusMachine nexus) {
            // FIX CRUCIALE: Passiamo 'this.pos' (la posizione del nastro)
            // Il Nexus userÃ  questa coordinata per verificare se il nastro Ã¨ davanti a una porta valida.
            moved = nexus.insertItem(currentItem, this.pos);
        }
        else if (neighbor instanceof ProcessorMachine processor) {
            // Anche i processori ora richiedono la posizione di origine
            moved = processor.insertItem(currentItem, this.pos);
        }

        if (moved) {
            this.currentItem = null;
            this.arrivalTick = -1;
            this.metadata.remove("currentItem");
            markDirty();
        }
    }

    @Override
    public JsonObject serialize() {
        super.serialize();
        if (currentItem != null) this.metadata.add("currentItem", currentItem.serialize());
        else this.metadata.remove("currentItem");
        return this.metadata;
    }
}


--------------------------------
FILE: DrillMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.inventory.MachineInventory;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.matter.MatterShape;
import com.matterworks.core.infrastructure.CoreConfig;

import java.util.UUID;

public class DrillMachine extends PlacedMachine {

    private int tierLevel;
    private float productionSpeed;
    private long nextSpawnTick = -1;
    private final MachineInventory outputBuffer;

    private MatterColor resourceToMine = MatterColor.RAW;

    public DrillMachine(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata, int tierLevel) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.tierLevel = tierLevel;
        this.productionSpeed = tierLevel * 1.0f;
        this.dimensions = new Vector3Int(1, 2, 1);

        int capacity = CoreConfig.getInt("machine.inventory.capacity", 64);
        this.outputBuffer = new MachineInventory(capacity);

        // Caricamento Dati
        if (this.metadata != null) {
            if (this.metadata.has("items")) {
                this.outputBuffer.loadState(this.metadata);
            }
            if (this.metadata.has("mining_resource")) {
                try {
                    this.resourceToMine = MatterColor.valueOf(this.metadata.get("mining_resource").getAsString());
                } catch (Exception e) {
                    this.resourceToMine = MatterColor.RAW;
                }
            }
        }
    }

    public void setResourceToMine(MatterColor resource) {
        this.resourceToMine = resource;
        saveInternalState(); // Salva subito
    }

    @Override
    public void tick(long currentTick) {
        if (nextSpawnTick == -1) {
            nextSpawnTick = currentTick + (long)(20 / productionSpeed);
        }

        if (currentTick >= nextSpawnTick) {
            produceItem();
            nextSpawnTick = currentTick + (long)(20 / productionSpeed);
        }
        tryEjectItem(currentTick);
    }

    private void produceItem() {
        MatterShape shape = (this.resourceToMine == MatterColor.RAW) ? MatterShape.CUBE : null;
        MatterPayload newItem = new MatterPayload(shape, this.resourceToMine);

        if (outputBuffer.insert(newItem)) {
            saveInternalState(); // Usa il metodo sicuro
        }
    }

    private void tryEjectItem(long currentTick) {
        if (outputBuffer.isEmpty()) return;

        // FIX: Usa getNeighborAt per trovare il nastro del proprietario corretto
        // (Assumendo che tu abbia applicato la patch Multi-Tenant precedente)
        Vector3Int dir = orientation.toVector();
        GridPosition targetPos = new GridPosition(pos.x() + dir.x(), pos.y() + dir.y(), pos.z() + dir.z());

        // Se non hai ancora il metodo getNeighborAt nella classe padre, usa:
        // PlacedMachine neighbor = gridManager.getMachineAt(this.ownerId, targetPos);
        PlacedMachine neighbor = getNeighborAt(targetPos);

        if (neighbor instanceof ConveyorBelt belt) {
            MatterPayload item = outputBuffer.extractFirst();
            if (item != null) {
                if (belt.insertItem(item, currentTick)) {
                    saveInternalState(); // FIX: Usa il metodo sicuro invece di sovrascrivere
                } else {
                    outputBuffer.insert(item); // Rollback se il nastro Ã¨ pieno
                }
            }
        }
    }

    /**
     * Metodo centrale per aggiornare i metadati senza perdere pezzi.
     * Unisce lo stato dell'inventario con la configurazione della risorsa.
     */
    private void saveInternalState() {
        // 1. Ottieni il JSON dell'inventario
        JsonObject invState = outputBuffer.serialize();

        // 2. Fai il merge dentro this.metadata invece di sovrascriverlo brutalmente
        this.metadata.add("items", invState.get("items"));
        this.metadata.add("capacity", invState.get("capacity"));

        // 3. Assicura che la risorsa sia sempre salvata
        this.metadata.addProperty("mining_resource", resourceToMine.name());

        // 4. Marca per il salvataggio DB
        markDirty();
    }
}


--------------------------------
FILE: IGridComponent.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.ports.IWorldAccess;

/**
 * Interfaccia base per qualsiasi oggetto piazzabile sulla griglia.
 *
 */
public interface IGridComponent {
    void onPlace(IWorldAccess world);
    void onRemove();
    JsonObject serialize();
    Vector3Int getDimensions();
}


--------------------------------
FILE: MachineStats.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.matterworks.core.common.Vector3Int;

/**
 * Contiene le statistiche statiche di una macchina caricate dal DB.
 * (Dimensioni, Prezzo, etc.)
 */
public record MachineStats(
        Vector3Int dimensions,
        double basePrice,
        String nameDisplay // Opzionale: utile per la GUI
) {
    // Statistiche di fallback per blocchi ignoti
    public static MachineStats fallback(String id) {
        return new MachineStats(Vector3Int.one(), 0.0, id);
    }
}


--------------------------------
FILE: NexusMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.inventory.MachineInventory;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.shop.MarketManager;

import java.util.UUID;

public class NexusMachine extends PlacedMachine {

    private final MachineInventory storage;
    private long nextSaleTick = -1;
    private static final int SALE_INTERVAL = 10;

    public NexusMachine(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.dimensions = new Vector3Int(3, 3, 3);
        this.storage = new MachineInventory(100);

        if (this.metadata.has("items")) {
            this.storage.loadState(this.metadata);
        }
    }

    @Override
    public void tick(long currentTick) {
        if (storage.isEmpty()) return;
        if (nextSaleTick == -1) nextSaleTick = currentTick + SALE_INTERVAL;

        if (currentTick >= nextSaleTick) {
            sellNextItem();
            nextSaleTick = currentTick + SALE_INTERVAL;
        }
    }

    /**
     * Metodo legacy (non dovrebbe essere usato dai nastri, ma per sicurezza)
     */
    public boolean insertItem(MatterPayload item) {
        return false; // Il Nexus ora richiede una posizione di origine!
    }

    /**
     * NUOVO: Inserimento con validazione geometrica rigorosa.
     */
    public boolean insertItem(MatterPayload item, GridPosition fromPos) {
        if (item.shape() == null) return false; // Rifiuta liquidi/dye
        if (fromPos == null) return false;

        // Validazione Porta: Deve entrare da una delle 6 porte centrali
        if (!isValidInputPort(fromPos)) {
            return false;
        }

        boolean success = storage.insert(item);
        if (success) {
            this.metadata = storage.serialize();
            markDirty();
        }
        return success;
    }

    private boolean isValidInputPort(GridPosition from) {
        int x = pos.x();
        int y = pos.y();
        int z = pos.z();

        // Coordinate relative (delta)
        int dx = from.x() - x;
        int dy = from.y() - y;
        int dz = from.z() - z;

        // Il Nexus accetta input solo ai livelli Y=0 e Y=1 (relativi alla base)
        if (dy < 0 || dy > 1) return false;

        // Logica Porte Centrali (Il Nexus Ã¨ 3x3, centro Ã¨ offset 1)
        // Nord (z-1) -> Entra in (1, y, 0) -> Delta da origine: x=1, z=-1
        if (dx == 1 && dz == -1) return true;
        // Sud (z+3) -> Entra in (1, y, 2) -> Delta da origine: x=1, z=3
        if (dx == 1 && dz == 3) return true;
        // Ovest (x-1) -> Entra in (0, y, 1) -> Delta da origine: x=-1, z=1
        if (dx == -1 && dz == 1) return true;
        // Est (x+3) -> Entra in (2, y, 1) -> Delta da origine: x=3, z=1
        if (dx == 3 && dz == 1) return true;

        return false;
    }

    private void sellNextItem() {
        if (gridManager == null) return;
        MarketManager market = gridManager.getMarketManager();
        if (market == null) return;

        MatterPayload itemToSell = storage.extractFirst();
        if (itemToSell != null) {
            market.sellItem(itemToSell, this.getOwnerId());
            this.metadata = storage.serialize();
            markDirty();
        }
    }
}


--------------------------------
FILE: PlacedMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.Direction;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.managers.GridManager;
import com.matterworks.core.ports.IWorldAccess;

import java.util.UUID;

public abstract class PlacedMachine implements IGridComponent {

    protected Long dbId;
    protected UUID ownerId;
    protected String typeId;
    protected GridPosition pos;
    protected Direction orientation;
    protected Vector3Int dimensions;
    protected JsonObject metadata;
    protected GridManager gridManager;
    protected boolean isDirty = false;

    public PlacedMachine(Long dbId, UUID ownerId, String typeId, GridPosition pos, JsonObject metadata) {
        this.dbId = dbId;
        this.ownerId = ownerId;
        this.typeId = typeId;
        this.pos = pos;
        this.metadata = metadata != null ? metadata : new JsonObject();

        this.orientation = Direction.NORTH;
        if (this.metadata.has("orientation")) {
            this.orientation = Direction.valueOf(this.metadata.get("orientation").getAsString());
        }

        this.dimensions = new Vector3Int(1, 1, 1);
    }

    @Override
    public Vector3Int getDimensions() {
        if (orientation == Direction.EAST || orientation == Direction.WEST) {
            return new Vector3Int(dimensions.z(), dimensions.y(), dimensions.x());
        }
        return dimensions;
    }

    // --- NUOVO METODO HELPER PER I VICINI ---
    protected PlacedMachine getNeighborAt(GridPosition targetPos) {
        if (gridManager == null) return null;
        // Chiede al GM la macchina in quella posizione MA nello stesso universo (ownerId)
        return gridManager.getMachineAt(this.ownerId, targetPos);
    }

    public void setOrientation(Direction orientation) {
        this.orientation = orientation;
        this.metadata.addProperty("orientation", orientation.name());
        markDirty();
    }
    public Direction getNeighborDirection(GridPosition neighborPos) {
        int dx = neighborPos.x() - this.pos.x();
        int dy = neighborPos.y() - this.pos.y();
        int dz = neighborPos.z() - this.pos.z();

        if (dx == 1) return Direction.EAST;
        if (dx == -1) return Direction.WEST;
        if (dz == 1) return Direction.SOUTH;
        if (dz == -1) return Direction.NORTH;
        if (dy == 1) return Direction.UP;
        if (dy == -1) return Direction.DOWN;

        return null; // Non adiacente
    }

    public UUID getOwnerId() { return ownerId; }
    public void cleanDirty() { this.isDirty = false; }

    public GridPosition getPos() { return pos; }
    public String getTypeId() { return typeId; }
    public Direction getOrientation() { return orientation; }

    public Long getDbId() { return dbId; }
    public void setDbId(Long id) { this.dbId = id; }

    public void setGridContext(GridManager gm) { this.gridManager = gm; }

    public void markDirty() { this.isDirty = true; }
    public boolean isDirty() { return isDirty; }

    public abstract void tick(long currentTick);

    public void onPlace(IWorldAccess world) {}
    public void onRemove() {}

    public JsonObject serialize() {
        metadata.addProperty("orientation", orientation.name());
        return metadata;
    }
}


--------------------------------
FILE: ProcessorMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.domain.inventory.MachineInventory;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.matter.Recipe;
import java.util.UUID;

public abstract class ProcessorMachine extends PlacedMachine {

    protected final MachineInventory inputBuffer;
    protected final MachineInventory outputBuffer;
    protected Recipe currentRecipe;
    protected long finishTick = -1;

    protected static final int MAX_INPUT_STACK = 64;
    protected static final int MAX_OUTPUT_STACK = 64;

    public ProcessorMachine(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.inputBuffer = new MachineInventory(2);
        this.outputBuffer = new MachineInventory(1);

        if (this.metadata.has("input")) this.inputBuffer.loadState(this.metadata.getAsJsonObject("input"));
        if (this.metadata.has("output")) this.outputBuffer.loadState(this.metadata.getAsJsonObject("output"));
    }

    protected abstract GridPosition getOutputPosition();
    public abstract boolean insertItem(MatterPayload item, GridPosition fromPos);

    protected boolean insertIntoBuffer(int slotIndex, MatterPayload item) {
        if (inputBuffer.getCountInSlot(slotIndex) >= MAX_INPUT_STACK) return false;
        if (inputBuffer.insertIntoSlot(slotIndex, item)) {
            saveState();
            return true;
        }
        return false;
    }

    protected void completeProcessing() {
        if (currentRecipe != null && outputBuffer.insert(currentRecipe.output())) {
            this.currentRecipe = null;
            this.finishTick = -1;
            saveState();
        }
    }

    protected void tryEjectItem(long currentTick) {
        if (outputBuffer.isEmpty() || gridManager == null) return;

        GridPosition targetPos = getOutputPosition();
        PlacedMachine neighbor = getNeighborAt(targetPos);

        if (neighbor instanceof ConveyorBelt belt) {
            MatterPayload item = outputBuffer.extractFirst();
            if (item != null) {
                if (belt.insertItem(item, currentTick)) {
                    saveState();
                } else {
                    outputBuffer.insert(item); // Rollback se nastro pieno
                }
            }
        } else if (neighbor instanceof NexusMachine nexus) {
            MatterPayload item = outputBuffer.extractFirst();
            if (item != null) {
                if (nexus.insertItem(item, targetPos)) {
                    saveState();
                } else {
                    outputBuffer.insert(item);
                }
            }
        }
    }

    protected void saveState() {
        this.metadata.add("input", inputBuffer.serialize());
        this.metadata.add("output", outputBuffer.serialize());
        markDirty();
    }
}


--------------------------------
FILE: StructuralBlock.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.ports.IWorldAccess;

/**
 * Rappresenta un blocco statico o strutturale (Muri, Decorazioni).
 * Occupa spazio nella griglia ma non ha logica di tick complessa.
 *
 */
public class StructuralBlock implements IGridComponent {

    private final String blockId;
    private final Vector3Int cachedDimensions;

    public StructuralBlock(String blockId, Vector3Int dimensions) {
        this.blockId = blockId;
        this.cachedDimensions = dimensions;
    }

    @Override
    public void onPlace(IWorldAccess world) {
        // Logica semplice: piazza il blocco visivo nel mondo
        // (La posizione viene gestita dal GridManager al momento del piazzamento)
    }

    @Override
    public void onRemove() {
        // Nessuna pulizia speciale necessaria per blocchi stupidi
    }

    @Override
    public JsonObject serialize() {
        // I blocchi strutturali potrebbero non aver bisogno di salvare metadati complessi
        // o salvano solo il loro ID se necessario.
        JsonObject json = new JsonObject();
        json.addProperty("type", "structure");
        json.addProperty("blockId", blockId);
        return json;
    }

    @Override
    public Vector3Int getDimensions() {
        return cachedDimensions;
    }

    public String getBlockId() { return blockId; }
}


--------------------------------
FILE: MatterColor.java
--------------------------------
package com.matterworks.core.domain.matter;

import java.util.Set;

public enum MatterColor {
    RAW,
    RED,
    BLUE,
    YELLOW,
    GREEN,
    ORANGE,
    PURPLE,
    WHITE;

    /**
     * Logica di miscelazione colori additiva (RYB standard da gioco).
     */
    public static MatterColor mix(MatterColor c1, MatterColor c2) {
        if (c1 == c2) return c1; // Rosso + Rosso = Rosso

        // Ordiniamo i colori per semplificare i check (usando Set o confronto stringhe)
        if (isMix(c1, c2, RED, YELLOW)) return ORANGE;
        if (isMix(c1, c2, YELLOW, BLUE)) return GREEN;
        if (isMix(c1, c2, RED, BLUE)) return PURPLE;

        // Fallback: se mischio cose strane (es. Viola + Verde) diventa RAW o GRIGIO SCURO
        return RAW;
    }

    private static boolean isMix(MatterColor in1, MatterColor in2, MatterColor target1, MatterColor target2) {
        return (in1 == target1 && in2 == target2) || (in1 == target2 && in2 == target1);
    }
}


--------------------------------
FILE: MatterEffect.java
--------------------------------
package com.matterworks.core.domain.matter;

public enum MatterEffect {
    SHINY,
    BLAZING,
    GLITCH,
    RADIOACTIVE
}


--------------------------------
FILE: MatterPayload.java
--------------------------------
package com.matterworks.core.domain.matter;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public record MatterPayload(
        MatterShape shape,
        MatterColor color,
        List<MatterEffect> effects
) {

    public MatterPayload(MatterShape shape, MatterColor color) {
        this(shape, color, Collections.emptyList());
    }

    public JsonObject serialize() {
        JsonObject json = new JsonObject();

        // --- FIX NPE: Controllo null su shape ---
        if (shape != null) {
            json.addProperty("shape", shape.name());
        } else {
            // Se shape Ã¨ null (liquido), non scriviamo nulla o scriviamo null esplicito
            // Gson gestisce l'assenza come null al deserializing solitamente.
        }

        // Colore Ã¨ sempre presente (anche se RAW)
        if (color != null) {
            json.addProperty("color", color.name());
        }

        if (!effects.isEmpty()) {
            JsonArray effectsJson = new JsonArray();
            effects.forEach(e -> effectsJson.add(e.name()));
            json.add("effects", effectsJson);
        }
        return json;
    }

    public boolean isComplex() { return !effects.isEmpty(); }

    // --- FIX DESERIALIZZAZIONE: Supporto shape null ---
    public static MatterPayload fromJson(JsonObject json) {
        try {
            // 1. Gestione Shape Opzionale
            MatterShape s = null;
            if (json.has("shape") && !json.get("shape").isJsonNull()) {
                s = MatterShape.valueOf(json.get("shape").getAsString());
            }

            // 2. Gestione Colore
            MatterColor c = MatterColor.RAW; // Default fallback
            if (json.has("color")) {
                c = MatterColor.valueOf(json.get("color").getAsString());
            }

            // 3. Gestione Effetti
            List<MatterEffect> effs = new ArrayList<>();
            if (json.has("effects")) {
                JsonArray arr = json.getAsJsonArray("effects");
                arr.forEach(el -> effs.add(MatterEffect.valueOf(el.getAsString())));
            }

            return new MatterPayload(s, c, effs);

        } catch (Exception e) {
            System.err.println("Errore parsing payload: " + e.getMessage());
            // In caso di errore grave, ritorniamo un cubo raw per non crashare il server
            return new MatterPayload(MatterShape.CUBE, MatterColor.RAW);
        }
    }
}


--------------------------------
FILE: MatterShape.java
--------------------------------
package com.matterworks.core.domain.matter;

public enum MatterShape {
    CUBE,
    SPHERE,
    PYRAMID,
    CYLINDER
}


--------------------------------
FILE: Recipe.java
--------------------------------
package com.matterworks.core.domain.matter;

import java.util.List;

public record Recipe(
        String id,
        List<MatterPayload> inputs, // Cosa serve (es. 1 Cubo RAW)
        MatterPayload output,       // Cosa esce (es. 1 Cubo ROSSO)
        float processTimeSeconds,   // Quanto ci mette (es. 2.0s)
        int requiredTechId          // Per sblocchi futuri (0 = base)
) {}


--------------------------------
FILE: RecipeRegistry.java
--------------------------------
package com.matterworks.core.domain.matter;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

public class RecipeRegistry {

    private static final List<Recipe> recipes = new ArrayList<>();

    static {
        // --- DEFINIZIONE RICETTE INIZIALI ---

        // Ricetta: Dipingi di Rosso
        // Input: CUBE RAW -> Output: CUBE RED
        recipes.add(new Recipe(
                "paint_red",
                List.of(new MatterPayload(MatterShape.CUBE, MatterColor.RAW)),
                new MatterPayload(MatterShape.CUBE, MatterColor.RED),
                2.0f, // 2 secondi
                0
        ));
    }

    public static Optional<Recipe> findMatchingRecipe(List<MatterPayload> inputs) {
        // Logica semplificata: Cerca la prima ricetta che corrisponde al primo item dell'input
        // In futuro servirÃ  un matching piÃ¹ complesso per input multipli (Mixer)
        if (inputs.isEmpty()) return Optional.empty();

        MatterPayload firstInput = inputs.get(0);

        return recipes.stream()
                .filter(r -> !r.inputs().isEmpty())
                .filter(r -> isMatch(r.inputs().get(0), firstInput))
                .findFirst();
    }

    private static boolean isMatch(MatterPayload required, MatterPayload actual) {
        return required.shape() == actual.shape() && required.color() == actual.color();
    }
}


--------------------------------
FILE: LinkCode.java
--------------------------------
package com.matterworks.core.domain.player;

public record LinkCode(String code, long expirationTime) {
    public boolean isValid() {
        return System.currentTimeMillis() < expirationTime;
    }
}


--------------------------------
FILE: PlayerProfile.java
--------------------------------
package com.matterworks.core.domain.player;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

public class PlayerProfile {

    public enum PlayerRank { PLAYER, ADMIN, MODERATOR }

    private final UUID playerId;
    private String username;
    private double money;
    private PlayerRank rank;
    private Set<String> unlockedTechs = new HashSet<>();

    public PlayerProfile(UUID playerId) {
        this.playerId = playerId;
        this.money = 0.0;
        this.rank = PlayerRank.PLAYER;
    }

    public boolean isAdmin() { return rank == PlayerRank.ADMIN; }
    public PlayerRank getRank() { return rank; }
    public void setRank(PlayerRank rank) { this.rank = rank; }
    public UUID getPlayerId() { return playerId; }
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    public double getMoney() { return money; }
    public void setMoney(double money) { this.money = money; }
    public void modifyMoney(double amount) { this.money += amount; }

    @Override
    public String toString() {
        // --- VISUALIZZA USERNAME (SHORT-ID) ---
        String shortId = playerId.toString().substring(0, 8);
        return username + " (" + shortId + ")";
    }
    public Set<String> getUnlockedTechs() { return unlockedTechs; }

    public void addTech(String techId) {
        this.unlockedTechs.add(techId);
    }

    public boolean hasTech(String techId) {
        return unlockedTechs.contains(techId);
    }
}


--------------------------------
FILE: MarketManager.java
--------------------------------
package com.matterworks.core.domain.shop;

import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.matter.MatterShape;
import com.matterworks.core.domain.player.PlayerProfile;
import com.matterworks.core.ports.IRepository;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class MarketManager {

    private final IRepository repository;
    private final Map<MatterColor, Double> basePrices;

    public MarketManager(IRepository repository) {
        this.repository = repository;
        this.basePrices = new HashMap<>();
        initializePrices();
    }

    private void initializePrices() {
        // Prezzi Base per Colore
        basePrices.put(MatterColor.RAW, 1.0);

        // Colori Primari (Lavorati)
        basePrices.put(MatterColor.RED, 5.0);
        basePrices.put(MatterColor.BLUE, 5.0);
        basePrices.put(MatterColor.YELLOW, 5.0);

        // Colori Secondari (Mixati - Valgono molto di piÃ¹)
        basePrices.put(MatterColor.PURPLE, 25.0);
        basePrices.put(MatterColor.ORANGE, 25.0);
        basePrices.put(MatterColor.GREEN, 25.0);

        // Colore Finale
        basePrices.put(MatterColor.WHITE, 100.0);
    }

    public void sellItem(MatterPayload item, UUID sellerId) {
        if (item == null) return;

        double value = calculateValue(item);

        // Carichiamo il profilo, aggiorniamo i soldi e salviamo subito
        PlayerProfile player = repository.loadPlayerProfile(sellerId);

        if (player != null) {
            player.modifyMoney(value);
            repository.savePlayerProfile(player);

            System.out.println("ðŸ’° MARKET: Venduto " + item.shape() + " (" + item.color() + ") per $" + String.format("%.2f", value));
            System.out.println("   [Saldo Attuale: $" + String.format("%.2f", player.getMoney()) + "]");
        } else {
            System.err.println("âŒ MARKET: Errore critico - Player non trovato " + sellerId);
        }
    }

    private double calculateValue(MatterPayload item) {
        // 1. Prezzo base del colore
        double base = basePrices.getOrDefault(item.color(), 0.5);

        // 2. Moltiplicatore forma (complessitÃ )
        double multiplier = 1.0;
        if (item.shape() == MatterShape.SPHERE) multiplier = 1.5;   // Liquidi/Sfere valgono di piÃ¹
        if (item.shape() == MatterShape.PYRAMID) multiplier = 2.0;  // Cristalli
        if (item.isComplex()) multiplier *= 1.2;                    // Bonus effetti (shiny, etc.)

        return base * multiplier;
    }
}


--------------------------------
FILE: CoreConfig.java
--------------------------------
package com.matterworks.core.infrastructure;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

/**
 * Gestore della configurazione esterna.
 * Legge il file 'matterworks.properties' dalla root del server.
 * Permette di cambiare i valori di gioco senza ricompilare.
 */
public class CoreConfig {

    private static final Properties props = new Properties();

    // Carica il file all'avvio
    public static void load() {
        try (FileInputStream in = new FileInputStream("matterworks.properties")) {
            props.load(in);
            System.out.println("âš™ï¸ Configurazione caricata da matterworks.properties");
        } catch (IOException e) {
            System.out.println("âš ï¸ matterworks.properties non trovato. Uso valori di DEFAULT.");
        }
    }

    /**
     * Recupera un intero dalla config, o usa il default se manca.
     */
    public static int getInt(String key, int defaultValue) {
        String val = props.getProperty(key);
        if (val == null) return defaultValue;
        try {
            return Integer.parseInt(val);
        } catch (NumberFormatException e) {
            System.err.println("âŒ Errore config per " + key + ": " + val + " non Ã¨ un numero.");
            return defaultValue;
        }
    }
}


--------------------------------
FILE: MariaDBAdapter.java
--------------------------------
package com.matterworks.core.infrastructure;

import com.matterworks.core.common.GridPosition;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.dao.*;
import com.matterworks.core.domain.machines.PlacedMachine;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.player.PlayerProfile;
import com.matterworks.core.model.PlotObject;
import com.matterworks.core.ports.IRepository;
import com.matterworks.core.database.UuidUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.UUID;

public class MariaDBAdapter implements IRepository {

    private final DatabaseManager dbManager;
    private final PlayerDAO playerDAO;
    private final PlotDAO plotDAO;
    private final PlotResourceDAO resourceDAO;
    private final InventoryDAO inventoryDAO;
    private final TechDefinitionDAO techDefinitionDAO;

    public MariaDBAdapter(DatabaseManager dbManager) {
        this.dbManager = dbManager;
        this.playerDAO = new PlayerDAO(dbManager);
        this.plotDAO = new PlotDAO(dbManager);
        this.resourceDAO = new PlotResourceDAO(dbManager);
        this.inventoryDAO = new InventoryDAO(dbManager);
        this.techDefinitionDAO = new TechDefinitionDAO(dbManager);
    }

    public TechDefinitionDAO getTechDefinitionDAO() { return techDefinitionDAO; }
    public DatabaseManager getDbManager() { return dbManager; }

    @Override
    public ServerConfig loadServerConfig() {
        String sql = "SELECT player_start_money, vein_raw, vein_red, vein_blue, vein_yellow, sos_threshold FROM server_gamestate WHERE id = 1";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql);
             ResultSet rs = ps.executeQuery()) {
            if (rs.next()) {
                return new ServerConfig(
                        rs.getDouble("player_start_money"),
                        rs.getInt("vein_raw"),
                        rs.getInt("vein_red"),
                        rs.getInt("vein_blue"),
                        rs.getInt("vein_yellow"),
                        rs.getDouble("sos_threshold")
                );
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        // Fallback in caso di errore grave (es. tabella mancante)
        return new ServerConfig(1000.0, 3, 1, 1, 0, 500.0);
    }

    @Override public PlayerProfile loadPlayerProfile(UUID uuid) { return playerDAO.load(uuid); }
    @Override public void savePlayerProfile(PlayerProfile profile) { playerDAO.save(profile); }
    @Override public List<PlayerProfile> getAllPlayers() { return playerDAO.loadAll(); }

    @Override
    public void deletePlayerFull(UUID uuid) {
        if (uuid == null) return;
        Long plotId = plotDAO.findPlotIdByOwner(uuid);
        try (Connection conn = dbManager.getConnection()) {
            conn.setAutoCommit(false);
            try {
                if (plotId != null) {
                    try (PreparedStatement ps = conn.prepareStatement("DELETE FROM plot_machines WHERE plot_id = ?")) { ps.setLong(1, plotId); ps.executeUpdate(); }
                    try (PreparedStatement ps = conn.prepareStatement("DELETE FROM plot_resources WHERE plot_id = ?")) { ps.setLong(1, plotId); ps.executeUpdate(); }
                    try (PreparedStatement ps = conn.prepareStatement("DELETE FROM plots WHERE id = ?")) { ps.setLong(1, plotId); ps.executeUpdate(); }
                }
                byte[] uuidBytes = UuidUtils.asBytes(uuid);
                try (PreparedStatement ps = conn.prepareStatement("DELETE FROM player_inventory WHERE player_uuid = ?")) { ps.setBytes(1, uuidBytes); ps.executeUpdate(); }
                try (PreparedStatement ps = conn.prepareStatement("DELETE FROM verification_codes WHERE player_uuid = ?")) { ps.setBytes(1, uuidBytes); ps.executeUpdate(); }
                try (PreparedStatement ps = conn.prepareStatement("DELETE FROM players WHERE uuid = ?")) { ps.setBytes(1, uuidBytes); ps.executeUpdate(); }
                conn.commit();
            } catch (SQLException ex) {
                conn.rollback();
                ex.printStackTrace();
            } finally {
                conn.setAutoCommit(true);
            }
        } catch (SQLException e) { e.printStackTrace(); }
    }

    @Override public int getInventoryItemCount(UUID ownerId, String itemId) { return inventoryDAO.getItemCount(ownerId, itemId); }
    @Override public void modifyInventoryItem(UUID ownerId, String itemId, int delta) { inventoryDAO.modifyItemCount(ownerId, itemId, delta); }
    @Override public List<PlotObject> loadPlotMachines(UUID ownerId) { return plotDAO.loadMachines(ownerId); }

    @Override
    public Long createMachine(UUID ownerId, PlacedMachine machine) {
        String jsonMeta = machine.serialize().toString();
        return plotDAO.insertMachine(ownerId, machine.getTypeId(), machine.getPos().x(), machine.getPos().y(), machine.getPos().z(), jsonMeta);
    }

    @Override public void deleteMachine(Long dbId) { plotDAO.removeMachine(dbId); }

    @Override
    public void updateMachinesMetadata(List<PlacedMachine> machines) {
        if (machines == null || machines.isEmpty()) return;
        String sql = "UPDATE plot_machines SET metadata = ? WHERE id = ?";
        try (Connection conn = dbManager.getConnection(); PreparedStatement stmt = conn.prepareStatement(sql)) {
            for (PlacedMachine pm : machines) {
                if (pm.getDbId() == null) continue;
                stmt.setString(1, pm.serialize().toString());
                stmt.setLong(2, pm.getDbId());
                stmt.addBatch();
            }
            stmt.executeBatch();
        } catch (SQLException e) { e.printStackTrace(); }
    }

    @Override
    public void clearPlotData(UUID ownerId) {
        Long plotId = plotDAO.findPlotIdByOwner(ownerId);
        if (plotId == null) return;
        try (Connection conn = dbManager.getConnection()) {
            try (PreparedStatement stmt = conn.prepareStatement("DELETE FROM plot_machines WHERE plot_id = ?")) { stmt.setLong(1, plotId); stmt.executeUpdate(); }
            try (PreparedStatement stmt = conn.prepareStatement("DELETE FROM plot_resources WHERE plot_id = ?")) { stmt.setLong(1, plotId); stmt.executeUpdate(); }
        } catch (SQLException e) { e.printStackTrace(); }
    }

    @Override public Long getPlotId(UUID ownerId) { return plotDAO.findPlotIdByOwner(ownerId); }
    @Override public void saveResource(Long plotId, int x, int z, MatterColor type) { resourceDAO.addResource(plotId, x, z, type); }
    @Override public Map<GridPosition, MatterColor> loadResources(Long plotId) { return resourceDAO.loadResources(plotId); }
}


--------------------------------
FILE: ServerConfig.java
--------------------------------
package com.matterworks.core.infrastructure;

public record ServerConfig(
        double startMoney,
        int veinRaw,
        int veinRed,
        int veinBlue,
        int veinYellow,
        double sosThreshold
) {}


--------------------------------
FILE: FactoryPanel.java
--------------------------------
package com.matterworks.core.infrastructure.swing;

import com.google.gson.JsonObject;
import com.matterworks.core.common.Direction;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.machines.BlockRegistry;
import com.matterworks.core.domain.machines.ConveyorBelt;
import com.matterworks.core.domain.machines.PlacedMachine;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.managers.GridManager;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Map;
import java.util.UUID;

public class FactoryPanel extends JPanel {

    private final GridManager gridManager;
    private final BlockRegistry registry;
    private UUID playerUuid;

    private final int CELL_SIZE = 40;
    private final int OFFSET_X = 50;
    private final int OFFSET_Y = 50;

    private String currentTool = "drill_mk1";
    private Direction currentOrientation = Direction.NORTH;
    private int currentLayer = 0;

    private GridPosition mouseHoverPos = null;
    private Runnable onStateChange;

    public FactoryPanel(GridManager gridManager, BlockRegistry registry, UUID playerUuid, Runnable onStateChange) {
        this.gridManager = gridManager;
        this.registry = registry;
        this.playerUuid = playerUuid;
        this.onStateChange = onStateChange;
        this.setBackground(new Color(30, 30, 30));
        this.setFocusable(true);

        this.addMouseMotionListener(new MouseMotionAdapter() {
            @Override
            public void mouseMoved(MouseEvent e) { updateMousePos(e.getX(), e.getY()); repaint(); }
        });
        this.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) { requestFocusInWindow(); handleMouseClick(e); repaint(); }
        });
        this.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) { if (e.getKeyCode() == KeyEvent.VK_R) rotate(); }
        });
    }

    public void setPlayerUuid(UUID uuid) { this.playerUuid = uuid; repaint(); }
    public void setLayer(int y) { this.currentLayer = y; repaint(); }
    public int getCurrentLayer() { return currentLayer; }
    public void setTool(String toolId) {
        this.currentTool = toolId;
        // Non facciamo controlli qui: il fantasma deve apparire sempre
        repaint();
    }
    public String getCurrentToolName() { return currentTool != null ? currentTool : "None"; }

    public void rotate() {
        switch(currentOrientation) {
            case NORTH -> currentOrientation = Direction.EAST;
            case EAST -> currentOrientation = Direction.SOUTH;
            case SOUTH -> currentOrientation = Direction.WEST;
            case WEST -> currentOrientation = Direction.NORTH;
        }
        if (onStateChange != null) onStateChange.run();
        repaint();
    }

    public String getCurrentOrientationName() { return currentOrientation.name(); }

    private void updateMousePos(int x, int y) {
        int gx = (x - OFFSET_X) / CELL_SIZE;
        int gz = (y - OFFSET_Y) / CELL_SIZE;
        if (gx >= 0 && gx <= 20 && gz >= 0 && gz <= 20) {
            this.mouseHoverPos = new GridPosition(gx, currentLayer, gz);
        } else {
            this.mouseHoverPos = null;
        }
    }

    private void handleMouseClick(MouseEvent e) {
        if (mouseHoverPos == null) return;
        if (SwingUtilities.isLeftMouseButton(e)) {
            gridManager.placeMachine(playerUuid, mouseHoverPos, currentTool, currentOrientation);
        } else if (SwingUtilities.isRightMouseButton(e)) {
            gridManager.removeComponent(playerUuid, mouseHoverPos);
        }
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        if (currentLayer == 0) drawTerrainResources(g2);
        drawGrid(g2);
        drawMachines(g2);
        drawGhost(g2);
    }

    private void drawTerrainResources(Graphics2D g) {
        Map<GridPosition, MatterColor> resources = gridManager.getTerrainResources(playerUuid);
        for (Map.Entry<GridPosition, MatterColor> entry : resources.entrySet()) {
            GridPosition pos = entry.getKey();
            MatterColor type = entry.getValue();
            int x = OFFSET_X + (pos.x() * CELL_SIZE);
            int z = OFFSET_Y + (pos.z() * CELL_SIZE);
            g.setColor(getColorFromStr(type.name(), 100));
            g.fillRect(x, z, CELL_SIZE, CELL_SIZE);
            g.setColor(Color.WHITE);
            g.setFont(new Font("SansSerif", Font.PLAIN, 9));
            g.drawString(type.name(), x + 2, z + 12);
        }
    }

    private void drawGrid(Graphics2D g) {
        g.setColor(new Color(50, 50, 50));
        for (int i = 0; i <= 20; i++) {
            g.drawLine(OFFSET_X + (i * CELL_SIZE), OFFSET_Y, OFFSET_X + (i * CELL_SIZE), OFFSET_Y + (20 * CELL_SIZE));
            g.drawLine(OFFSET_X, OFFSET_Y + (i * CELL_SIZE), OFFSET_X + (20 * CELL_SIZE), OFFSET_Y + (i * CELL_SIZE));
        }
    }

    private void drawMachines(Graphics2D g) {
        Map<GridPosition, PlacedMachine> machines = gridManager.getSnapshot(playerUuid);
        for (PlacedMachine m : machines.values()) {
            if (currentLayer >= m.getPos().y() && currentLayer < m.getPos().y() + m.getDimensions().y()) {
                drawSingleMachine(g, m);
            }
        }
    }

    private void drawSingleMachine(Graphics2D g, PlacedMachine m) {
        int x = OFFSET_X + (m.getPos().x() * CELL_SIZE);
        int z = OFFSET_Y + (m.getPos().z() * CELL_SIZE);
        int w = m.getDimensions().x() * CELL_SIZE;
        int h = m.getDimensions().z() * CELL_SIZE;

        g.setColor(getColorForType(m.getTypeId()));
        g.fillRect(x + 2, z + 2, w - 4, h - 4);

        if (m.getTypeId().equals("nexus_core")) {
            drawNexusPorts(g, m, x, z, w, h);
        } else if (m.getTypeId().equals("chromator") || m.getTypeId().equals("color_mixer")) {
            drawProcessorPorts(g, m, x, z, w, h);
        } else {
            drawStandardPorts(g, m, x, z, w, h);
        }

        if (m instanceof ConveyorBelt belt) drawBeltItem(g, belt, x, z);
        drawDirectionArrow(g, x, z, w, h, m.getOrientation());
    }

    private void drawStandardPorts(Graphics2D g, PlacedMachine m, int x, int z, int w, int h) {
        int p = 8;
        Point out = null, in = null;
        switch (m.getOrientation()) {
            case NORTH -> { out = new Point(x + w/2 - p/2, z); in = new Point(x + w/2 - p/2, z + h - p); }
            case SOUTH -> { out = new Point(x + w/2 - p/2, z + h - p); in = new Point(x + w/2 - p/2, z); }
            case EAST  -> { out = new Point(x + w - p, z + h/2 - p/2); in = new Point(x, z + h/2 - p/2); }
            case WEST  -> { out = new Point(x, z + h/2 - p/2); in = new Point(x + w - p, z + h/2 - p/2); }
        }
        if (out != null) drawPort(g, out, Color.GREEN);
        if (in != null && !m.getTypeId().equals("drill_mk1")) drawPort(g, in, Color.BLUE);
    }

    private void drawNexusPorts(Graphics2D g, PlacedMachine m, int x, int z, int w, int h) {
        if (currentLayer - m.getPos().y() <= 1) {
            int p = 8;
            drawPort(g, new Point(x + w/2 - p/2, z), Color.BLUE);
            drawPort(g, new Point(x + w/2 - p/2, z + h - p), Color.BLUE);
            drawPort(g, new Point(x, z + h/2 - p/2), Color.BLUE);
            drawPort(g, new Point(x + w - p, z + h/2 - p/2), Color.BLUE);
        }
    }

    private void drawProcessorPorts(Graphics2D g, PlacedMachine m, int x, int z, int w, int h) {
        int p = 8; int c = CELL_SIZE;
        boolean isChroma = m.getTypeId().equals("chromator");
        Color colS0 = isChroma ? Color.CYAN : Color.BLUE; // S0: Material/Input1
        Color colS1 = isChroma ? Color.MAGENTA : Color.BLUE; // S1: Color/Input2

        switch (m.getOrientation()) {
            case NORTH -> {
                drawPort(g, new Point(x + c/2 - p/2, z), Color.GREEN); // Out
                drawPort(g, new Point(x + c/2 - p/2, z + h - p), colS0); // In 0
                drawPort(g, new Point(x + (c*3)/2 - p/2, z + h - p), colS1); // In 1
            }
            case SOUTH -> {
                drawPort(g, new Point(x + (c*3)/2 - p/2, z + h - p), Color.GREEN);
                drawPort(g, new Point(x + (c*3)/2 - p/2, z), colS0);
                drawPort(g, new Point(x + c/2 - p/2, z), colS1);
            }
            case EAST -> {
                drawPort(g, new Point(x + w - p, z + c/2 - p/2), Color.GREEN);
                drawPort(g, new Point(x, z + c/2 - p/2), colS0);
                drawPort(g, new Point(x, z + (c*3)/2 - p/2), colS1);
            }
            case WEST -> {
                drawPort(g, new Point(x, z + (c*3)/2 - p/2), Color.GREEN);
                drawPort(g, new Point(x + w - p, z + (c*3)/2 - p/2), colS0);
                drawPort(g, new Point(x + w - p, z + c/2 - p/2), colS1);
            }
        }
    }

    private void drawPort(Graphics2D g, Point pt, Color color) {
        g.setColor(color);
        g.fillRect(pt.x, pt.y, 8, 8);
        g.setColor(Color.WHITE);
        g.drawRect(pt.x, pt.y, 8, 8);
    }

    private void drawBeltItem(Graphics2D g, ConveyorBelt belt, int x, int z) {
        JsonObject meta = belt.serialize();
        if (meta.has("currentItem")) {
            JsonObject item = meta.getAsJsonObject("currentItem");
            String colorStr = item.has("color") ? item.get("color").getAsString() : "RAW";
            String shapeStr = (item.has("shape") && !item.get("shape").isJsonNull()) ? item.get("shape").getAsString() : "LIQUID";
            g.setColor(getColorFromStr(colorStr, 255));
            int size = 18; int pad = (CELL_SIZE - size) / 2;
            if ("CUBE".equals(shapeStr)) g.fillRect(x + pad, z + pad, size, size);
            else g.fillOval(x + pad, z + pad, size, size);
            g.setColor(Color.WHITE); g.drawRect(x + pad, z + pad, size, size);
        }
    }

    private void drawGhost(Graphics2D g) {
        if (mouseHoverPos == null || currentTool == null) return;
        Vector3Int dim = registry.getDimensions(currentTool);
        if (currentOrientation == Direction.EAST || currentOrientation == Direction.WEST) {
            dim = new Vector3Int(dim.z(), dim.y(), dim.x());
        }
        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.4f));
        int x = OFFSET_X + (mouseHoverPos.x() * CELL_SIZE);
        int z = OFFSET_Y + (mouseHoverPos.z() * CELL_SIZE);
        g.setColor(getColorForType(currentTool));
        g.fillRect(x, z, dim.x() * CELL_SIZE, dim.z() * CELL_SIZE);
        g.setColor(Color.WHITE);
        g.drawRect(x, z, dim.x() * CELL_SIZE, dim.z() * CELL_SIZE);
        drawDirectionArrow(g, x, z, dim.x() * CELL_SIZE, dim.z() * CELL_SIZE, currentOrientation);
        g.setComposite(AlphaComposite.SrcOver);
    }

    private void drawDirectionArrow(Graphics2D g, int x, int y, int w, int h, Direction dir) {
        g.setColor(Color.YELLOW);
        int cx = x + w / 2; int cy = y + h / 2;
        switch (dir) {
            case NORTH -> g.fillOval(cx - 3, y + 2, 6, 6);
            case SOUTH -> g.fillOval(cx - 3, y + h - 8, 6, 6);
            case EAST -> g.fillOval(x + w - 8, cy - 3, 6, 6);
            case WEST -> g.fillOval(x + 2, cy - 3, 6, 6);
        }
    }

    private Color getColorFromStr(String c, int alpha) {
        return switch(c) {
            case "RED" -> new Color(200, 0, 0, alpha);
            case "BLUE" -> new Color(0, 0, 200, alpha);
            case "YELLOW" -> new Color(200, 200, 0, alpha);
            case "PURPLE" -> new Color(160, 32, 240, alpha);
            case "GREEN" -> new Color(0, 200, 0, alpha);
            default -> new Color(120, 120, 120, alpha);
        };
    }

    private Color getColorForType(String type) {
        return switch (type) {
            case "drill_mk1" -> Color.LIGHT_GRAY;
            case "conveyor_belt" -> Color.DARK_GRAY;
            case "nexus_core" -> new Color(150, 0, 150);
            case "chromator" -> new Color(255, 140, 0);
            case "color_mixer" -> new Color(0, 200, 200);
            default -> Color.RED;
        };
    }
}


--------------------------------
FILE: InventoryDebugPanel.java
--------------------------------
package com.matterworks.core.infrastructure.swing;

import com.matterworks.core.domain.player.PlayerProfile;
import com.matterworks.core.managers.GridManager;
import com.matterworks.core.ports.IRepository;
import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class InventoryDebugPanel extends JPanel {

    private final IRepository repository;
    private final UUID playerUuid;
    private final GridManager gridManager;
    private final String[] itemIds = {"drill_mk1", "conveyor_belt", "nexus_core", "chromator", "color_mixer"};
    private final Map<String, JLabel> labelMap = new HashMap<>();

    // Timer salvato in campo per poterlo fermare
    private final Timer refreshTimer;

    public InventoryDebugPanel(IRepository repository, UUID playerUuid, GridManager gm) {
        this.repository = repository;
        this.playerUuid = playerUuid;
        this.gridManager = gm;

        this.setPreferredSize(new Dimension(320, 0));
        this.setMinimumSize(new Dimension(320, 0));

        PlayerProfile profile = gridManager.getCachedProfile(playerUuid); // Use cache
        boolean isPlayer = (profile != null && profile.getRank() == PlayerProfile.PlayerRank.PLAYER);

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBorder(BorderFactory.createTitledBorder(isPlayer ? "Warehouse Shop" : "Warehouse Monitor"));
        setBackground(new Color(40, 40, 40));

        for (String id : itemIds) {
            add(createItemRow(id, isPlayer));
            add(Box.createVerticalStrut(8));
        }

        // Timer a 500ms
        refreshTimer = new Timer(500, e -> updateAllLabels());
        refreshTimer.start();
    }

    /**
     * IMPORTANTE: Ferma il timer per evitare memory leak e CPU usage in background
     */
    public void dispose() {
        if (refreshTimer != null && refreshTimer.isRunning()) {
            refreshTimer.stop();
        }
    }

    private JPanel createItemRow(String itemId, boolean isPlayer) {
        JPanel row = new JPanel(new BorderLayout(10, 0));
        row.setOpaque(false);
        row.setMaximumSize(new Dimension(310, 40));

        JLabel lblInfo = new JLabel(itemId + ": 0");
        lblInfo.setForeground(Color.WHITE);
        lblInfo.setFont(new Font("Monospaced", Font.BOLD, 12));
        labelMap.put(itemId, lblInfo);

        JPanel buttons = new JPanel(new GridLayout(1, 2, 5, 0));
        buttons.setOpaque(false);
        buttons.setPreferredSize(new Dimension(80, 28));
        buttons.setMinimumSize(new Dimension(80, 28));

        JButton btnAdd = createTinyButton("+", () -> {
            if (isPlayer) gridManager.buyItem(playerUuid, itemId, 1);
            else repository.modifyInventoryItem(playerUuid, itemId, 1);
        });
        btnAdd.setBackground(new Color(50, 110, 50));

        JButton btnRem = createTinyButton("-", () -> {
            if (isPlayer) {
                if (repository.getInventoryItemCount(playerUuid, itemId) > 0) {
                    double refund = gridManager.getBlockRegistry().getPrice(itemId) * 0.5;
                    PlayerProfile p = gridManager.getCachedProfile(playerUuid);
                    if (p != null) {
                        p.modifyMoney(refund);
                        repository.savePlayerProfile(p);
                        repository.modifyInventoryItem(playerUuid, itemId, -1);
                    }
                }
            } else {
                repository.modifyInventoryItem(playerUuid, itemId, -1);
            }
        });
        btnRem.setBackground(new Color(120, 50, 50));

        buttons.add(btnRem);
        buttons.add(btnAdd);

        row.add(lblInfo, BorderLayout.CENTER);
        row.add(buttons, BorderLayout.EAST);
        return row;
    }

    private void updateAllLabels() {
        // Safe check: se il pannello non Ã¨ piÃ¹ visualizzabile, fermati
        if (!this.isDisplayable()) {
            dispose();
            return;
        }
        for (String id : itemIds) {
            JLabel lbl = labelMap.get(id);
            if (lbl != null) {
                int count = repository.getInventoryItemCount(playerUuid, id);
                lbl.setText(id + ": " + count);
            }
        }
    }

    private JButton createTinyButton(String t, Runnable a) {
        JButton b = new JButton(t);
        b.setPreferredSize(new Dimension(35, 25));
        b.setMargin(new Insets(0, 0, 0, 0));
        b.setFont(new Font("SansSerif", Font.BOLD, 14));
        b.setFocusable(false);
        b.setForeground(Color.WHITE);
        b.addActionListener(e -> { a.run(); updateAllLabels(); });
        return b;
    }
}


--------------------------------
FILE: MatterWorksGUI.java
--------------------------------
package com.matterworks.core.infrastructure.swing;

import com.matterworks.core.domain.machines.BlockRegistry;
import com.matterworks.core.domain.player.PlayerProfile;
import com.matterworks.core.managers.GridManager;
import com.matterworks.core.ports.IRepository;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class MatterWorksGUI extends JFrame {

    private final GridManager gridManager;
    private final BlockRegistry registry;
    private final IRepository repository;
    private final Runnable onSave;

    private final FactoryPanel factoryPanel;
    private final JTabbedPane rightTabbedPane;
    private final JPanel glassPane;

    private JComboBox<Object> playerSelector;
    private JLabel lblMoney, lblTool, lblOrient, lblLayer, lblPlotId;

    private final Timer repaintTimer;
    private final Timer economyTimer;

    private UUID currentPlayerUuid;
    private List<PlayerProfile> cachedPlayerList = new ArrayList<>();

    public MatterWorksGUI(GridManager gm, BlockRegistry reg, UUID initialUuid,
                          Runnable onSave, IRepository repo) {

        this.gridManager = gm;
        this.registry = reg;
        this.repository = repo;
        this.currentPlayerUuid = initialUuid;
        this.onSave = onSave;

        this.factoryPanel = new FactoryPanel(gm, reg, currentPlayerUuid, this::updateLabels);
        this.rightTabbedPane = new JTabbedPane();
        this.rightTabbedPane.setPreferredSize(new Dimension(340, 0));

        // Loading Overlay
        this.glassPane = new JPanel() {
            @Override
            protected void paintComponent(Graphics g) {
                g.setColor(new Color(0, 0, 0, 180));
                g.fillRect(0, 0, getWidth(), getHeight());
                g.setColor(Color.WHITE);
                g.setFont(new Font("SansSerif", Font.BOLD, 26));
                String msg = "SWITCHING VIEW...";
                FontMetrics fm = g.getFontMetrics();
                g.drawString(msg, (getWidth() - fm.stringWidth(msg)) / 2, getHeight() / 2);
            }
        };
        glassPane.setOpaque(false);
        glassPane.addMouseListener(new MouseAdapter() {});
        glassPane.addMouseMotionListener(new MouseAdapter() {});
        setGlassPane(glassPane);

        setTitle("MatterWorks Architect - Multi-User Management");
        setSize(1600, 950);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);
        setLayout(new BorderLayout());

        JPanel topContainer = createTopContainer();
        updateTabs();
        JPanel statusBar = createStatusBar();

        add(topContainer, BorderLayout.NORTH);
        add(factoryPanel, BorderLayout.CENTER);
        add(rightTabbedPane, BorderLayout.EAST);
        add(statusBar, BorderLayout.SOUTH);

        // Timer
        repaintTimer = new Timer(40, e -> factoryPanel.repaint());
        economyTimer = new Timer(1000, e -> updateEconomyLabels());

        repaintTimer.start();
        economyTimer.start();

        setVisible(true);
        factoryPanel.requestFocusInWindow();
        updateLabels();

        // Caricamento iniziale
        if(currentPlayerUuid != null) {
            gridManager.loadPlotFromDB(currentPlayerUuid);
        }
    }

    private void setLoading(boolean loading) {
        SwingUtilities.invokeLater(() -> {
            glassPane.setVisible(loading);
            playerSelector.setEnabled(!loading);
        });
    }

    private JPanel createTopContainer() {
        JPanel container = new JPanel(new BorderLayout());
        JPanel header = new JPanel(new FlowLayout(FlowLayout.LEFT, 20, 10));
        header.setBackground(new Color(45, 45, 48));

        playerSelector = new JComboBox<>();
        refreshPlayerList(true);

        playerSelector.addActionListener(e -> {
            if (!glassPane.isVisible()) handlePlayerSwitch();
        });

        lblMoney = createLabel("MONEY: $---", Color.GREEN, 16);
        header.add(new JLabel("ACTIVE USER:") {{ setForeground(Color.WHITE); }});
        header.add(playerSelector);
        header.add(lblMoney);

        JPanel toolbar = new JPanel(new BorderLayout());
        toolbar.setBackground(new Color(60, 60, 65));

        JPanel leftTools = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 5));
        leftTools.setOpaque(false);
        leftTools.add(createToolButton("â› Drill", "drill_mk1"));
        leftTools.add(createToolButton("âª  Belt", "conveyor_belt"));
        leftTools.add(createToolButton("ðŸŽ¨ Chromator", "chromator"));
        leftTools.add(createToolButton("ðŸŒª Mixer", "color_mixer"));
        leftTools.add(createToolButton("ðŸ”® Nexus", "nexus_core"));
        leftTools.add(new JSeparator(SwingConstants.VERTICAL) {{ setPreferredSize(new Dimension(5, 25)); }});
        leftTools.add(createSimpleButton("â¬‡ DOWN", e -> changeLayer(-1)));
        leftTools.add(createSimpleButton("â¬† UP", e -> changeLayer(1)));

        JPanel rightSystem = new JPanel(new FlowLayout(FlowLayout.RIGHT, 10, 5));
        rightSystem.setOpaque(false);

        JButton btnSOS = createSimpleButton("ðŸ†˜ SOS", e -> {
            if (gridManager.attemptBailout(currentPlayerUuid)) {
                JOptionPane.showMessageDialog(this, "SOS approved!");
            }
        });
        btnSOS.setBackground(new Color(220, 150, 0));

        JButton btnSave = createSimpleButton("ðŸ’¾ SAVE", e -> onSave.run());
        btnSave.setBackground(new Color(0, 100, 200));

        JButton btnReset = createSimpleButton("âš ï¸ RESET", e -> {
            if (JOptionPane.showConfirmDialog(this, "Reset plot?") == JOptionPane.YES_OPTION) {
                gridManager.resetUserPlot(currentPlayerUuid);
            }
        });
        btnReset.setBackground(new Color(180, 0, 0));

        JButton btnDelete = createSimpleButton("ðŸ’€ DELETE", e -> handleDeletePlayer());
        btnDelete.setBackground(Color.BLACK);
        btnDelete.setForeground(Color.RED);
        btnDelete.setBorder(BorderFactory.createLineBorder(Color.RED, 1));

        rightSystem.add(btnSOS);
        rightSystem.add(btnSave);
        rightSystem.add(btnReset);
        rightSystem.add(btnDelete);

        toolbar.add(leftTools, BorderLayout.WEST);
        toolbar.add(rightSystem, BorderLayout.EAST);
        container.add(header, BorderLayout.NORTH);
        container.add(toolbar, BorderLayout.SOUTH);
        return container;
    }

    private void handleDeletePlayer() {
        if (currentPlayerUuid == null) return;

        int confirm = JOptionPane.showConfirmDialog(this,
                "ELIMINARE DEFINITIVAMENTE QUESTO GIOCATORE?",
                "Delete Player", JOptionPane.YES_NO_OPTION, JOptionPane.ERROR_MESSAGE);

        if (confirm == JOptionPane.YES_OPTION) {
            setLoading(true);
            UUID toDelete = currentPlayerUuid;

            new Thread(() -> {
                gridManager.deletePlayer(toDelete);

                SwingUtilities.invokeLater(() -> {
                    refreshPlayerList(true);

                    if (!cachedPlayerList.isEmpty()) {
                        PlayerProfile next = cachedPlayerList.get(0);
                        this.currentPlayerUuid = next.getPlayerId();
                        factoryPanel.setPlayerUuid(next.getPlayerId());
                        new Thread(() -> {
                            gridManager.loadPlotFromDB(next.getPlayerId());
                            SwingUtilities.invokeLater(() -> {
                                updateTabs();
                                setLoading(false);
                            });
                        }).start();
                    } else {
                        this.currentPlayerUuid = null;
                        factoryPanel.setPlayerUuid(null);
                        updateTabs();
                        setLoading(false);
                    }
                });
            }).start();
        }
    }

    private JPanel createStatusBar() {
        JPanel statusPanel = new JPanel(new BorderLayout());
        statusPanel.setBackground(new Color(35, 35, 35));
        JPanel leftStatus = new JPanel(new FlowLayout(FlowLayout.LEFT, 20, 5));
        leftStatus.setOpaque(false);
        lblTool = createLabel("TOOL: Drill", Color.WHITE, 12);
        lblOrient = createLabel("DIR: NORTH", Color.WHITE, 12);
        lblLayer = createLabel("LAYER: 0", Color.CYAN, 12);
        leftStatus.add(lblTool); leftStatus.add(lblOrient); leftStatus.add(lblLayer);
        lblPlotId = createLabel("PLOT ID: #---", Color.LIGHT_GRAY, 12);
        statusPanel.add(leftStatus, BorderLayout.WEST);
        statusPanel.add(lblPlotId, BorderLayout.EAST);
        return statusPanel;
    }

    private void updateTabs() {
        // Dispose old panels (Anti-Lag Fix)
        for (Component c : rightTabbedPane.getComponents()) {
            if (c instanceof InventoryDebugPanel) ((InventoryDebugPanel) c).dispose();
            if (c instanceof TechTreePanel) ((TechTreePanel) c).dispose();
        }

        rightTabbedPane.removeAll();
        if (currentPlayerUuid != null) {
            rightTabbedPane.addTab("Shop", new InventoryDebugPanel(repository, currentPlayerUuid, gridManager));
            rightTabbedPane.addTab("Tech Tree", new TechTreePanel(repository, currentPlayerUuid, gridManager));
        } else {
            rightTabbedPane.addTab("Info", new JPanel() {{ add(new JLabel("No Player")); }});
        }
    }

    private void handlePlayerSwitch() {
        Object sel = playerSelector.getSelectedItem();

        if (sel instanceof PlayerProfile p) {
            UUID newUuid = p.getPlayerId();
            if (newUuid.equals(this.currentPlayerUuid)) return;

            setLoading(true);

            new Thread(() -> {
                try {
                    // Assicura caricamento in memoria (no unload)
                    gridManager.loadPlotFromDB(newUuid);

                    SwingUtilities.invokeLater(() -> {
                        this.currentPlayerUuid = newUuid;
                        factoryPanel.setPlayerUuid(newUuid);
                        updateTabs();
                        updateLabels();
                        updateEconomyLabels();
                        setLoading(false);
                    });
                } catch (Exception ex) {
                    ex.printStackTrace();
                    setLoading(false);
                }
            }).start();

        } else if ("--- ADD NEW PLAYER ---".equals(sel)) {
            String n = JOptionPane.showInputDialog("Name:");
            if (n != null && !n.isBlank()) {
                gridManager.createNewPlayer(n);
                refreshPlayerList(true);
            } else {
                refreshPlayerList(false);
            }
        }
    }

    private void refreshPlayerList(boolean forceDb) {
        ActionListener[] listeners = playerSelector.getActionListeners();
        for (var l : listeners) playerSelector.removeActionListener(l);

        if (forceDb) cachedPlayerList = repository.getAllPlayers();

        playerSelector.removeAllItems();
        for (PlayerProfile p : cachedPlayerList) playerSelector.addItem(p);
        playerSelector.addItem("--- ADD NEW PLAYER ---");

        if (currentPlayerUuid != null) {
            for (int i = 0; i < playerSelector.getItemCount(); i++) {
                if (playerSelector.getItemAt(i) instanceof PlayerProfile p && p.getPlayerId().equals(currentPlayerUuid)) {
                    playerSelector.setSelectedIndex(i);
                    break;
                }
            }
        }

        for (var l : listeners) playerSelector.addActionListener(l);
    }

    private void updateEconomyLabels() {
        if (currentPlayerUuid == null) {
            lblMoney.setText("MONEY: $---");
            lblPlotId.setText("PLOT ID: ---");
            return;
        }
        PlayerProfile p = gridManager.getCachedProfile(currentPlayerUuid);
        if (p != null) {
            lblMoney.setText(String.format("MONEY: $%,.2f [%s]", p.getMoney(), p.getRank()));
            lblMoney.setForeground(p.isAdmin() ? new Color(255, 215, 0) : Color.GREEN);
        }
    }

    private void updateLabels() {
        if (lblTool != null) {
            lblTool.setText("TOOL: " + factoryPanel.getCurrentToolName());
            lblOrient.setText("DIR: " + factoryPanel.getCurrentOrientationName());
            lblLayer.setText("LAYER: " + factoryPanel.getCurrentLayer());
        }
    }

    private void changeLayer(int delta) {
        int newY = Math.max(0, factoryPanel.getCurrentLayer() + delta);
        factoryPanel.setLayer(newY);
        updateLabels();
    }

    private JButton createToolButton(String text, String itemId) {
        JButton btn = createSimpleButton(text, e -> { factoryPanel.setTool(itemId); updateLabels(); });
        btn.addMouseListener(new MouseAdapter() {
            public void mouseClicked(MouseEvent e) {
                if (SwingUtilities.isRightMouseButton(e) && currentPlayerUuid != null)
                    gridManager.buyItem(currentPlayerUuid, itemId, 1);
            }
        });
        return btn;
    }

    private JButton createSimpleButton(String text, java.awt.event.ActionListener action) {
        JButton btn = new JButton(text);
        btn.setFocusable(false); btn.addActionListener(action);
        btn.setBackground(new Color(70, 70, 70)); btn.setForeground(Color.WHITE);
        return btn;
    }

    private JLabel createLabel(String text, Color color, int size) {
        JLabel lbl = new JLabel(text);
        lbl.setForeground(color);
        lbl.setFont(new Font("Monospaced", Font.BOLD, size));
        return lbl;
    }
}


--------------------------------
FILE: TechTreePanel.java
--------------------------------
package com.matterworks.core.infrastructure.swing;

import com.matterworks.core.domain.player.PlayerProfile;
import com.matterworks.core.managers.GridManager;
import com.matterworks.core.managers.TechManager;
import com.matterworks.core.ports.IRepository;

import javax.swing.*;
import java.awt.*;
import java.util.UUID;

public class TechTreePanel extends JPanel {

    private final IRepository repository;
    private final UUID playerUuid;
    private final GridManager gridManager;
    private final Timer refreshTimer;

    public TechTreePanel(IRepository repository, UUID playerUuid, GridManager gm) {
        this.repository = repository;
        this.playerUuid = playerUuid;
        this.gridManager = gm;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBackground(new Color(30, 30, 35));
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        renderNodes();

        // Timer di refresh 1 secondo
        refreshTimer = new Timer(1000, e -> {
            if (!this.isDisplayable()) {
                dispose();
                return;
            }
            renderNodes();
        });
        refreshTimer.start();
    }

    public void dispose() {
        if (refreshTimer != null && refreshTimer.isRunning()) {
            refreshTimer.stop();
        }
    }

    private void renderNodes() {
        removeAll();

        JLabel title = new JLabel("RESEARCH & DEVELOPMENT");
        title.setForeground(Color.ORANGE);
        title.setFont(new Font("Monospaced", Font.BOLD, 16));
        title.setAlignmentX(Component.CENTER_ALIGNMENT);
        add(title);
        add(Box.createVerticalStrut(15));

        TechManager tm = gridManager.getTechManager();
        // Use Cache
        PlayerProfile p = gridManager.getCachedProfile(playerUuid);

        if (p == null) return;

        for (TechManager.TechNode node : tm.getAllNodes()) {
            add(createTechCard(node, tm, p));
            add(Box.createVerticalStrut(10));
        }

        revalidate();
        repaint();
    }

    private JPanel createTechCard(TechManager.TechNode node, TechManager tm, PlayerProfile p) {
        boolean unlocked = p.hasTech(node.id());

        boolean parentsUnlocked = true;
        for (String parentId : node.parentIds()) {
            if (!p.hasTech(parentId)) {
                parentsUnlocked = false;
                break;
            }
        }

        boolean canAfford = p.getMoney() >= node.cost();

        JPanel card = new JPanel(new BorderLayout(10, 5));
        card.setBackground(new Color(50, 50, 55));
        card.setBorder(BorderFactory.createLineBorder(Color.DARK_GRAY, 1));
        card.setMaximumSize(new Dimension(310, 70));
        card.setPreferredSize(new Dimension(310, 70));

        JPanel info = new JPanel(new GridLayout(2, 1));
        info.setOpaque(false);
        JLabel lblName = new JLabel(node.name());
        lblName.setForeground(Color.WHITE);
        lblName.setFont(new Font("SansSerif", Font.BOLD, 13));

        String unlockText = String.join(", ", node.unlockItemIds());
        JLabel lblDetail = new JLabel("Cost: $" + (int)node.cost() + " | Unlocks: " + unlockText);
        lblDetail.setForeground(Color.LIGHT_GRAY);
        lblDetail.setFont(new Font("Monospaced", Font.PLAIN, 10));

        info.add(lblName);
        info.add(lblDetail);
        info.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 0));

        JButton btnAction = new JButton();
        btnAction.setPreferredSize(new Dimension(100, 40));
        btnAction.setFont(new Font("SansSerif", Font.BOLD, 11));
        btnAction.setFocusable(false);

        if (unlocked) {
            btnAction.setText("ACQUISITO");
            btnAction.setBackground(new Color(80, 80, 80));
            btnAction.setForeground(Color.LIGHT_GRAY);
            btnAction.setEnabled(false);
        } else if (!parentsUnlocked) {
            btnAction.setText("BLOCCATO");
            btnAction.setBackground(new Color(120, 40, 40));
            btnAction.setForeground(Color.WHITE);
            btnAction.setEnabled(false);
            if (!node.parentIds().isEmpty()) {
                btnAction.setToolTipText("Richiede: " + String.join(", ", node.parentIds()));
            }
        } else {
            btnAction.setText("SBLOCCA");
            btnAction.setBackground(canAfford ? new Color(40, 140, 40) : new Color(100, 100, 40));
            btnAction.setForeground(Color.WHITE);
            btnAction.addActionListener(e -> {
                if (tm.unlockNode(p, node.id())) {
                    renderNodes();
                }
            });
        }

        card.add(info, BorderLayout.CENTER);
        card.add(btnAction, BorderLayout.EAST);

        return card;
    }
}


--------------------------------
FILE: GridManager.java
--------------------------------
package com.matterworks.core.managers;

import com.matterworks.core.common.Direction;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.factory.MachineFactory;
import com.matterworks.core.domain.machines.*;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.player.PlayerProfile;
import com.matterworks.core.domain.shop.MarketManager;
import com.matterworks.core.infrastructure.MariaDBAdapter;
import com.matterworks.core.infrastructure.ServerConfig;
import com.matterworks.core.model.PlotObject;
import com.matterworks.core.ports.IRepository;
import com.matterworks.core.ports.IWorldAccess;
import com.matterworks.core.database.dao.TechDefinitionDAO;
import com.matterworks.core.database.dao.PlotDAO;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

public class GridManager {

    private final IRepository repository;
    private final IWorldAccess worldAdapter;
    private final BlockRegistry blockRegistry;
    private final MarketManager marketManager;
    private final TechManager techManager;

    // Cache Globale: Mantiene TUTTI i player caricati per la simulazione
    private final Map<UUID, PlayerProfile> activeProfileCache = new ConcurrentHashMap<>();
    private final Map<UUID, Map<GridPosition, PlacedMachine>> playerGrids = new ConcurrentHashMap<>();
    private final Map<UUID, Map<GridPosition, MatterColor>> playerResources = new ConcurrentHashMap<>();

    // Lista unica sincronizzata per il tick loop
    private final List<PlacedMachine> tickingMachines = Collections.synchronizedList(new ArrayList<>());

    private final ExecutorService ioExecutor = Executors.newVirtualThreadPerTaskExecutor();
    private ServerConfig serverConfig;

    public GridManager(IRepository repository, IWorldAccess worldAdapter, BlockRegistry registry) {
        this.repository = repository;
        this.worldAdapter = worldAdapter;
        this.blockRegistry = registry;
        this.marketManager = new MarketManager(repository);

        TechDefinitionDAO techDao = null;
        if (repository instanceof MariaDBAdapter adapter) {
            techDao = adapter.getTechDefinitionDAO();
        }
        this.techManager = new TechManager(repository, techDao);

        this.serverConfig = repository.loadServerConfig();
        System.out.println("âš™ï¸ [Core] Config Loaded: StartMoney=" + serverConfig.startMoney() + ", Veins=" + serverConfig.veinRaw());
    }

    public TechManager getTechManager() { return techManager; }
    public MarketManager getMarketManager() { return marketManager; }

    // --- CARICAMENTO SIMULAZIONE (No Unload) ---

    /**
     * Metodo richiesto da Main.java.
     * Carica il plot nella simulazione globale se non Ã¨ giÃ  presente.
     */
    public void loadPlotFromDB(UUID ownerId) {
        if (ownerId == null) return;

        // Se Ã¨ giÃ  in memoria, non facciamo nulla (evita IO inutile)
        if (activeProfileCache.containsKey(ownerId)) return;

        ioExecutor.submit(() -> {
            System.out.println("ðŸ“¥ [Sim] Loading chunk for " + ownerId);
            loadPlotSynchronously(ownerId);
            PlayerProfile p = repository.loadPlayerProfile(ownerId);
            if (p != null) activeProfileCache.put(ownerId, p);
        });
    }

    private void loadPlotSynchronously(UUID ownerId) {
        // Rimuove eventuali dati parziali SOLO di questo player
        unloadPlotSpecific(ownerId);

        try {
            // 1. Risorse
            if (repository instanceof MariaDBAdapter db) {
                Long pid = db.getPlotId(ownerId);
                if (pid != null) {
                    Map<GridPosition, MatterColor> res = db.loadResources(pid);
                    if (res.isEmpty()) generateDefaultResources(db, pid, res);
                    playerResources.put(ownerId, res);
                }
            }
            // 2. Macchine
            List<PlotObject> dtos = repository.loadPlotMachines(ownerId);
            for (PlotObject d : dtos) {
                PlacedMachine m = MachineFactory.createFromModel(d, ownerId);
                if (m != null) internalAddMachine(ownerId, m);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void unloadPlotSpecific(UUID ownerId) {
        playerGrids.remove(ownerId);
        playerResources.remove(ownerId);
        // Rimuove dalla simulazione solo le macchine di questo utente
        synchronized (tickingMachines) {
            tickingMachines.removeIf(m -> m.getOwnerId().equals(ownerId));
        }
    }

    // --- LOGICA DI GIOCO & CAP ---

    public boolean placeMachine(UUID ownerId, GridPosition pos, String typeId, Direction orientation) {
        PlayerProfile player = getCachedProfile(ownerId);
        if (player == null) return false;

        // 1. Tech Check
        if (!techManager.canBuyItem(player, typeId)) {
            System.err.println("ðŸ”’ [Game] Tech mancante: " + typeId);
            return false;
        }

        // 2. Vein Check (Drill)
        if (typeId.equals("drill_mk1")) {
            Map<GridPosition, MatterColor> res = playerResources.get(ownerId);
            if (res == null || !res.containsKey(pos)) return false;
        }

        // 3. Inventory Check
        if (!player.isAdmin() && repository.getInventoryItemCount(ownerId, typeId) <= 0) return false;

        // 4. Area Check
        Vector3Int dim = blockRegistry.getDimensions(typeId);
        Vector3Int effDim = (orientation == Direction.EAST || orientation == Direction.WEST) ? new Vector3Int(dim.z(), dim.y(), dim.x()) : dim;
        if (!isAreaClear(ownerId, pos, effDim)) return false;

        // Esegui Piazzamento
        if (!player.isAdmin()) repository.modifyInventoryItem(ownerId, typeId, -1);

        PlotObject dto = new PlotObject(null, null, pos.x(), pos.y(), pos.z(), typeId, null);
        PlacedMachine m = MachineFactory.createFromModel(dto, ownerId);
        if (m == null) return false;

        m.setOrientation(orientation);
        m.setGridContext(this);
        if (m instanceof DrillMachine drill) drill.setResourceToMine(playerResources.get(ownerId).get(pos));

        internalAddMachine(ownerId, m);
        m.onPlace(worldAdapter);
        repository.createMachine(ownerId, m);
        return true;
    }

    public boolean buyItem(UUID playerId, String itemId, int amount) {
        PlayerProfile p = getCachedProfile(playerId);
        if (p == null) return false;

        if (!techManager.canBuyItem(p, itemId)) {
            System.err.println("ðŸ”’ [Shop] Tech mancante per " + itemId);
            return false;
        }

        // --- CAP SYSTEM ---
        if (!p.isAdmin() && !checkItemCap(playerId, itemId, amount)) return false;

        double cost = blockRegistry.getStats(itemId).basePrice() * amount;
        if (!p.isAdmin() && p.getMoney() < cost) return false;

        if (!p.isAdmin()) {
            p.modifyMoney(-cost);
            repository.savePlayerProfile(p);
            activeProfileCache.put(playerId, p); // Update Cache
        }
        repository.modifyInventoryItem(playerId, itemId, amount);
        return true;
    }

    private boolean checkItemCap(UUID playerId, String itemId, int incomingAmount) {
        int inInventory = repository.getInventoryItemCount(playerId, itemId);
        Map<GridPosition, PlacedMachine> placed = playerGrids.get(playerId);
        long placedCount = (placed != null) ? placed.values().stream().filter(m -> m.getTypeId().equals(itemId)).count() : 0;
        long total = inInventory + placedCount + incomingAmount;

        // Nexus: Max 1
        if (itemId.equals("nexus_core") && total > 1) {
            System.err.println("ðŸš« CAP: Massimo 1 Nexus consentito.");
            return false;
        }
        // Trivelle: Max <= Numero Vene
        if (itemId.equals("drill_mk1")) {
            Map<GridPosition, MatterColor> veins = playerResources.get(playerId);
            int totalVeins = (veins != null) ? veins.size() : 0;
            if (total > totalVeins) {
                System.err.println("ðŸš« CAP: Max trivelle raggiunto (" + totalVeins + ")");
                return false;
            }
        }
        return true;
    }

    // --- PLAYER MANAGEMENT ---

    public PlayerProfile createNewPlayer(String username) {
        this.serverConfig = repository.loadServerConfig(); // Reload config
        UUID newUuid = UUID.randomUUID();
        PlayerProfile p = new PlayerProfile(newUuid);
        p.setUsername(username);
        p.setMoney(serverConfig.startMoney()); // Config Money
        p.setRank(PlayerProfile.PlayerRank.PLAYER);

        repository.savePlayerProfile(p);
        activeProfileCache.put(p.getPlayerId(), p);

        // Starter Kit
        repository.modifyInventoryItem(newUuid, "drill_mk1", 1);
        repository.modifyInventoryItem(newUuid, "nexus_core", 1);
        repository.modifyInventoryItem(newUuid, "conveyor_belt", 1);

        if (repository instanceof MariaDBAdapter adapter) {
            PlotDAO plotDAO = new PlotDAO(adapter.getDbManager());
            Long plotId = plotDAO.createPlot(newUuid, 1, 0, 0);
            if (plotId != null) generateDefaultResources(adapter, plotId, new HashMap<>());
        }
        return p;
    }

    public void deletePlayer(UUID ownerId) {
        unloadPlotSpecific(ownerId);
        activeProfileCache.remove(ownerId);
        repository.deletePlayerFull(ownerId);
        System.out.println("ðŸ’€ [Manager] Player " + ownerId + " eliminato.");
    }

    public boolean attemptBailout(UUID ownerId) {
        PlayerProfile player = getCachedProfile(ownerId);
        if (player == null) return false;

        this.serverConfig = repository.loadServerConfig();
        if (player.getMoney() < serverConfig.sosThreshold()) {
            player.setMoney(serverConfig.sosThreshold());
            repository.savePlayerProfile(player);
            activeProfileCache.put(ownerId, player);
            return true;
        }
        return false;
    }

    public void resetUserPlot(UUID ownerId) {
        ioExecutor.submit(() -> {
            unloadPlotSpecific(ownerId);
            if (repository instanceof MariaDBAdapter db) db.clearPlotData(ownerId);
            loadPlotSynchronously(ownerId);
        });
    }

    // --- UTILS ---

    public void removeComponent(UUID ownerId, GridPosition pos) {
        PlacedMachine target = getMachineAt(ownerId, pos);
        if (target == null) return;
        repository.modifyInventoryItem(ownerId, target.getTypeId(), 1);
        if (target.getDbId() != null) repository.deleteMachine(target.getDbId());

        synchronized (tickingMachines) {
            removeFromGridMap(ownerId, target);
            tickingMachines.remove(target);
        }
        target.onRemove();
    }

    public boolean isAreaClear(UUID id, GridPosition o, Vector3Int dim) {
        Map<GridPosition, PlacedMachine> g = playerGrids.get(id);
        if (g == null) return true;
        for(int x = 0; x < dim.x(); x++) {
            for(int y = 0; y < dim.y(); y++) {
                for(int z = 0; z < dim.z(); z++) {
                    GridPosition checkPos = new GridPosition(o.x() + x, o.y() + y, o.z() + z);
                    if (g.containsKey(checkPos)) return false;
                }
            }
        }
        return true;
    }

    public PlacedMachine getMachineAt(UUID id, GridPosition pos) {
        Map<GridPosition, PlacedMachine> g = playerGrids.get(id);
        return g != null ? g.get(pos) : null;
    }

    public void tick(long t) {
        // Itera su TUTTO il mondo caricato (Multitenant Simulation)
        synchronized (tickingMachines) {
            for (PlacedMachine m : tickingMachines) {
                m.tick(t);
            }
        }
    }

    private void internalAddMachine(UUID id, PlacedMachine m) {
        m.setGridContext(this);
        Map<GridPosition, PlacedMachine> grid = playerGrids.computeIfAbsent(id, k -> new ConcurrentHashMap<>());
        Vector3Int dim = m.getDimensions(); GridPosition o = m.getPos();
        for(int x=0; x<dim.x(); x++) for(int y=0; y<dim.y(); y++) for(int z=0; z<dim.z(); z++)
            grid.put(new GridPosition(o.x()+x, o.y()+y, o.z()+z), m);
        synchronized (tickingMachines) { tickingMachines.add(m); }
    }

    private void removeFromGridMap(UUID id, PlacedMachine m) {
        Map<GridPosition, PlacedMachine> grid = playerGrids.get(id);
        if (grid == null) return;
        Vector3Int dim = m.getDimensions(); GridPosition o = m.getPos();
        for(int x=0; x<dim.x(); x++) for(int y=0; y<dim.y(); y++) for(int z=0; z<dim.z(); z++)
            grid.remove(new GridPosition(o.x()+x, o.y()+y, o.z()+z));
    }

    private void generateDefaultResources(MariaDBAdapter db, Long plotId, Map<GridPosition, MatterColor> cache) {
        Random rnd = new Random();
        for (int i = 0; i < serverConfig.veinRaw(); i++) createResource(db, plotId, cache, rnd.nextInt(18)+1, 0, rnd.nextInt(18)+1, MatterColor.RAW);
        for (int i = 0; i < serverConfig.veinRed(); i++) createResource(db, plotId, cache, rnd.nextInt(18)+1, 0, rnd.nextInt(18)+1, MatterColor.RED);
        for (int i = 0; i < serverConfig.veinBlue(); i++) createResource(db, plotId, cache, rnd.nextInt(18)+1, 0, rnd.nextInt(18)+1, MatterColor.BLUE);
        for (int i = 0; i < serverConfig.veinYellow(); i++) createResource(db, plotId, cache, rnd.nextInt(18)+1, 0, rnd.nextInt(18)+1, MatterColor.YELLOW);
    }

    private void createResource(MariaDBAdapter db, Long pid, Map<GridPosition, MatterColor> c, int x, int y, int z, MatterColor t) {
        while (c.containsKey(new GridPosition(x, y, z))) {
            x = new Random().nextInt(18) + 1;
            z = new Random().nextInt(18) + 1;
        }
        db.saveResource(pid, x, z, t);
        c.put(new GridPosition(x,y,z), t);
    }

    public PlayerProfile getCachedProfile(UUID uuid) {
        if (uuid == null) return null;
        return activeProfileCache.computeIfAbsent(uuid, repository::loadPlayerProfile);
    }

    public Map<GridPosition, PlacedMachine> getSnapshot(UUID id) {
        Map<GridPosition, PlacedMachine> g = playerGrids.get(id);
        return g != null ? new HashMap<>(g) : Collections.emptyMap();
    }

    public Map<GridPosition, PlacedMachine> getAllMachinesSnapshot() {
        Map<GridPosition, PlacedMachine> all = new HashMap<>();
        for (var map : playerGrids.values()) all.putAll(map);
        return all;
    }

    public Map<GridPosition, MatterColor> getTerrainResources(UUID id) { return playerResources.getOrDefault(id, Collections.emptyMap()); }
    public BlockRegistry getBlockRegistry() { return blockRegistry; }
}


--------------------------------
FILE: TechManager.java
--------------------------------
package com.matterworks.core.managers;

import com.matterworks.core.database.dao.TechDefinitionDAO;
import com.matterworks.core.domain.player.PlayerProfile;
import com.matterworks.core.ports.IRepository;
import java.util.*;

public class TechManager {

    private final IRepository repository;
    private final TechDefinitionDAO dao;

    public record TechNode(
            String id,
            String name,
            double cost,
            List<String> parentIds,
            List<String> unlockItemIds
    ) {}

    private final Map<String, TechNode> nodes = new LinkedHashMap<>();
    private final Set<String> baseItems = Set.of("drill_mk1", "conveyor_belt", "nexus_core");

    public TechManager(IRepository repository, TechDefinitionDAO dao) {
        this.repository = repository;
        this.dao = dao;
        loadFromDatabase();
    }

    public void loadFromDatabase() {
        nodes.clear();
        if (dao == null) return;

        List<TechNode> dbNodes = dao.loadAllNodes();
        for (TechNode node : dbNodes) {
            nodes.put(node.id(), node);
        }

        if (nodes.isEmpty()) {
            System.err.println("!!! TECH TREE EMPTY - Check Database Table 'tech_definitions' !!!");
        }
    }

    public boolean canBuyItem(PlayerProfile p, String itemId) {
        if (p.isAdmin()) return true;
        if (baseItems.contains(itemId)) return true;

        for (TechNode node : nodes.values()) {
            if (node.unlockItemIds().contains(itemId)) {
                return p.hasTech(node.id());
            }
        }
        return false;
    }

    public boolean unlockNode(PlayerProfile p, String nodeId) {
        TechNode node = nodes.get(nodeId);
        if (node == null) return false;

        if (p.hasTech(nodeId)) return false;
        if (p.getMoney() < node.cost()) return false;

        for (String parentId : node.parentIds()) {
            if (!p.hasTech(parentId)) return false;
        }

        p.modifyMoney(-node.cost());
        p.addTech(nodeId);
        repository.savePlayerProfile(p);
        return true;
    }

    public Collection<TechNode> getAllNodes() { return nodes.values(); }
    public TechNode getNode(String id) { return nodes.get(id); }
}


--------------------------------
FILE: WorldIntegrityValidator.java
--------------------------------
package com.matterworks.core.managers;

import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.domain.machines.BlockRegistry;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.model.PlotObject;
import com.matterworks.core.infrastructure.MariaDBAdapter;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.*;

public class WorldIntegrityValidator {

    private final DatabaseManager db;
    private final BlockRegistry registry;

    public WorldIntegrityValidator(DatabaseManager db, BlockRegistry registry) {
        this.db = db;
        this.registry = registry;
    }

    public boolean validateWorldIntegrity() {
        System.out.println("ðŸ” [System] Avvio Validazione IntegritÃ ...");
        Map<Long, List<PlotObject>> machinesByPlot = loadAllMachines();
        Map<Long, Map<GridPosition, MatterColor>> resourcesByPlot = loadAllResources();

        List<String> errorLog = new ArrayList<>();

        for (var entry : machinesByPlot.entrySet()) {
            Long plotId = entry.getKey();
            List<PlotObject> machines = entry.getValue();
            Map<GridPosition, MatterColor> resources = resourcesByPlot.getOrDefault(plotId, Collections.emptyMap());

            // 1. Check Sovrapposizioni [cite: 713, 720]
            validateOverlaps(plotId, machines, errorLog);

            // 2. Check Trivelle su Vene
            for (PlotObject m : machines) {
                if (m.getTypeId().equals("drill_mk1")) {
                    GridPosition pos = new GridPosition(m.getX(), m.getY(), m.getZ());
                    if (!resources.containsKey(pos)) {
                        errorLog.add("âŒ Plot " + plotId + ": Trivella (ID " + m.getId() + ") piazzata nel vuoto a " + pos);
                    }
                }
            }
        }

        if (errorLog.isEmpty()) {
            System.out.println("âœ… [System] IntegritÃ  verificata: 0 conflitti.");
            return true;
        } else {
            if (errorLog.size() > 100) {
                System.err.println("ðŸš¨ [System] ATTENZIONE: Rilevate " + errorLog.size() + " collisioni nel mondo! (Troppe per la lista)");
            } else {
                System.err.println("ðŸš¨ [System] RILEVATE COLLISIONI:");
                errorLog.forEach(System.err::println);
            }
            return false;
        }
    }

    private void validateOverlaps(Long plotId, List<PlotObject> machines, List<String> errorLog) {
        Map<GridPosition, Long> occupied = new HashMap<>();
        for (PlotObject m : machines) {
            Vector3Int dim = registry.getDimensions(m.getTypeId());
            for (int x=0; x<dim.x(); x++) for (int y=0; y<dim.y(); y++) for (int z=0; z<dim.z(); z++) {
                GridPosition p = new GridPosition(m.getX()+x, m.getY()+y, m.getZ()+z);
                if (occupied.containsKey(p)) {
                    errorLog.add("âš ï¸ Plot " + plotId + ": Conflitto a " + p + " tra ID " + m.getId() + " e ID " + occupied.get(p));
                }
                occupied.put(p, m.getId());
            }
        }
    }

    // ... (loadAllMachines e loadAllResources rimangono uguali alla versione precedente)
    private Map<Long, List<PlotObject>> loadAllMachines() {
        Map<Long, List<PlotObject>> result = new HashMap<>();
        String sql = "SELECT id, plot_id, x, y, z, type_id FROM plot_machines";
        try (Connection conn = db.getConnection(); PreparedStatement ps = conn.prepareStatement(sql); ResultSet rs = ps.executeQuery()) {
            while (rs.next()) {
                PlotObject obj = new PlotObject(rs.getLong("id"), rs.getLong("plot_id"), rs.getInt("x"), rs.getInt("y"), rs.getInt("z"), rs.getString("type_id"), null);
                result.computeIfAbsent(obj.getPlotId(), k -> new ArrayList<>()).add(obj);
            }
        } catch (Exception e) { e.printStackTrace(); }
        return result;
    }

    private Map<Long, Map<GridPosition, MatterColor>> loadAllResources() {
        Map<Long, Map<GridPosition, MatterColor>> result = new HashMap<>();
        String sql = "SELECT plot_id, x, z, resource_type FROM plot_resources";
        try (Connection conn = db.getConnection(); PreparedStatement ps = conn.prepareStatement(sql); ResultSet rs = ps.executeQuery()) {
            while (rs.next()) {
                long pid = rs.getLong("plot_id");
                GridPosition pos = new GridPosition(rs.getInt("x"), 0, rs.getInt("z"));
                MatterColor color = MatterColor.valueOf(rs.getString("resource_type"));
                result.computeIfAbsent(pid, k -> new HashMap<>()).put(pos, color);
            }
        } catch (Exception e) { e.printStackTrace(); }
        return result;
    }
}


--------------------------------
FILE: PlotObject.java
--------------------------------
package com.matterworks.core.model;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

public class PlotObject {

    private Long id;
    private Long plotId;
    private int x;
    private int y;
    private int z;
    private String typeId;
    private JsonObject metaData;

    // --- COSTRUTTORI ---

    // 1. Costruttore Vuoto (Richiesto dal Validator e da alcuni framework)
    public PlotObject() {
        this.metaData = new JsonObject();
    }

    // 2. Costruttore Completo
    public PlotObject(Long id, Long plotId, int x, int y, int z, String typeId, JsonObject metaData) {
        this.id = id;
        this.plotId = plotId;
        this.x = x;
        this.y = y;
        this.z = z;
        this.typeId = typeId;
        this.metaData = (metaData != null) ? metaData : new JsonObject();
    }

    // --- GETTERS & SETTERS ---

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getPlotId() { return plotId; }
    public void setPlotId(Long plotId) { this.plotId = plotId; }

    // Coordinate singole
    public int getX() { return x; }
    public void setX(int x) { this.x = x; }

    public int getY() { return y; }
    public void setY(int y) { this.y = y; }

    public int getZ() { return z; }
    public void setZ(int z) { this.z = z; }

    // Helper richiesto dal Validator
    public void setPosition(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    // Type ID
    public String getTypeId() { return typeId; }
    public void setTypeId(String typeId) { this.typeId = typeId; }

    // Metadata
    public JsonObject getMetaData() { return metaData; }
    public void setMetaData(JsonObject metaData) { this.metaData = metaData; }

    // --- METODI DI UTILITÃ€ ---

    public String getRawMetaData() {
        return this.metaData != null ? this.metaData.toString() : "{}";
    }

    public void setMetaDataFromString(String jsonString) {
        if (jsonString == null || jsonString.isEmpty()) {
            this.metaData = new JsonObject();
            return;
        }
        try {
            this.metaData = JsonParser.parseString(jsonString).getAsJsonObject();
        } catch (Exception e) {
            System.err.println("âš ï¸ Errore parsing JSON per PlotObject " + id + ": " + e.getMessage());
            this.metaData = new JsonObject();
        }
    }
}


--------------------------------
FILE: IMachineVisuals.java
--------------------------------
package com.matterworks.core.ports;

/**
 * Astrazione per effetti client-side (Particelle, Animazioni).
 * Definita nel namespace Core_Ports.
 */
public interface IMachineVisuals {
    void playAnimation(String animationName);
    void spawnParticle(String particleId);
}


--------------------------------
FILE: IRepository.java
--------------------------------
package com.matterworks.core.ports;

import com.matterworks.core.domain.machines.PlacedMachine;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.player.PlayerProfile;
import com.matterworks.core.infrastructure.ServerConfig;
import com.matterworks.core.model.PlotObject;
import com.matterworks.core.common.GridPosition;

import java.util.List;
import java.util.Map;
import java.util.UUID;

public interface IRepository {

    // --- CONFIG ---
    ServerConfig loadServerConfig();

    // --- PLAYER & PROFILE ---
    PlayerProfile loadPlayerProfile(UUID uuid);
    void savePlayerProfile(PlayerProfile profile);
    void deletePlayerFull(UUID uuid);

    // --- PLOT DATA ---
    List<PlotObject> loadPlotMachines(UUID ownerId);
    Long createMachine(UUID ownerId, PlacedMachine machine);
    void deleteMachine(Long dbId);
    void updateMachinesMetadata(List<PlacedMachine> machines);
    void clearPlotData(UUID ownerId);
    Long getPlotId(UUID ownerId);

    // --- RISORSE ---
    void saveResource(Long plotId, int x, int z, MatterColor type);
    Map<GridPosition, MatterColor> loadResources(Long plotId);

    // --- INVENTARIO ---
    int getInventoryItemCount(UUID ownerId, String itemId);
    void modifyInventoryItem(UUID ownerId, String itemId, int delta);
    List<PlayerProfile> getAllPlayers();
}


--------------------------------
FILE: IWorldAccess.java
--------------------------------
package com.matterworks.core.ports;

import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;

/**
 * Astrazione per toccare i blocchi di Hytale.
 * Definita nel namespace Core_Ports.
 */
public interface IWorldAccess {
    void setBlock(GridPosition pos, String blockId);
    boolean isBlockSolid(GridPosition pos);
    void createVisuals(GridPosition pos, String visualId);
    Vector3Int fetchExternalBlockDimensions(String blockId);
}


--------------------------------
FILE: FactoryLoop.java
--------------------------------
package com.matterworks.core.synchronization;

import com.matterworks.core.managers.GridManager;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Il Loop di Gioco.
 * - FactoryLoop.
 */
public class FactoryLoop {

    private final GridManager gridManager;
    private final ScheduledExecutorService scheduler;
    private final AtomicLong currentTick = new AtomicLong(0);
    private volatile boolean isRunning = false;

    public FactoryLoop(GridManager gridManager) {
        this.gridManager = gridManager;
        // Thread singolo dedicato al tick del gioco (per evitare race conditions nella logica)
        this.scheduler = Executors.newSingleThreadScheduledExecutor();
    }

    public void start() {
        if (isRunning) return;
        isRunning = true;

        // Hytale gira a 20 TPS (Ticks Per Second) -> 50ms per tick
        scheduler.scheduleAtFixedRate(this::runTick, 0, 50, TimeUnit.MILLISECONDS);
        System.out.println("ðŸ­ Factory Loop Started.");
    }

    public void stop() {
        isRunning = false;
        scheduler.shutdown();
    }

    /**
     * runTick
     */
    private void runTick() {
        try {
            long tick = currentTick.incrementAndGet();

            // 1. Tick della griglia (Macchine producono/consumano)
            gridManager.tick(tick);

            // TODO: Qui potremmo chiamare TechManager, CapManager, etc.

        } catch (Exception e) {
            System.err.println("CRITICAL: Exception in Factory Loop!");
            e.printStackTrace();
        }
    }
}


--------------------------------
FILE: GridSaverService.java
--------------------------------
package com.matterworks.core.synchronization;

import com.matterworks.core.common.GridPosition;
import com.matterworks.core.domain.machines.PlacedMachine;
import com.matterworks.core.managers.GridManager;
import com.matterworks.core.ports.IRepository;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

public class GridSaverService {

    private final GridManager gridManager;
    private final IRepository repository;

    public GridSaverService(GridManager gridManager, IRepository repository) {
        this.gridManager = gridManager;
        this.repository = repository;
    }

    public void autoSaveTask() {
        // FIX: Usa getAllMachinesSnapshot() invece di getSnapshot()
        // Questo recupera le macchine di TUTTI i giocatori per salvarle.
        Map<GridPosition, PlacedMachine> allMachines = gridManager.getAllMachinesSnapshot();

        List<PlacedMachine> dirtyMachines = allMachines.values().stream()
                .filter(PlacedMachine::isDirty)
                .distinct()
                .collect(Collectors.toList());

        if (dirtyMachines.isEmpty()) return;

        Map<UUID, List<PlacedMachine>> machinesByOwner = dirtyMachines.stream()
                .collect(Collectors.groupingBy(PlacedMachine::getOwnerId));

        System.out.println("ðŸ’¾ AutoSave: Saving dirty machines for " + machinesByOwner.size() + " plots.");

        for (Map.Entry<UUID, List<PlacedMachine>> entry : machinesByOwner.entrySet()) {
            List<PlacedMachine> toSave = entry.getValue();
            repository.updateMachinesMetadata(toSave);
            toSave.forEach(PlacedMachine::cleanDirty);
        }
    }
}
