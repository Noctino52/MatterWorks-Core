

--------------------------------
FILE: Main.java
--------------------------------
package com.matterworks;

//TIP To <b>Run</b> code, press <shortcut actionId="Run"/> or
// click the <icon src="AllIcons.Actions.Execute"/> icon in the gutter.
public class Main {
    public static void main(String[] args) {
        //TIP Press <shortcut actionId="ShowIntentionActions"/> with your caret at the highlighted text
        // to see how IntelliJ IDEA suggests fixing it.
        System.out.printf("Hello and welcome!");

        for (int i = 1; i <= 5; i++) {
            //TIP Press <shortcut actionId="Debug"/> to start debugging your code. We have set one <icon src="AllIcons.Debugger.Db_set_breakpoint"/> breakpoint
            // for you, but you can always add more by pressing <shortcut actionId="ToggleLineBreakpoint"/>.
            System.out.println("i = " + i);
        }
    }
}


--------------------------------
FILE: Main.java
--------------------------------
package com.matterworks.core;

import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.dao.MachineDefinitionDAO;
import com.matterworks.core.database.dao.PlayerDAO;
import com.matterworks.core.database.dao.PlotDAO;
import com.matterworks.core.domain.machines.BlockRegistry;
import com.matterworks.core.domain.player.PlayerProfile;
import com.matterworks.core.infrastructure.CoreConfig;
import com.matterworks.core.infrastructure.MariaDBAdapter;
import com.matterworks.core.infrastructure.swing.MatterWorksGUI;
import com.matterworks.core.managers.GridManager;
import com.matterworks.core.managers.WorldIntegrityValidator;
import com.matterworks.core.ports.IRepository;
import com.matterworks.core.ports.IWorldAccess;
import com.matterworks.core.synchronization.FactoryLoop;
import com.matterworks.core.synchronization.GridSaverService;

import javax.swing.SwingUtilities;
import java.awt.GraphicsEnvironment;
import java.util.UUID;

public class Main {

    public static void main(String[] args) throws InterruptedException {
        System.out.println("ðŸ­ MatterWorks Core Starting...");

        CoreConfig.load();

        String url = "jdbc:mariadb://dev.matterworks.org:3306/matterworks_core?allowPublicKeyRetrieval=true&useSSL=false";
        DatabaseManager dbManager = new DatabaseManager(url, "Noctino52", "Yy72s7mRnVs3");

        IWorldAccess world = new MockWorld();

        MachineDefinitionDAO defDao = new MachineDefinitionDAO(dbManager);
        BlockRegistry blockRegistry = new BlockRegistry(world, defDao);
        blockRegistry.loadFromDatabase();

        WorldIntegrityValidator validator = new WorldIntegrityValidator(dbManager, blockRegistry);
        if (!validator.validateWorldIntegrity()) {
            System.err.println("ðŸš¨ ATTENZIONE: Il mondo contiene collisioni! Controlla il DB.");
            Thread.sleep(2000);
        }

        IRepository repository = new MariaDBAdapter(dbManager);
        GridManager gridManager = new GridManager(repository, world, blockRegistry);
        GridSaverService saverService = new GridSaverService(gridManager, repository);

        FactoryLoop gameLoop = new FactoryLoop(gridManager);
        gameLoop.start();

        UUID playerUuid = UUID.fromString("550e8400-e29b-41d4-a716-446655440000");
        ensurePlayerExists(dbManager, playerUuid);
        ensurePlayerHasPlot(dbManager, playerUuid);

        System.out.println("ðŸ“¥ Caricamento Plot dal Database...");
        gridManager.loadPlotFromDB(playerUuid);
        Thread.sleep(500);

        if (GraphicsEnvironment.isHeadless()) {
            System.out.println("ðŸ‘» MODALITÃ€ HEADLESS ATTIVA (SERVER)");
        } else {
            System.out.println("ðŸ–¥ï¸ Monitor rilevato: Avvio GUI...");
            SwingUtilities.invokeLater(() -> {
                new MatterWorksGUI(
                        gridManager,
                        blockRegistry,
                        playerUuid,
                        () -> {
                            System.out.println("ðŸ’¾ Manual Save...");
                            saverService.autoSaveTask();
                        },
                        () -> {
                            PlayerProfile p = repository.loadPlayerProfile(playerUuid);
                            return (p != null) ? p.getMoney() : 0.0;
                        }
                );
            });
        }

        System.out.println("--- ðŸŸ¢ SISTEMA ONLINE ---");
        int ticks = 0;
        while (true) {
            Thread.sleep(1000);
            ticks++;
            if (ticks % 10 == 0) {
                System.out.println("ðŸ’¾ AutoSave Triggered...");
                saverService.autoSaveTask();
                PlayerProfile p = repository.loadPlayerProfile(playerUuid);
                if (p != null) {
                    System.out.println("   [Status] Saldo: " + p.getMoney() + "$ | Uptime: " + ticks + "s");
                }
            }
        }
    }

    private static void ensurePlayerExists(DatabaseManager db, UUID uuid) {
        PlayerDAO playerDao = new PlayerDAO(db);
        if (playerDao.load(uuid) == null) {
            PlayerProfile p = new PlayerProfile(uuid);
            p.setUsername("Noctino_Dev");
            p.setMoney(1000.0);
            playerDao.save(p);
        }
    }

    private static void ensurePlayerHasPlot(DatabaseManager db, UUID owner) {
        PlotDAO plotDao = new PlotDAO(db);
        if (plotDao.findPlotIdByOwner(owner) == null) {
            plotDao.createPlot(owner, 1, 0, 0);
        }
    }

    static class MockWorld implements IWorldAccess {
        @Override public void setBlock(GridPosition pos, String blockId) {}
        @Override public boolean isBlockSolid(GridPosition pos) { return true; }
        @Override public void createVisuals(GridPosition pos, String visualId) {}
        @Override public Vector3Int fetchExternalBlockDimensions(String blockId) { return Vector3Int.one(); }
    }
}


--------------------------------
FILE: Direction.java
--------------------------------
package com.matterworks.core.common;

public enum Direction {
    NORTH(0, 0, -1),
    EAST(1, 0, 0),
    SOUTH(0, 0, 1),
    WEST(-1, 0, 0),
    UP(0, 1, 0),
    DOWN(0, -1, 0);

    private final int x, y, z;

    Direction(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public Vector3Int toVector() {
        return new Vector3Int(x, y, z);
    }

    public Direction opposite() {
        return switch(this) {
            case NORTH -> SOUTH;
            case SOUTH -> NORTH;
            case EAST -> WEST;
            case WEST -> EAST;
            case UP -> DOWN;
            case DOWN -> UP;
        };
    }
}


--------------------------------
FILE: GridPosition.java
--------------------------------
package com.matterworks.core.common;

/**
 * Value Object immutabile che rappresenta una coordinata 3D nel mondo.
 * Usato come chiave primaria nelle HashMap del GridManager per accesso O(1).
 */
public record GridPosition(int x, int y, int z) {

    /**
     * Factory method statico per leggibilitÃ  (opzionale ma comodo).
     * Uso: GridPosition.of(10, 64, 10)
     */
    public static GridPosition of(int x, int y, int z) {
        return new GridPosition(x, y, z);
    }

    /**
     * Metodo di utilitÃ  per calcolare posizioni relative (es. "il blocco sopra").
     * Utile per logica di nastri trasportatori o controlli di adiacenza.
     */
    public GridPosition add(int dx, int dy, int dz) {
        return new GridPosition(x + dx, y + dy, z + dz);
    }

    public GridPosition add(Vector3Int vec) {
        return new GridPosition(x + vec.x(), y + vec.y(), z + vec.z());
    }

    // Nota: equals(), hashCode() e toString() sono generati automaticamente dal Record.
}


--------------------------------
FILE: Vector3Int.java
--------------------------------
package com.matterworks.core.common;

/**
 * Value Object semplice per le dimensioni (Width, Height, Depth).
 * Usato da IGridComponent.
 */
public record Vector3Int(int x, int y, int z) {
    public static Vector3Int one() { return new Vector3Int(1, 1, 1); }
}


--------------------------------
FILE: DatabaseManager.java
--------------------------------
package com.matterworks.core.database;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.sql.Connection;
import java.sql.SQLException;

public class DatabaseManager {

    private final HikariDataSource dataSource;

    public DatabaseManager(String jdbcUrl, String username, String password) {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(username);
        config.setPassword(password);

        // Ottimizzazioni per Gaming (Bassa latenza)
        config.setMaximumPoolSize(10);
        config.setMinimumIdle(2);
        config.setIdleTimeout(30000);
        config.setConnectionTimeout(2000); // Fail fast se il DB Ã¨ giÃ¹

        this.dataSource = new HikariDataSource(config);
    }

    public Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }

    public void close() {
        if (dataSource != null) {
            dataSource.close();
        }
    }
}


--------------------------------
FILE: UuidUtils.java
--------------------------------
package com.matterworks.core.database;

import java.nio.ByteBuffer;
import java.util.UUID;

public class UuidUtils {

    public static byte[] asBytes(UUID uuid) {
        if (uuid == null) return null;
        ByteBuffer bb = ByteBuffer.wrap(new byte[16]);
        bb.putLong(uuid.getMostSignificantBits());
        bb.putLong(uuid.getLeastSignificantBits());
        return bb.array();
    }

    public static UUID asUuid(byte[] bytes) {
        if (bytes == null || bytes.length != 16) return null;
        ByteBuffer bb = ByteBuffer.wrap(bytes);
        long firstLong = bb.getLong();
        long secondLong = bb.getLong();
        return new UUID(firstLong, secondLong);
    }
}


--------------------------------
FILE: MachineDefinitionDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.database.DatabaseManager;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

public class MachineDefinitionDAO {

    private final DatabaseManager db;
    private static final String SELECT_ALL = "SELECT type_id, width, height, depth FROM machine_definitions";

    public MachineDefinitionDAO(DatabaseManager db) {
        this.db = db;
    }

    public Map<String, Vector3Int> loadAllDefinitions() {
        Map<String, Vector3Int> defs = new HashMap<>();

        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(SELECT_ALL);
             ResultSet rs = ps.executeQuery()) {

            while (rs.next()) {
                String id = rs.getString("type_id");
                Vector3Int dim = new Vector3Int(
                        rs.getInt("width"),
                        rs.getInt("height"),
                        rs.getInt("depth")
                );
                defs.put(id, dim);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return defs;
    }
}


--------------------------------
FILE: PlayerDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils; // Importante
import com.matterworks.core.domain.player.PlayerProfile;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.UUID;

public class PlayerDAO {

    private final DatabaseManager db;

    // UUID Ã¨ BINARY(16) nel DB
    private static final String UPSERT_SQL = """
        INSERT INTO players (uuid, username, money) 
        VALUES (?, ?, ?)
        ON DUPLICATE KEY UPDATE 
            username = VALUES(username),
            money = VALUES(money),
            last_login = CURRENT_TIMESTAMP
    """;

    private static final String SELECT_SQL = "SELECT * FROM players WHERE uuid = ?";

    public PlayerDAO(DatabaseManager db) {
        this.db = db;
    }

    public void save(PlayerProfile p) {
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(UPSERT_SQL)) {

            // FIX: Usiamo setBytes invece di setString
            ps.setBytes(1, UuidUtils.asBytes(p.getPlayerId()));
            ps.setString(2, p.getUsername());
            ps.setDouble(3, p.getMoney());

            ps.executeUpdate();

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public PlayerProfile load(UUID uuid) {
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(SELECT_SQL)) {

            // FIX: Usiamo setBytes per la ricerca
            ps.setBytes(1, UuidUtils.asBytes(uuid));

            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    // FIX: Ricostruiamo l'UUID dai byte (anche se l'abbiamo giÃ  passato, Ã¨ buona pratica)
                    // In questo caso usiamo l'UUID passato per creare l'oggetto
                    PlayerProfile p = new PlayerProfile(uuid);
                    p.setUsername(rs.getString("username"));
                    p.setMoney(rs.getDouble("money"));
                    return p;
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }
}


--------------------------------
FILE: PlotDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils;
import com.matterworks.core.model.PlotObject;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class PlotDAO {

    private final DatabaseManager dbManager;

    public PlotDAO(DatabaseManager dbManager) {
        this.dbManager = dbManager;
    }

    // UPDATE: Ritorna Long
    public Long findPlotIdByOwner(UUID ownerId) {
        String sql = "SELECT id FROM plots WHERE owner_id = ?";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setBytes(1, UuidUtils.asBytes(ownerId));
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) return rs.getLong("id"); // getLong
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void createPlot(UUID ownerId, int x, int z, int worldId) {
        String sql = "INSERT INTO plots (owner_id, x, z, world_id, allocation_index, world_x, world_z, expansion_tier, is_active) VALUES (?, ?, ?, ?, 0, 0, 0, 0, 1)";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setBytes(1, UuidUtils.asBytes(ownerId));
            stmt.setInt(2, x);
            stmt.setInt(3, z);
            stmt.setInt(4, worldId);
            stmt.executeUpdate();
            System.out.println("âœ… Plot creato per " + ownerId);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public Long insertMachine(UUID ownerId, String typeId, int x, int y, int z, String metadataJson) {
        // UPDATE: Usa Long
        Long plotId = findPlotIdByOwner(ownerId);
        if (plotId == null) {
            System.err.println("âŒ Nessun plot trovato per salvare la macchina!");
            return null;
        }

        String sql = "INSERT INTO plot_machines (plot_id, type_id, x, y, z, metadata) VALUES (?, ?, ?, ?, ?, ?)";

        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, java.sql.Statement.RETURN_GENERATED_KEYS)) {

            stmt.setLong(1, plotId); // setLong
            stmt.setString(2, typeId);
            stmt.setInt(3, x);
            stmt.setInt(4, y);
            stmt.setInt(5, z);
            stmt.setString(6, metadataJson);

            int affected = stmt.executeUpdate();
            if (affected > 0) {
                try (ResultSet rs = stmt.getGeneratedKeys()) {
                    if (rs.next()) return rs.getLong(1);
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    public List<PlotObject> loadMachines(UUID ownerId) {
        List<PlotObject> machines = new ArrayList<>();
        String sql = "SELECT pm.id, pm.plot_id, pm.type_id, pm.x, pm.y, pm.z, pm.metadata FROM plot_machines pm JOIN plots p ON pm.plot_id = p.id WHERE p.owner_id = ?";

        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setBytes(1, UuidUtils.asBytes(ownerId));

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    String metaStr = rs.getString("metadata");
                    JsonObject metaJson = new JsonObject();
                    if (metaStr != null && !metaStr.isBlank()) {
                        try { metaJson = JsonParser.parseString(metaStr).getAsJsonObject(); }
                        catch (Exception ignored) {}
                    }
                    machines.add(new PlotObject(
                            rs.getLong("id"), rs.getLong("plot_id"),
                            rs.getInt("x"), rs.getInt("y"), rs.getInt("z"),
                            rs.getString("type_id"), metaJson
                    ));
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return machines;
    }

    public void removeMachine(Long dbId) {
        if (dbId == null) return;
        String sql = "DELETE FROM plot_machines WHERE id = ?";
        try (Connection conn = dbManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, dbId);
            stmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


--------------------------------
FILE: PlotObjectDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.model.PlotObject;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class PlotObjectDAO {

    private final DatabaseManager db;

    // --- FIX: USIAMO UPSERT INVECE DI INSERT ---
    // Se la combinazione (plot_id, x, y, z) esiste giÃ  (Unique Key),
    // aggiorniamo solo i metadati e il tipo, invece di dare errore.
    private static final String UPSERT_SQL = """
        INSERT INTO plot_objects (plot_id, x, y, z, type_id, meta_data)
        VALUES (?, ?, ?, ?, ?, ?)
        ON DUPLICATE KEY UPDATE 
            meta_data = VALUES(meta_data),
            type_id = VALUES(type_id)
    """;

    private static final String SELECT_SQL = "SELECT * FROM plot_objects WHERE plot_id = ?";
    private static final String DELETE_SQL = "DELETE FROM plot_objects WHERE id = ?";

    public PlotObjectDAO(DatabaseManager db) {
        this.db = db;
    }

    public void placeMachine(PlotObject obj) {
        // Usiamo Statement.RETURN_GENERATED_KEYS per ottenere l'ID se Ã¨ un nuovo inserimento
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(UPSERT_SQL, Statement.RETURN_GENERATED_KEYS)) {

            ps.setLong(1, obj.getPlotId());
            ps.setInt(2, obj.getX());
            ps.setInt(3, obj.getY());
            ps.setInt(4, obj.getZ());
            ps.setString(5, obj.getTypeId());
            // Gestione metadati sicura
            ps.setString(6, obj.getMetaData() != null ? obj.getMetaData().toString() : "{}");

            ps.executeUpdate();

            // Se Ã¨ stato un INSERT (nuova macchina), prendiamo l'ID.
            // Se Ã¨ stato un UPDATE, l'ID non cambia (lo abbiamo giÃ  in obj.id solitamente).
            try (ResultSet rs = ps.getGeneratedKeys()) {
                if (rs.next()) {
                    long newId = rs.getLong(1);
                    // Aggiorniamo l'ID solo se ne abbiamo ricevuto uno valido (cioÃ¨ era un insert)
                    if (newId > 0) {
                        obj.setId(newId);
                    }
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public List<PlotObject> loadPlotMachines(Long plotId) {
        List<PlotObject> machines = new ArrayList<>();
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(SELECT_SQL)) {

            ps.setLong(1, plotId);

            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    PlotObject obj = new PlotObject();
                    obj.setId(rs.getLong("id"));
                    obj.setPlotId(plotId);
                    obj.setX(rs.getInt("x"));
                    obj.setY(rs.getInt("y"));
                    obj.setZ(rs.getInt("z"));
                    obj.setTypeId(rs.getString("type_id"));

                    // Parsing JSON sicuro
                    String metaStr = rs.getString("meta_data");
                    if (metaStr != null) {
                        obj.setMetaDataFromString(metaStr);
                    }

                    machines.add(obj);
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return machines;
    }

    public void deleteMachine(Long dbId) {
        if (dbId == null) return;

        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(DELETE_SQL)) {

            ps.setLong(1, dbId);
            ps.executeUpdate();
            System.out.println("ðŸ—‘ï¸ DB: Cancellata riga ID " + dbId);

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


--------------------------------
FILE: PlotResourceDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.common.GridPosition;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.domain.matter.MatterColor;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

public class PlotResourceDAO {

    private final DatabaseManager db;

    public PlotResourceDAO(DatabaseManager db) {
        this.db = db;
    }

    // UPDATE: Long plotId
    public void addResource(Long plotId, int x, int z, MatterColor type) {
        String sql = "INSERT INTO plot_resources (plot_id, x, z, resource_type) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE resource_type = VALUES(resource_type)";

        try (Connection conn = db.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, plotId); // setLong
            stmt.setInt(2, x);
            stmt.setInt(3, z);
            stmt.setString(4, type.name());
            stmt.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // UPDATE: Long plotId
    public Map<GridPosition, MatterColor> loadResources(Long plotId) {
        Map<GridPosition, MatterColor> resources = new HashMap<>();
        String sql = "SELECT x, z, resource_type FROM plot_resources WHERE plot_id = ?";

        try (Connection conn = db.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setLong(1, plotId); // setLong

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    int x = rs.getInt("x");
                    int z = rs.getInt("z");
                    String typeStr = rs.getString("resource_type");

                    try {
                        MatterColor color = MatterColor.valueOf(typeStr);
                        resources.put(new GridPosition(x, 0, z), color);
                    } catch (IllegalArgumentException e) {
                        System.err.println("âš ï¸ Risorsa ignota nel DB: " + typeStr);
                    }
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return resources;
    }
}


--------------------------------
FILE: TransactionDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.UUID;

public class TransactionDAO {

    private final DatabaseManager db;

    private static final String INSERT_SQL = """
        INSERT INTO transactions (player_uuid, action_type, currency, amount, item_id, occurred_at)
        VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
    """;

    public TransactionDAO(DatabaseManager db) {
        this.db = db;
    }

    /**
     * Logga una transazione economica.
     * @param uuid Chi?
     * @param type Cosa ha fatto? (es. "MARKET_SELL", "TECH_BUY")
     * @param currency Valuta ("MONEY", "VOID_COINS")
     * @param amount Quanto? (Positivo = guadagno, Negativo = spesa)
     * @param itemId Opzionale (null se non rilevante)
     */
    public void logTransaction(UUID uuid, String type, String currency, BigDecimal amount, String itemId) {
        // Eseguiamo in un thread separato per non bloccare il gioco (Fire & Forget)
        // In un server vero useremmo un ExecutorService, qui per semplicitÃ  va bene cosÃ¬
        new Thread(() -> {
            try (Connection conn = db.getConnection();
                 PreparedStatement ps = conn.prepareStatement(INSERT_SQL)) {

                ps.setBytes(1, UuidUtils.asBytes(uuid));
                ps.setString(2, type);
                ps.setString(3, currency);
                ps.setBigDecimal(4, amount);
                ps.setString(5, itemId); // PuÃ² essere null

                ps.executeUpdate();

            } catch (SQLException e) {
                System.err.println("FAILED TO LOG TRANSACTION: " + e.getMessage());
                // Non crashare il gioco per un log fallito, ma stampalo
            }
        }).start();
    }
}


--------------------------------
FILE: VerificationCodeDAO.java
--------------------------------
package com.matterworks.core.database.dao;

import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.UuidUtils;
import com.matterworks.core.domain.player.LinkCode; // Importante: Usa il Dominio

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.UUID;

public class VerificationCodeDAO {

    private final DatabaseManager db;

    private static final String INSERT_CODE = """
        INSERT INTO verification_codes (code, player_uuid, expires_at)
        VALUES (?, ?, ?)
    """;

    public VerificationCodeDAO(DatabaseManager db) {
        this.db = db;
    }

    public void saveCode(UUID playerUuid, LinkCode linkCode) {
        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(INSERT_CODE)) {

            ps.setString(1, linkCode.code());
            ps.setBytes(2, UuidUtils.asBytes(playerUuid));
            // Convertiamo il long (millisecondi) in Timestamp SQL
            ps.setTimestamp(3, new Timestamp(linkCode.expirationTime()));

            ps.executeUpdate();

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}


--------------------------------
FILE: MachineFactory.java
--------------------------------
package com.matterworks.core.domain.factory;

import com.matterworks.core.common.GridPosition;
import com.matterworks.core.domain.machines.*;
import com.matterworks.core.model.PlotObject;

import java.util.UUID;

public class MachineFactory {

    public static PlacedMachine createFromModel(PlotObject model, UUID ownerId) {
        GridPosition pos = new GridPosition(model.getX(), model.getY(), model.getZ());

        return switch (model.getTypeId()) {
            case "drill_mk1" -> new DrillMachine(
                    model.getId(),
                    ownerId,
                    pos,
                    "drill_mk1",
                    model.getMetaData(),
                    1
            );

            case "conveyor_belt" -> new ConveyorBelt(
                    model.getId(),
                    ownerId,
                    pos,
                    "conveyor_belt",
                    model.getMetaData()
            );

            // NEW: Creazione Nexus
            case "nexus_core" -> new NexusMachine(
                    model.getId(),
                    ownerId,
                    pos,
                    "nexus_core",
                    model.getMetaData()
            );
            case "chromator" -> new Chromator(
                    model.getId(),
                    ownerId,
                    pos,
                    "chromator",
                    model.getMetaData()
            );
            case "color_mixer" -> new ColorMixer(model.getId(), ownerId, pos, "color_mixer", model.getMetaData());


            default -> {
                System.err.println("Unknown machine type: " + model.getTypeId());
                yield null;
            }
        };
    }
}


--------------------------------
FILE: MachineInventory.java
--------------------------------
package com.matterworks.core.domain.inventory;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.matterworks.core.domain.matter.MatterPayload;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class MachineInventory {

    // Classe interna per rappresentare uno Slot con quantitÃ 
    private static class InventorySlot {
        MatterPayload item;
        int count;

        InventorySlot(MatterPayload item, int count) {
            this.item = item;
            this.count = count;
        }
    }

    private final List<InventorySlot> slots;
    private final int slotCount;
    private final int MAX_STACK_SIZE = 64; // Limite stack per slot

    public MachineInventory(int slotCount) {
        this.slotCount = slotCount;
        this.slots = new ArrayList<>(slotCount);
        // Inizializza slot vuoti
        for (int i = 0; i < slotCount; i++) {
            slots.add(null);
        }
    }

    // --- GESTIONE SLOT (STACKING LOGIC) ---

    public MatterPayload getItemInSlot(int slotIndex) {
        if (slotIndex < 0 || slotIndex >= slots.size()) return null;
        InventorySlot slot = slots.get(slotIndex);
        return (slot != null) ? slot.item : null;
    }

    public int getCountInSlot(int slotIndex) {
        if (slotIndex < 0 || slotIndex >= slots.size()) return 0;
        InventorySlot slot = slots.get(slotIndex);
        return (slot != null) ? slot.count : 0;
    }

    /**
     * Tenta di inserire un item in uno slot specifico gestendo lo stacking.
     */
    public boolean insertIntoSlot(int slotIndex, MatterPayload newItem) {
        if (newItem == null) return false;

        // Assicuriamoci che la lista sia dimensionata
        while (slots.size() <= slotIndex) slots.add(null);

        InventorySlot currentSlot = slots.get(slotIndex);

        // CASO 1: Slot vuoto -> Crea nuovo stack
        if (currentSlot == null) {
            slots.set(slotIndex, new InventorySlot(newItem, 1));
            return true;
        }

        // CASO 2: Slot occupato -> Controlla se Ã¨ lo stesso item e se c'Ã¨ spazio
        if (isSameItem(currentSlot.item, newItem)) {
            if (currentSlot.count < MAX_STACK_SIZE) {
                currentSlot.count++;
                return true;
            }
        }

        // CASO 3: Item diverso o Stack pieno -> Rifiuta
        return false;
    }

    /**
     * Decrementa la quantitÃ  in uno slot (Consumo ricetta).
     */
    public void decreaseSlot(int slotIndex, int amount) {
        if (slotIndex < 0 || slotIndex >= slots.size()) return;

        InventorySlot slot = slots.get(slotIndex);
        if (slot != null) {
            slot.count -= amount;
            if (slot.count <= 0) {
                slots.set(slotIndex, null); // Slot svuotato
            }
        }
    }

    // --- METODI LEGACY (Per Belt/Drill che non usano slot specifici) ---

    public boolean insert(MatterPayload m) {
        // Cerca il primo slot valido (Vuoto o Stesso tipo con spazio)
        for (int i = 0; i < slots.size(); i++) {
            if (insertIntoSlot(i, m)) return true;
        }
        return false;
    }

    public MatterPayload extractFirst() {
        // Cerca il primo slot non vuoto e decrementa
        for (int i = 0; i < slots.size(); i++) {
            InventorySlot slot = slots.get(i);
            if (slot != null && slot.count > 0) {
                MatterPayload item = slot.item;
                decreaseSlot(i, 1);
                return item;
            }
        }
        return null;
    }

    public boolean isEmpty() {
        for (InventorySlot s : slots) if (s != null) return false;
        return true;
    }

    public int getCount() {
        // Ritorna la somma totale degli item
        int total = 0;
        for (InventorySlot s : slots) if (s != null) total += s.count;
        return total;
    }

    // --- HELPER ---

    private boolean isSameItem(MatterPayload a, MatterPayload b) {
        return a.color() == b.color() && a.shape() == b.shape();
        // Nota: Ignoriamo effetti per ora per semplicitÃ  di stacking
    }

    // --- SERIALIZZAZIONE (Aggiornata con COUNT) ---

    public JsonObject serialize() {
        JsonObject json = new JsonObject();
        json.addProperty("capacity", slotCount);

        JsonArray itemsArr = new JsonArray();
        for (InventorySlot slot : slots) {
            if (slot != null) {
                JsonObject slotJson = slot.item.serialize();
                slotJson.addProperty("count", slot.count); // Salviamo quanti ce ne sono
                itemsArr.add(slotJson);
            } else {
                itemsArr.add((JsonElement) null);
            }
        }
        json.add("items", itemsArr);
        return json;
    }

    public void loadState(JsonObject json) {
        if (json == null || !json.has("items")) return;

        slots.clear();
        for(int i=0; i<slotCount; i++) slots.add(null);

        JsonArray itemsArr = json.getAsJsonArray("items");
        for (int i = 0; i < itemsArr.size() && i < slotCount; i++) {
            JsonElement el = itemsArr.get(i);
            if (el.isJsonObject()) {
                JsonObject obj = el.getAsJsonObject();
                MatterPayload mp = MatterPayload.fromJson(obj);
                int count = obj.has("count") ? obj.get("count").getAsInt() : 1;
                slots.set(i, new InventorySlot(mp, count));
            }
        }
    }
}


--------------------------------
FILE: BlockRegistry.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.database.dao.MachineDefinitionDAO;
import com.matterworks.core.ports.IWorldAccess;

import java.util.HashMap;
import java.util.Map;

public class BlockRegistry {

    private final IWorldAccess worldAdapter;
    private final Map<String, Vector3Int> dimensionCache;
    private final MachineDefinitionDAO definitionDAO;

    // Ora richiede il DAO nel costruttore
    public BlockRegistry(IWorldAccess worldAdapter, MachineDefinitionDAO definitionDAO) {
        this.worldAdapter = worldAdapter;
        this.definitionDAO = definitionDAO;
        this.dimensionCache = new HashMap<>();
    }

    /**
     * Chiamato all'avvio del server.
     */
    public void loadFromDatabase() {
        System.out.println("ðŸ“ Caricamento dimensioni macchine dal DB...");
        Map<String, Vector3Int> dbDefs = definitionDAO.loadAllDefinitions();

        dbDefs.forEach((id, dim) -> {
            dimensionCache.put(id, dim);
            System.out.println("   -> " + id + ": " + dim);
        });
    }

    public Vector3Int getDimensions(String blockId) {
        if (dimensionCache.containsKey(blockId)) {
            return dimensionCache.get(blockId);
        }
        // Fallback su Hytale se non Ã¨ nel nostro DB
        Vector3Int dim = worldAdapter.fetchExternalBlockDimensions(blockId);
        dimensionCache.put(blockId, dim);
        return dim;
    }
}


--------------------------------
FILE: Chromator.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.matter.MatterPayload;

import java.util.UUID;

public class Chromator extends ProcessorMachine {

    public Chromator(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, pos, typeId, metadata);
        this.dimensions = new Vector3Int(2, 1, 1);
        if (inputBuffer.getItemInSlot(0) == null) inputBuffer.insertIntoSlot(0, null);
        if (inputBuffer.getItemInSlot(1) == null) inputBuffer.insertIntoSlot(1, null);
    }

    @Override
    public boolean insertItem(MatterPayload item, GridPosition fromPos) {
        if (fromPos == null) return false;
        int targetSlot = getSlotForPosition(fromPos);
        if (targetSlot == -1) return false;

        boolean isDye = (item.color() != MatterColor.RAW);
        if (targetSlot == 0 && isDye) return false;
        if (targetSlot == 1 && !isDye) return false;

        return insertIntoBuffer(targetSlot, item);
    }

    // --- FIX OUTPUT POSITION ---
    @Override
    protected GridPosition getOutputPosition() {
        int x = pos.x();
        int y = pos.y();
        int z = pos.z();

        // Restituisce il vicino del "Blocco Sinistro" rispetto alla faccia anteriore
        return switch (orientation) {
            // NORD: Fronte Ã¨ Z-min. Sinistra Ã¨ X (Ovest). Output deve essere a (x, z-1).
            case NORTH -> new GridPosition(x, y, z - 1);

            // SUD: Fronte Ã¨ Z-max. Sinistra Ã¨ X+1 (Est). Output deve essere a (x+1, z+1).
            case SOUTH -> new GridPosition(x + 1, y, z + 1);

            // EST: Fronte Ã¨ X-max. Sinistra Ã¨ Z (Nord). Output deve essere a (x+1, z).
            case EAST -> new GridPosition(x + 1, y, z);

            // OVEST: Fronte Ã¨ X-min. Sinistra Ã¨ Z+1 (Sud). Output deve essere a (x-1, z+1).
            case WEST -> new GridPosition(x - 1, y, z + 1);

            default -> pos;
        };
    }

    private int getSlotForPosition(GridPosition senderPos) {
        // ... (Stessa logica di prima) ...
        int x = pos.x(); int y = pos.y(); int z = pos.z();
        GridPosition slot0Pos = null, slot1Pos = null;
        switch (orientation) {
            case NORTH: slot0Pos = new GridPosition(x, y, z + 1); slot1Pos = new GridPosition(x + 1, y, z + 1); break;
            case SOUTH: slot0Pos = new GridPosition(x + 1, y, z - 1); slot1Pos = new GridPosition(x, y, z - 1); break;
            case EAST:  slot0Pos = new GridPosition(x - 1, y, z); slot1Pos = new GridPosition(x - 1, y, z + 1); break;
            case WEST:  slot0Pos = new GridPosition(x + 1, y, z + 1); slot1Pos = new GridPosition(x + 1, y, z); break;
            default: return -1;
        }
        if (senderPos.equals(slot0Pos)) return 0;
        if (senderPos.equals(slot1Pos)) return 1;
        return -1;
    }

    @Override
    public void tick(long currentTick) {
        super.tryEjectItem(currentTick);
        if (currentRecipe != null) {
            if (currentTick >= finishTick) completeProcessing();
            return;
        }
        if (outputBuffer.getCount() >= MAX_OUTPUT_STACK) return;

        int countShape = inputBuffer.getCountInSlot(0);
        int countDye = inputBuffer.getCountInSlot(1);

        if (countShape > 0 && countDye > 0) {
            MatterPayload inputShape = inputBuffer.getItemInSlot(0);
            MatterPayload inputDye = inputBuffer.getItemInSlot(1);
            inputBuffer.decreaseSlot(0, 1);
            inputBuffer.decreaseSlot(1, 1);
            MatterPayload result = new MatterPayload(inputShape.shape(), inputDye.color());
            this.currentRecipe = new com.matterworks.core.domain.matter.Recipe("chroma_op", java.util.List.of(inputShape, inputDye), result, 2.0f, 0);
            this.finishTick = currentTick + 40;
            saveState();
            System.out.println("ðŸŽ¨ Chromator: Mix " + inputShape.shape() + " + " + inputDye.color());
        }
    }
}


--------------------------------
FILE: ColorMixer.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.matter.MatterShape;

import java.util.UUID;

public class ColorMixer extends ProcessorMachine {

    public ColorMixer(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, pos, typeId, metadata);
        this.dimensions = new Vector3Int(2, 1, 1);
        if (inputBuffer.getItemInSlot(0) == null) inputBuffer.insertIntoSlot(0, null);
        if (inputBuffer.getItemInSlot(1) == null) inputBuffer.insertIntoSlot(1, null);
    }

    @Override
    public boolean insertItem(MatterPayload item, GridPosition fromPos) {
        if (fromPos == null) return false;
        if (item.color() == MatterColor.RAW) return false;

        int targetSlot = getSlotForPosition(fromPos);
        if (targetSlot == -1) return false;

        // FIX: Usa la costante MAX_INPUT_STACK (64)
        if (inputBuffer.getCountInSlot(targetSlot) >= MAX_INPUT_STACK) return false;

        return insertIntoBuffer(targetSlot, item);
    }

    @Override
    protected GridPosition getOutputPosition() {
        int x = pos.x();
        int y = pos.y();
        int z = pos.z();

        // Restituisce il vicino del "Blocco Sinistro" rispetto alla faccia anteriore
        return switch (orientation) {
            // NORD: Fronte Ã¨ Z-min. Sinistra Ã¨ X (Ovest). Output deve essere a (x, z-1).
            case NORTH -> new GridPosition(x, y, z - 1);

            // SUD: Fronte Ã¨ Z-max. Sinistra Ã¨ X+1 (Est). Output deve essere a (x+1, z+1).
            case SOUTH -> new GridPosition(x + 1, y, z + 1);

            // EST: Fronte Ã¨ X-max. Sinistra Ã¨ Z (Nord). Output deve essere a (x+1, z).
            case EAST -> new GridPosition(x + 1, y, z);

            // OVEST: Fronte Ã¨ X-min. Sinistra Ã¨ Z+1 (Sud). Output deve essere a (x-1, z+1).
            case WEST -> new GridPosition(x - 1, y, z + 1);

            default -> pos;
        };
    }

    private int getSlotForPosition(GridPosition senderPos) {
        int x = pos.x();
        int y = pos.y();
        int z = pos.z();
        GridPosition slot0Pos = null, slot1Pos = null;

        switch (orientation) {
            case NORTH: slot0Pos = new GridPosition(x, y, z + 1); slot1Pos = new GridPosition(x + 1, y, z + 1); break;
            case SOUTH: slot0Pos = new GridPosition(x + 1, y, z - 1); slot1Pos = new GridPosition(x, y, z - 1); break;
            case EAST:  slot0Pos = new GridPosition(x - 1, y, z); slot1Pos = new GridPosition(x - 1, y, z + 1); break;
            case WEST:  slot0Pos = new GridPosition(x + 1, y, z + 1); slot1Pos = new GridPosition(x + 1, y, z); break;
            default: return -1;
        }

        if (senderPos.equals(slot0Pos)) return 0;
        if (senderPos.equals(slot1Pos)) return 1;
        return -1;
    }

    @Override
    public void tick(long currentTick) {
        super.tryEjectItem(currentTick);
        if (currentRecipe != null) {
            if (currentTick >= finishTick) completeProcessing();
            return;
        }
        if (outputBuffer.getCount() >= MAX_OUTPUT_STACK) return;

        int count0 = inputBuffer.getCountInSlot(0);
        int count1 = inputBuffer.getCountInSlot(1);

        if (count0 > 0 && count1 > 0) {
            MatterPayload c1 = inputBuffer.getItemInSlot(0);
            MatterPayload c2 = inputBuffer.getItemInSlot(1);
            if (c1.color() == c2.color()) return;

            inputBuffer.decreaseSlot(0, 1);
            inputBuffer.decreaseSlot(1, 1);

            MatterColor mixed = MatterColor.mix(c1.color(), c2.color());
            MatterPayload result = new MatterPayload(MatterShape.SPHERE, mixed);
            this.currentRecipe = new com.matterworks.core.domain.matter.Recipe("mix_" + mixed.name(), java.util.List.of(c1, c2), result, 1.5f, 0);
            this.finishTick = currentTick + 30;
            saveState();
            System.out.println("ðŸŒ€ Mixer: Mixing " + c1.color() + " + " + c2.color() + " -> " + mixed);
        }
    }
}


--------------------------------
FILE: ConveyorBelt.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.matter.MatterPayload;

import java.util.UUID;

public class ConveyorBelt extends PlacedMachine {

    private MatterPayload currentItem;
    private long arrivalTick = -1;
    private static final int TRANSPORT_TIME = 20;

    public ConveyorBelt(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.dimensions = Vector3Int.one();

        if (this.metadata.has("currentItem")) {
            this.currentItem = MatterPayload.fromJson(this.metadata.getAsJsonObject("currentItem"));
            this.arrivalTick = 0;
        }
    }

    @Override
    public void tick(long currentTick) {
        if (currentItem == null) return;
        if (arrivalTick == -1) arrivalTick = currentTick + TRANSPORT_TIME;

        if (currentTick >= arrivalTick) {
            pushToNeighbor(currentTick);
        }
    }

    public boolean insertItem(MatterPayload item, long currentTick) {
        if (this.currentItem != null) return false;
        this.currentItem = item;
        this.arrivalTick = currentTick + TRANSPORT_TIME;
        this.metadata.add("currentItem", item.serialize());
        markDirty();
        return true;
    }

    private void pushToNeighbor(long currentTick) {
        if (gridManager == null) return;

        Vector3Int dirVec = orientation.toVector();
        GridPosition targetPos = new GridPosition(
                pos.x() + dirVec.x(),
                pos.y() + dirVec.y(),
                pos.z() + dirVec.z()
        );

        PlacedMachine neighbor = getNeighborAt(targetPos);
        boolean moved = false;

        if (neighbor instanceof ConveyorBelt nextBelt) {
            moved = nextBelt.insertItem(currentItem, currentTick);
        }
        else if (neighbor instanceof NexusMachine nexus) {
            // FIX CRUCIALE: Passiamo 'this.pos' (la posizione del nastro)
            // Il Nexus userÃ  questa coordinata per verificare se il nastro Ã¨ davanti a una porta valida.
            moved = nexus.insertItem(currentItem, this.pos);
        }
        else if (neighbor instanceof ProcessorMachine processor) {
            // Anche i processori ora richiedono la posizione di origine
            moved = processor.insertItem(currentItem, this.pos);
        }

        if (moved) {
            this.currentItem = null;
            this.arrivalTick = -1;
            this.metadata.remove("currentItem");
            markDirty();
        }
    }

    @Override
    public JsonObject serialize() {
        super.serialize();
        if (currentItem != null) this.metadata.add("currentItem", currentItem.serialize());
        else this.metadata.remove("currentItem");
        return this.metadata;
    }
}


--------------------------------
FILE: DrillMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.inventory.MachineInventory;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.matter.MatterShape;
import com.matterworks.core.infrastructure.CoreConfig;

import java.util.UUID;

public class DrillMachine extends PlacedMachine {

    private int tierLevel;
    private float productionSpeed;
    private long nextSpawnTick = -1;
    private final MachineInventory outputBuffer;

    private MatterColor resourceToMine = MatterColor.RAW;

    public DrillMachine(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata, int tierLevel) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.tierLevel = tierLevel;
        this.productionSpeed = tierLevel * 1.0f;
        this.dimensions = new Vector3Int(1, 2, 1);

        int capacity = CoreConfig.getInt("machine.inventory.capacity", 64);
        this.outputBuffer = new MachineInventory(capacity);

        // Caricamento Dati
        if (this.metadata != null) {
            if (this.metadata.has("items")) {
                this.outputBuffer.loadState(this.metadata);
            }
            if (this.metadata.has("mining_resource")) {
                try {
                    this.resourceToMine = MatterColor.valueOf(this.metadata.get("mining_resource").getAsString());
                } catch (Exception e) {
                    this.resourceToMine = MatterColor.RAW;
                }
            }
        }
    }

    public void setResourceToMine(MatterColor resource) {
        this.resourceToMine = resource;
        saveInternalState(); // Salva subito
    }

    @Override
    public void tick(long currentTick) {
        if (nextSpawnTick == -1) {
            nextSpawnTick = currentTick + (long)(20 / productionSpeed);
        }

        if (currentTick >= nextSpawnTick) {
            produceItem();
            nextSpawnTick = currentTick + (long)(20 / productionSpeed);
        }
        tryEjectItem(currentTick);
    }

    private void produceItem() {
        MatterShape shape = (this.resourceToMine == MatterColor.RAW) ? MatterShape.CUBE : null;
        MatterPayload newItem = new MatterPayload(shape, this.resourceToMine);

        if (outputBuffer.insert(newItem)) {
            saveInternalState(); // Usa il metodo sicuro
        }
    }

    private void tryEjectItem(long currentTick) {
        if (outputBuffer.isEmpty()) return;

        // FIX: Usa getNeighborAt per trovare il nastro del proprietario corretto
        // (Assumendo che tu abbia applicato la patch Multi-Tenant precedente)
        Vector3Int dir = orientation.toVector();
        GridPosition targetPos = new GridPosition(pos.x() + dir.x(), pos.y() + dir.y(), pos.z() + dir.z());

        // Se non hai ancora il metodo getNeighborAt nella classe padre, usa:
        // PlacedMachine neighbor = gridManager.getMachineAt(this.ownerId, targetPos);
        PlacedMachine neighbor = getNeighborAt(targetPos);

        if (neighbor instanceof ConveyorBelt belt) {
            MatterPayload item = outputBuffer.extractFirst();
            if (item != null) {
                if (belt.insertItem(item, currentTick)) {
                    saveInternalState(); // FIX: Usa il metodo sicuro invece di sovrascrivere
                } else {
                    outputBuffer.insert(item); // Rollback se il nastro Ã¨ pieno
                }
            }
        }
    }

    /**
     * Metodo centrale per aggiornare i metadati senza perdere pezzi.
     * Unisce lo stato dell'inventario con la configurazione della risorsa.
     */
    private void saveInternalState() {
        // 1. Ottieni il JSON dell'inventario
        JsonObject invState = outputBuffer.serialize();

        // 2. Fai il merge dentro this.metadata invece di sovrascriverlo brutalmente
        this.metadata.add("items", invState.get("items"));
        this.metadata.add("capacity", invState.get("capacity"));

        // 3. Assicura che la risorsa sia sempre salvata
        this.metadata.addProperty("mining_resource", resourceToMine.name());

        // 4. Marca per il salvataggio DB
        markDirty();
    }
}


--------------------------------
FILE: IGridComponent.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.ports.IWorldAccess;

/**
 * Interfaccia base per qualsiasi oggetto piazzabile sulla griglia.
 *
 */
public interface IGridComponent {
    void onPlace(IWorldAccess world);
    void onRemove();
    JsonObject serialize();
    Vector3Int getDimensions();
}


--------------------------------
FILE: NexusMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.inventory.MachineInventory;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.shop.MarketManager;

import java.util.UUID;

public class NexusMachine extends PlacedMachine {

    private final MachineInventory storage;
    private long nextSaleTick = -1;
    private static final int SALE_INTERVAL = 10;

    public NexusMachine(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.dimensions = new Vector3Int(3, 3, 3);
        this.storage = new MachineInventory(100);

        if (this.metadata.has("items")) {
            this.storage.loadState(this.metadata);
        }
    }

    @Override
    public void tick(long currentTick) {
        if (storage.isEmpty()) return;
        if (nextSaleTick == -1) nextSaleTick = currentTick + SALE_INTERVAL;

        if (currentTick >= nextSaleTick) {
            sellNextItem();
            nextSaleTick = currentTick + SALE_INTERVAL;
        }
    }

    /**
     * Metodo legacy (non dovrebbe essere usato dai nastri, ma per sicurezza)
     */
    public boolean insertItem(MatterPayload item) {
        return false; // Il Nexus ora richiede una posizione di origine!
    }

    /**
     * NUOVO: Inserimento con validazione geometrica rigorosa.
     */
    public boolean insertItem(MatterPayload item, GridPosition fromPos) {
        if (item.shape() == null) return false; // Rifiuta liquidi/dye
        if (fromPos == null) return false;

        // Validazione Porta: Deve entrare da una delle 6 porte centrali
        if (!isValidInputPort(fromPos)) {
            return false;
        }

        boolean success = storage.insert(item);
        if (success) {
            this.metadata = storage.serialize();
            markDirty();
        }
        return success;
    }

    private boolean isValidInputPort(GridPosition from) {
        int x = pos.x();
        int y = pos.y();
        int z = pos.z();

        // Coordinate relative (delta)
        int dx = from.x() - x;
        int dy = from.y() - y;
        int dz = from.z() - z;

        // Il Nexus accetta input solo ai livelli Y=0 e Y=1 (relativi alla base)
        if (dy < 0 || dy > 1) return false;

        // Logica Porte Centrali (Il Nexus Ã¨ 3x3, centro Ã¨ offset 1)
        // Nord (z-1) -> Entra in (1, y, 0) -> Delta da origine: x=1, z=-1
        if (dx == 1 && dz == -1) return true;
        // Sud (z+3) -> Entra in (1, y, 2) -> Delta da origine: x=1, z=3
        if (dx == 1 && dz == 3) return true;
        // Ovest (x-1) -> Entra in (0, y, 1) -> Delta da origine: x=-1, z=1
        if (dx == -1 && dz == 1) return true;
        // Est (x+3) -> Entra in (2, y, 1) -> Delta da origine: x=3, z=1
        if (dx == 3 && dz == 1) return true;

        return false;
    }

    private void sellNextItem() {
        if (gridManager == null) return;
        MarketManager market = gridManager.getMarketManager();
        if (market == null) return;

        MatterPayload itemToSell = storage.extractFirst();
        if (itemToSell != null) {
            market.sellItem(itemToSell, this.getOwnerId());
            this.metadata = storage.serialize();
            markDirty();
        }
    }
}


--------------------------------
FILE: PlacedMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.Direction;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.managers.GridManager;
import com.matterworks.core.ports.IWorldAccess;

import java.util.UUID;

public abstract class PlacedMachine implements IGridComponent {

    protected Long dbId;
    protected UUID ownerId;
    protected String typeId;
    protected GridPosition pos;
    protected Direction orientation;
    protected Vector3Int dimensions;
    protected JsonObject metadata;
    protected GridManager gridManager;
    protected boolean isDirty = false;

    public PlacedMachine(Long dbId, UUID ownerId, String typeId, GridPosition pos, JsonObject metadata) {
        this.dbId = dbId;
        this.ownerId = ownerId;
        this.typeId = typeId;
        this.pos = pos;
        this.metadata = metadata != null ? metadata : new JsonObject();

        this.orientation = Direction.NORTH;
        if (this.metadata.has("orientation")) {
            this.orientation = Direction.valueOf(this.metadata.get("orientation").getAsString());
        }

        this.dimensions = new Vector3Int(1, 1, 1);
    }

    @Override
    public Vector3Int getDimensions() {
        if (orientation == Direction.EAST || orientation == Direction.WEST) {
            return new Vector3Int(dimensions.z(), dimensions.y(), dimensions.x());
        }
        return dimensions;
    }

    // --- NUOVO METODO HELPER PER I VICINI ---
    protected PlacedMachine getNeighborAt(GridPosition targetPos) {
        if (gridManager == null) return null;
        // Chiede al GM la macchina in quella posizione MA nello stesso universo (ownerId)
        return gridManager.getMachineAt(this.ownerId, targetPos);
    }

    public void setOrientation(Direction orientation) {
        this.orientation = orientation;
        this.metadata.addProperty("orientation", orientation.name());
        markDirty();
    }
    public Direction getNeighborDirection(GridPosition neighborPos) {
        int dx = neighborPos.x() - this.pos.x();
        int dy = neighborPos.y() - this.pos.y();
        int dz = neighborPos.z() - this.pos.z();

        if (dx == 1) return Direction.EAST;
        if (dx == -1) return Direction.WEST;
        if (dz == 1) return Direction.SOUTH;
        if (dz == -1) return Direction.NORTH;
        if (dy == 1) return Direction.UP;
        if (dy == -1) return Direction.DOWN;

        return null; // Non adiacente
    }

    public UUID getOwnerId() { return ownerId; }
    public void cleanDirty() { this.isDirty = false; }

    public GridPosition getPos() { return pos; }
    public String getTypeId() { return typeId; }
    public Direction getOrientation() { return orientation; }

    public Long getDbId() { return dbId; }
    public void setDbId(Long id) { this.dbId = id; }

    public void setGridContext(GridManager gm) { this.gridManager = gm; }

    public void markDirty() { this.isDirty = true; }
    public boolean isDirty() { return isDirty; }

    public abstract void tick(long currentTick);

    public void onPlace(IWorldAccess world) {}
    public void onRemove() {}

    public JsonObject serialize() {
        metadata.addProperty("orientation", orientation.name());
        return metadata;
    }
}


--------------------------------
FILE: ProcessorMachine.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.inventory.MachineInventory;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.matter.Recipe;

import java.util.UUID;

public abstract class ProcessorMachine extends PlacedMachine {

    protected final MachineInventory inputBuffer;
    protected final MachineInventory outputBuffer;
    protected Recipe currentRecipe;
    protected long finishTick = -1;

    protected static final int MAX_INPUT_STACK = 64;
    protected static final int MAX_OUTPUT_STACK = 64;

    public ProcessorMachine(Long dbId, UUID ownerId, GridPosition pos, String typeId, JsonObject metadata) {
        super(dbId, ownerId, typeId, pos, metadata);
        this.inputBuffer = new MachineInventory(2);
        this.outputBuffer = new MachineInventory(1);

        if (this.metadata.has("input")) this.inputBuffer.loadState(this.metadata.getAsJsonObject("input"));
        if (this.metadata.has("output")) this.outputBuffer.loadState(this.metadata.getAsJsonObject("output"));
    }

    @Override
    public void tick(long currentTick) {
        tryEjectItem(currentTick);
        processRecipe(currentTick);
    }

    public boolean insertItem(MatterPayload item) { return false; }
    public abstract boolean insertItem(MatterPayload item, GridPosition fromPos);

    // NUOVO METODO ASTRATTO: Ogni macchina deve dire esattamente DOVE sputa l'output
    protected abstract GridPosition getOutputPosition();

    protected boolean insertIntoBuffer(int slotIndex, MatterPayload item) {
        if (inputBuffer.getCountInSlot(slotIndex) >= MAX_INPUT_STACK) return false;
        if (inputBuffer.insertIntoSlot(slotIndex, item)) {
            saveState();
            return true;
        }
        return false;
    }

    protected void processRecipe(long currentTick) {
        if (outputBuffer.getCount() >= MAX_OUTPUT_STACK) return;
        if (currentRecipe != null) {
            if (currentTick >= finishTick) completeProcessing();
        }
    }

    protected void completeProcessing() {
        if (outputBuffer.insert(currentRecipe.output())) {
            System.out.println(typeId + " -> FINITO: Creato " + currentRecipe.output().color());
            this.currentRecipe = null;
            this.finishTick = -1;
            saveState();
        }
    }

    protected void tryEjectItem(long currentTick) {
        if (outputBuffer.isEmpty()) return;
        if (gridManager == null) return;

        // FIX: Usa la posizione specifica calcolata dalla sottoclasse
        GridPosition targetPos = getOutputPosition();
        if (targetPos == null) return;

        PlacedMachine neighbor = getNeighborAt(targetPos);

        if (neighbor instanceof ConveyorBelt belt) {
            MatterPayload item = outputBuffer.extractFirst();
            if (item != null) {
                // Passiamo 'this.pos' (o meglio, la posizione precisa dell'output sarebbe ideale, ma this.pos va bene per ora)
                if (belt.insertItem(item, currentTick)) saveState();
                else outputBuffer.insert(item);
            }
        } else if (neighbor instanceof NexusMachine nexus) {
            MatterPayload item = outputBuffer.extractFirst();
            if (item != null) {
                // Nexus requires strict fromPos checking now.
                // We pass the output position as the "source"
                GridPosition outputSource = getOutputPosition().add(orientation.opposite().toVector());
                if (nexus.insertItem(item, outputSource)) saveState();
                else outputBuffer.insert(item);
            }
        }
    }

    protected void saveState() {
        this.metadata.add("input", inputBuffer.serialize());
        this.metadata.add("output", outputBuffer.serialize());
        markDirty();
    }
}


--------------------------------
FILE: StructuralBlock.java
--------------------------------
package com.matterworks.core.domain.machines;

import com.google.gson.JsonObject;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.ports.IWorldAccess;

/**
 * Rappresenta un blocco statico o strutturale (Muri, Decorazioni).
 * Occupa spazio nella griglia ma non ha logica di tick complessa.
 *
 */
public class StructuralBlock implements IGridComponent {

    private final String blockId;
    private final Vector3Int cachedDimensions;

    public StructuralBlock(String blockId, Vector3Int dimensions) {
        this.blockId = blockId;
        this.cachedDimensions = dimensions;
    }

    @Override
    public void onPlace(IWorldAccess world) {
        // Logica semplice: piazza il blocco visivo nel mondo
        // (La posizione viene gestita dal GridManager al momento del piazzamento)
    }

    @Override
    public void onRemove() {
        // Nessuna pulizia speciale necessaria per blocchi stupidi
    }

    @Override
    public JsonObject serialize() {
        // I blocchi strutturali potrebbero non aver bisogno di salvare metadati complessi
        // o salvano solo il loro ID se necessario.
        JsonObject json = new JsonObject();
        json.addProperty("type", "structure");
        json.addProperty("blockId", blockId);
        return json;
    }

    @Override
    public Vector3Int getDimensions() {
        return cachedDimensions;
    }

    public String getBlockId() { return blockId; }
}


--------------------------------
FILE: MatterColor.java
--------------------------------
package com.matterworks.core.domain.matter;

import java.util.Set;

public enum MatterColor {
    RAW,
    RED,
    BLUE,
    YELLOW,
    GREEN,
    ORANGE,
    PURPLE,
    WHITE;

    /**
     * Logica di miscelazione colori additiva (RYB standard da gioco).
     */
    public static MatterColor mix(MatterColor c1, MatterColor c2) {
        if (c1 == c2) return c1; // Rosso + Rosso = Rosso

        // Ordiniamo i colori per semplificare i check (usando Set o confronto stringhe)
        if (isMix(c1, c2, RED, YELLOW)) return ORANGE;
        if (isMix(c1, c2, YELLOW, BLUE)) return GREEN;
        if (isMix(c1, c2, RED, BLUE)) return PURPLE;

        // Fallback: se mischio cose strane (es. Viola + Verde) diventa RAW o GRIGIO SCURO
        return RAW;
    }

    private static boolean isMix(MatterColor in1, MatterColor in2, MatterColor target1, MatterColor target2) {
        return (in1 == target1 && in2 == target2) || (in1 == target2 && in2 == target1);
    }
}


--------------------------------
FILE: MatterEffect.java
--------------------------------
package com.matterworks.core.domain.matter;

public enum MatterEffect {
    SHINY,
    BLAZING,
    GLITCH,
    RADIOACTIVE
}


--------------------------------
FILE: MatterPayload.java
--------------------------------
package com.matterworks.core.domain.matter;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public record MatterPayload(
        MatterShape shape,
        MatterColor color,
        List<MatterEffect> effects
) {

    public MatterPayload(MatterShape shape, MatterColor color) {
        this(shape, color, Collections.emptyList());
    }

    public JsonObject serialize() {
        JsonObject json = new JsonObject();

        // --- FIX NPE: Controllo null su shape ---
        if (shape != null) {
            json.addProperty("shape", shape.name());
        } else {
            // Se shape Ã¨ null (liquido), non scriviamo nulla o scriviamo null esplicito
            // Gson gestisce l'assenza come null al deserializing solitamente.
        }

        // Colore Ã¨ sempre presente (anche se RAW)
        if (color != null) {
            json.addProperty("color", color.name());
        }

        if (!effects.isEmpty()) {
            JsonArray effectsJson = new JsonArray();
            effects.forEach(e -> effectsJson.add(e.name()));
            json.add("effects", effectsJson);
        }
        return json;
    }

    public boolean isComplex() { return !effects.isEmpty(); }

    // --- FIX DESERIALIZZAZIONE: Supporto shape null ---
    public static MatterPayload fromJson(JsonObject json) {
        try {
            // 1. Gestione Shape Opzionale
            MatterShape s = null;
            if (json.has("shape") && !json.get("shape").isJsonNull()) {
                s = MatterShape.valueOf(json.get("shape").getAsString());
            }

            // 2. Gestione Colore
            MatterColor c = MatterColor.RAW; // Default fallback
            if (json.has("color")) {
                c = MatterColor.valueOf(json.get("color").getAsString());
            }

            // 3. Gestione Effetti
            List<MatterEffect> effs = new ArrayList<>();
            if (json.has("effects")) {
                JsonArray arr = json.getAsJsonArray("effects");
                arr.forEach(el -> effs.add(MatterEffect.valueOf(el.getAsString())));
            }

            return new MatterPayload(s, c, effs);

        } catch (Exception e) {
            System.err.println("Errore parsing payload: " + e.getMessage());
            // In caso di errore grave, ritorniamo un cubo raw per non crashare il server
            return new MatterPayload(MatterShape.CUBE, MatterColor.RAW);
        }
    }
}


--------------------------------
FILE: MatterShape.java
--------------------------------
package com.matterworks.core.domain.matter;

public enum MatterShape {
    CUBE,
    SPHERE,
    PYRAMID,
    CYLINDER
}


--------------------------------
FILE: Recipe.java
--------------------------------
package com.matterworks.core.domain.matter;

import java.util.List;

public record Recipe(
        String id,
        List<MatterPayload> inputs, // Cosa serve (es. 1 Cubo RAW)
        MatterPayload output,       // Cosa esce (es. 1 Cubo ROSSO)
        float processTimeSeconds,   // Quanto ci mette (es. 2.0s)
        int requiredTechId          // Per sblocchi futuri (0 = base)
) {}


--------------------------------
FILE: RecipeRegistry.java
--------------------------------
package com.matterworks.core.domain.matter;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

public class RecipeRegistry {

    private static final List<Recipe> recipes = new ArrayList<>();

    static {
        // --- DEFINIZIONE RICETTE INIZIALI ---

        // Ricetta: Dipingi di Rosso
        // Input: CUBE RAW -> Output: CUBE RED
        recipes.add(new Recipe(
                "paint_red",
                List.of(new MatterPayload(MatterShape.CUBE, MatterColor.RAW)),
                new MatterPayload(MatterShape.CUBE, MatterColor.RED),
                2.0f, // 2 secondi
                0
        ));
    }

    public static Optional<Recipe> findMatchingRecipe(List<MatterPayload> inputs) {
        // Logica semplificata: Cerca la prima ricetta che corrisponde al primo item dell'input
        // In futuro servirÃ  un matching piÃ¹ complesso per input multipli (Mixer)
        if (inputs.isEmpty()) return Optional.empty();

        MatterPayload firstInput = inputs.get(0);

        return recipes.stream()
                .filter(r -> !r.inputs().isEmpty())
                .filter(r -> isMatch(r.inputs().get(0), firstInput))
                .findFirst();
    }

    private static boolean isMatch(MatterPayload required, MatterPayload actual) {
        return required.shape() == actual.shape() && required.color() == actual.color();
    }
}


--------------------------------
FILE: LinkCode.java
--------------------------------
package com.matterworks.core.domain.player;

public record LinkCode(String code, long expirationTime) {
    public boolean isValid() {
        return System.currentTimeMillis() < expirationTime;
    }
}


--------------------------------
FILE: PlayerProfile.java
--------------------------------
package com.matterworks.core.domain.player;

import java.util.UUID;

public class PlayerProfile {

    private final UUID playerId;
    private String username;

    // CAMPO MONEY
    private double money;

    public PlayerProfile(UUID playerId) {
        this.playerId = playerId;
        this.money = 0.0; // Default
    }

    public UUID getPlayerId() {
        return playerId;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    // --- GESTIONE SOLDI ---

    public double getMoney() {
        return money;
    }

    public void setMoney(double money) {
        this.money = money;
    }

    /**
     * Modifica il saldo (positivo per aggiungere, negativo per togliere).
     * @param amount QuantitÃ  da aggiungere/togliere.
     */
    public void modifyMoney(double amount) {
        this.money += amount;
    }
}


--------------------------------
FILE: MarketManager.java
--------------------------------
package com.matterworks.core.domain.shop;

import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.matter.MatterPayload;
import com.matterworks.core.domain.matter.MatterShape;
import com.matterworks.core.domain.player.PlayerProfile;
import com.matterworks.core.ports.IRepository;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class MarketManager {

    private final IRepository repository;
    private final Map<MatterColor, Double> basePrices;

    public MarketManager(IRepository repository) {
        this.repository = repository;
        this.basePrices = new HashMap<>();
        initializePrices();
    }

    private void initializePrices() {
        // Prezzi Base per Colore
        basePrices.put(MatterColor.RAW, 1.0);

        // Colori Primari (Lavorati)
        basePrices.put(MatterColor.RED, 5.0);
        basePrices.put(MatterColor.BLUE, 5.0);
        basePrices.put(MatterColor.YELLOW, 5.0);

        // Colori Secondari (Mixati - Valgono molto di piÃ¹)
        basePrices.put(MatterColor.PURPLE, 25.0);
        basePrices.put(MatterColor.ORANGE, 25.0);
        basePrices.put(MatterColor.GREEN, 25.0);

        // Colore Finale
        basePrices.put(MatterColor.WHITE, 100.0);
    }

    public void sellItem(MatterPayload item, UUID sellerId) {
        if (item == null) return;

        double value = calculateValue(item);

        // Carichiamo il profilo, aggiorniamo i soldi e salviamo subito
        PlayerProfile player = repository.loadPlayerProfile(sellerId);

        if (player != null) {
            player.modifyMoney(value);
            repository.savePlayerProfile(player);

            System.out.println("ðŸ’° MARKET: Venduto " + item.shape() + " (" + item.color() + ") per $" + String.format("%.2f", value));
            System.out.println("   [Saldo Attuale: $" + String.format("%.2f", player.getMoney()) + "]");
        } else {
            System.err.println("âŒ MARKET: Errore critico - Player non trovato " + sellerId);
        }
    }

    private double calculateValue(MatterPayload item) {
        // 1. Prezzo base del colore
        double base = basePrices.getOrDefault(item.color(), 0.5);

        // 2. Moltiplicatore forma (complessitÃ )
        double multiplier = 1.0;
        if (item.shape() == MatterShape.SPHERE) multiplier = 1.5;   // Liquidi/Sfere valgono di piÃ¹
        if (item.shape() == MatterShape.PYRAMID) multiplier = 2.0;  // Cristalli
        if (item.isComplex()) multiplier *= 1.2;                    // Bonus effetti (shiny, etc.)

        return base * multiplier;
    }
}


--------------------------------
FILE: CoreConfig.java
--------------------------------
package com.matterworks.core.infrastructure;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

/**
 * Gestore della configurazione esterna.
 * Legge il file 'matterworks.properties' dalla root del server.
 * Permette di cambiare i valori di gioco senza ricompilare.
 */
public class CoreConfig {

    private static final Properties props = new Properties();

    // Carica il file all'avvio
    public static void load() {
        try (FileInputStream in = new FileInputStream("matterworks.properties")) {
            props.load(in);
            System.out.println("âš™ï¸ Configurazione caricata da matterworks.properties");
        } catch (IOException e) {
            System.out.println("âš ï¸ matterworks.properties non trovato. Uso valori di DEFAULT.");
        }
    }

    /**
     * Recupera un intero dalla config, o usa il default se manca.
     */
    public static int getInt(String key, int defaultValue) {
        String val = props.getProperty(key);
        if (val == null) return defaultValue;
        try {
            return Integer.parseInt(val);
        } catch (NumberFormatException e) {
            System.err.println("âŒ Errore config per " + key + ": " + val + " non Ã¨ un numero.");
            return defaultValue;
        }
    }
}


--------------------------------
FILE: MariaDBAdapter.java
--------------------------------
package com.matterworks.core.infrastructure;

import com.matterworks.core.common.GridPosition;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.database.dao.PlayerDAO;
import com.matterworks.core.database.dao.PlotDAO;
import com.matterworks.core.database.dao.PlotResourceDAO;
import com.matterworks.core.domain.machines.PlacedMachine;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.player.PlayerProfile;
import com.matterworks.core.model.PlotObject;
import com.matterworks.core.ports.IRepository;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.UUID;

public class MariaDBAdapter implements IRepository {

    private final DatabaseManager dbManager;
    private final PlayerDAO playerDAO;
    private final PlotDAO plotDAO;
    private final PlotResourceDAO resourceDAO;

    public MariaDBAdapter(DatabaseManager dbManager) {
        this.dbManager = dbManager;
        this.playerDAO = new PlayerDAO(dbManager);
        this.plotDAO = new PlotDAO(dbManager);
        this.resourceDAO = new PlotResourceDAO(dbManager);
    }

    // --- NUOVO METODO: RESET TOTALE ---
    public void clearPlotData(UUID ownerId) {
        Long plotId = plotDAO.findPlotIdByOwner(ownerId);
        if (plotId == null) return;

        try (Connection conn = dbManager.getConnection()) {
            // 1. Cancella tutte le macchine
            try (PreparedStatement stmt = conn.prepareStatement("DELETE FROM plot_machines WHERE plot_id = ?")) {
                stmt.setLong(1, plotId);
                stmt.executeUpdate();
            }
            // 2. Cancella tutte le risorse (cosÃ¬ al riavvio vengono rigenerate)
            try (PreparedStatement stmt = conn.prepareStatement("DELETE FROM plot_resources WHERE plot_id = ?")) {
                stmt.setLong(1, plotId);
                stmt.executeUpdate();
            }
            System.out.println("ðŸ”¥ WIPE COMPLETO per Plot ID " + plotId);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // ... (Il resto dei metodi rimane invariato: getPlotId, saveResource, loadResources, loadPlotMachines, etc.) ...

    public Long getPlotId(UUID ownerId) { return plotDAO.findPlotIdByOwner(ownerId); }
    public void saveResource(Long plotId, int x, int z, MatterColor type) { resourceDAO.addResource(plotId, x, z, type); }
    public Map<GridPosition, MatterColor> loadResources(Long plotId) { return resourceDAO.loadResources(plotId); }
    @Override public PlayerProfile loadPlayerProfile(UUID uuid) { return playerDAO.load(uuid); }
    @Override public void savePlayerProfile(PlayerProfile profile) { playerDAO.save(profile); }
    @Override public List<PlotObject> loadPlotMachines(UUID ownerId) { return plotDAO.loadMachines(ownerId); }
    @Override public Long createMachine(UUID ownerId, PlacedMachine machine) {
        String jsonMeta = machine.serialize().toString();
        return plotDAO.insertMachine(ownerId, machine.getTypeId(), machine.getPos().x(), machine.getPos().y(), machine.getPos().z(), jsonMeta);
    }
    @Override public void deleteMachine(Long dbId) { plotDAO.removeMachine(dbId); }
    @Override public void updateMachinesMetadata(List<PlacedMachine> machines) {
        if (machines == null || machines.isEmpty()) return;
        String sql = "UPDATE plot_machines SET metadata = ? WHERE id = ?";
        try (Connection conn = dbManager.getConnection(); PreparedStatement stmt = conn.prepareStatement(sql)) {
            for (PlacedMachine pm : machines) {
                if (pm.getDbId() == null) continue;
                stmt.setString(1, pm.serialize().toString());
                stmt.setLong(2, pm.getDbId());
                stmt.addBatch();
            }
            stmt.executeBatch();
        } catch (SQLException e) { e.printStackTrace(); }
    }
}


--------------------------------
FILE: FactoryPanel.java
--------------------------------
package com.matterworks.core.infrastructure.swing;

import com.google.gson.JsonObject;
import com.matterworks.core.common.Direction;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.machines.BlockRegistry;
import com.matterworks.core.domain.machines.ConveyorBelt;
import com.matterworks.core.domain.machines.NexusMachine;
import com.matterworks.core.domain.machines.PlacedMachine;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.managers.GridManager;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Map;
import java.util.UUID;

public class FactoryPanel extends JPanel {

    private final GridManager gridManager;
    private final BlockRegistry registry;
    private final UUID playerUuid;

    private final int CELL_SIZE = 40;
    private final int OFFSET_X = 50;
    private final int OFFSET_Y = 50;

    private String currentTool = "drill_mk1";
    private Direction currentOrientation = Direction.NORTH;
    private int currentLayer = 0;

    private GridPosition mouseHoverPos = null;
    private Runnable onStateChange;

    public FactoryPanel(GridManager gridManager, BlockRegistry registry, UUID playerUuid, Runnable onStateChange) {
        this.gridManager = gridManager;
        this.registry = registry;
        this.playerUuid = playerUuid;
        this.onStateChange = onStateChange;
        this.setBackground(new Color(30, 30, 30));
        this.setFocusable(true);

        this.addMouseMotionListener(new MouseMotionAdapter() {
            @Override
            public void mouseMoved(MouseEvent e) {
                updateMousePos(e.getX(), e.getY());
                repaint();
            }
        });
        this.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                requestFocusInWindow();
                handleMouseClick(e);
                repaint();
            }
        });
        this.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                if (e.getKeyCode() == KeyEvent.VK_R) rotate();
            }
        });
    }

    public void setLayer(int y) { this.currentLayer = y; repaint(); }
    public int getCurrentLayer() { return currentLayer; }
    public void setTool(String toolId) { this.currentTool = toolId; repaint(); }
    public String getCurrentToolName() { return currentTool != null ? currentTool : "None"; }

    public void rotate() {
        switch(currentOrientation) {
            case NORTH -> currentOrientation = Direction.EAST;
            case EAST -> currentOrientation = Direction.SOUTH;
            case SOUTH -> currentOrientation = Direction.WEST;
            case WEST -> currentOrientation = Direction.NORTH;
        }
        if (onStateChange != null) onStateChange.run();
        repaint();
    }
    public String getCurrentOrientationName() { return currentOrientation.name(); }

    private void updateMousePos(int x, int y) {
        int gx = toGridX(x);
        int gz = toGridY(y);
        if (gx >= 0 && gx <= 20 && gz >= 0 && gz <= 20) {
            this.mouseHoverPos = new GridPosition(gx, currentLayer, gz);
        } else {
            this.mouseHoverPos = null;
        }
    }

    private void handleMouseClick(MouseEvent e) {
        if (mouseHoverPos == null) return;
        if (SwingUtilities.isLeftMouseButton(e)) {
            if (currentTool != null) {
                gridManager.placeMachine(playerUuid, mouseHoverPos, currentTool, currentOrientation);
            }
        } else if (SwingUtilities.isRightMouseButton(e)) {
            gridManager.removeComponent(playerUuid, mouseHoverPos);
        }
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        if (currentLayer == 0) drawTerrainResources(g2);
        drawGrid(g2);
        drawMachines(g2);
        drawGhost(g2);
    }

    private void drawTerrainResources(Graphics2D g) {
        Map<GridPosition, MatterColor> resources = gridManager.getTerrainResources(playerUuid);
        for (Map.Entry<GridPosition, MatterColor> entry : resources.entrySet()) {
            GridPosition pos = entry.getKey();
            MatterColor type = entry.getValue();
            int x = toScreenX(pos.x());
            int z = toScreenY(pos.z());

            Color c = switch(type) {
                case RAW -> new Color(100, 100, 100, 100);
                case RED -> new Color(200, 0, 0, 100);
                case BLUE -> new Color(0, 0, 200, 100);
                case YELLOW -> new Color(200, 200, 0, 100);
                default -> new Color(255, 255, 255, 50);
            };
            g.setColor(c);
            g.fillRect(x, z, CELL_SIZE, CELL_SIZE);
            g.setColor(c.darker());
            g.drawRect(x, z, CELL_SIZE, CELL_SIZE);
            g.setColor(Color.WHITE);
            g.setFont(new Font("SansSerif", Font.PLAIN, 9));
            g.drawString(type.name(), x + 2, z + 12);
        }
    }

    private void drawGrid(Graphics2D g) {
        g.setColor(new Color(50, 50, 50));
        for (int i = 0; i <= 20; i++) {
            g.drawLine(toScreenX(i), toScreenY(0), toScreenX(i), toScreenY(20));
            g.drawLine(toScreenX(0), toScreenY(i), toScreenX(20), toScreenY(i));
        }
        g.setColor(new Color(60, 60, 60));
        g.drawString("LAYER Y = " + currentLayer, 10, getHeight() - 10);
    }

    private void drawMachines(Graphics2D g) {
        Map<GridPosition, PlacedMachine> machines = gridManager.getSnapshot(playerUuid);
        for (PlacedMachine m : machines.values()) {
            int machineY = m.getPos().y();
            int machineHeight = m.getDimensions().y();
            if (currentLayer >= machineY && currentLayer < machineY + machineHeight) {
                drawSingleMachine(g, m, false);
            }
        }
    }

    private void drawGhost(Graphics2D g) {
        if (mouseHoverPos == null || currentTool == null) return;
        Vector3Int dimBase = registry.getDimensions(currentTool);

        boolean isRotated = (currentOrientation == Direction.EAST || currentOrientation == Direction.WEST);
        int w = (isRotated ? dimBase.z() : dimBase.x()) * CELL_SIZE;
        int h = (isRotated ? dimBase.x() : dimBase.z()) * CELL_SIZE;

        Composite original = g.getComposite();
        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));

        int x = toScreenX(mouseHoverPos.x());
        int z = toScreenY(mouseHoverPos.z());

        g.setColor(getColorForType(currentTool));
        g.fillRect(x, z, w, h);
        g.setColor(Color.WHITE);
        g.drawRect(x, z, w, h);

        drawDirectionArrow(g, x, z, w, h, currentOrientation);
        g.setComposite(original);
    }

    private void drawSingleMachine(Graphics2D g, PlacedMachine m, boolean isGhost) {
        GridPosition pos = m.getPos();
        Vector3Int dim = m.getDimensions();

        int x = toScreenX(pos.x());
        int z = toScreenY(pos.z());
        int w = dim.x() * CELL_SIZE;
        int h = dim.z() * CELL_SIZE;

        g.setColor(getColorForType(m.getTypeId()));
        g.fillRect(x + 2, z + 2, w - 4, h - 4);

        // --- LOGICA PORTE SPECIFICA ---
        if (m.getTypeId().equals("nexus_core")) {
            drawNexusPorts(g, m, x, z, w, h);
        }
        else if (m.getTypeId().equals("chromator") || m.getTypeId().equals("color_mixer")) {
            drawPorts(g, m, x, z, w, h);
        } else {
            drawStandardPorts(g, m, x, z, w, h);
        }

        drawDirectionArrow(g, x, z, w, h, m.getOrientation());

        if (m instanceof ConveyorBelt belt) {
            drawBeltItem(g, belt, x, z);
        } else if (m instanceof NexusMachine) {
            g.setColor(Color.WHITE);
            if (pos.y() == currentLayer) g.drawString("NEXUS", x + 10, z + 20);
        }
    }

    // --- NUOVO METODO: PORTE DEL NEXUS ---
    // Disegna porte di ingresso (BLU) su tutti i lati per i primi 2 livelli.
    private void drawNexusPorts(Graphics2D g, PlacedMachine m, int x, int z, int w, int h) {
        int machineBaseY = m.getPos().y();
        int relativeY = currentLayer - machineBaseY;

        // Se siamo al livello 0 o 1 del Nexus (base o centro), disegna porte
        if (relativeY >= 0 && relativeY <= 1) {
            g.setColor(Color.BLUE);
            int pSize = 8;

            // Porta Nord
            g.fillRect(x + w/2 - pSize/2, z, pSize, pSize);
            // Porta Sud
            g.fillRect(x + w/2 - pSize/2, z + h - pSize, pSize, pSize);
            // Porta Ovest
            g.fillRect(x, z + h/2 - pSize/2, pSize, pSize);
            // Porta Est
            g.fillRect(x + w - pSize, z + h/2 - pSize/2, pSize, pSize);
        }
        // Nessun Output (Verde)
    }

    private void drawBeltItem(Graphics2D g, ConveyorBelt belt, int x, int z) {
        JsonObject meta = belt.serialize();
        if (meta.has("currentItem")) {
            JsonObject itemJson = meta.getAsJsonObject("currentItem");
            String shapeStr = null;
            String colorStr = "RAW";

            try {
                if (itemJson.has("shape") && !itemJson.get("shape").isJsonNull()) {
                    shapeStr = itemJson.get("shape").getAsString();
                }
                if (itemJson.has("color")) colorStr = itemJson.get("color").getAsString();
            } catch(Exception ignored) {}

            Color itemColor = switch(colorStr) {
                case "RAW" -> new Color(180, 180, 180);
                case "RED" -> new Color(220, 50, 50);
                case "BLUE" -> new Color(50, 80, 255);
                case "YELLOW" -> new Color(255, 220, 0);
                case "GREEN" -> new Color(50, 200, 50);
                case "ORANGE" -> new Color(255, 140, 0);
                case "PURPLE" -> new Color(160, 32, 240);
                default -> Color.MAGENTA;
            };

            int itemSize = 20;
            int ix = x + (CELL_SIZE - itemSize) / 2;
            int iz = z + (CELL_SIZE - itemSize) / 2;

            g.setColor(itemColor);

            if ("CUBE".equals(shapeStr)) {
                g.fillRect(ix, iz, itemSize, itemSize);
                g.setColor(Color.WHITE);
                g.drawRect(ix, iz, itemSize, itemSize);
            } else {
                g.fillOval(ix, iz, itemSize, itemSize);
                g.setColor(Color.WHITE);
                g.drawOval(ix, iz, itemSize, itemSize);
            }
        }
    }

    private void drawPorts(Graphics2D g, PlacedMachine m, int x, int z, int w, int h) {
        int pSize = 8;
        Direction dir = m.getOrientation();
        Point out = null, in1 = null, in2 = null;

        // Dimensioni macchina in pixel
        // w e h sono giÃ  ruotati (es. NORTH: w=2 celle, h=1 cella)

        int cell = CELL_SIZE;

        switch (dir) {
            case NORTH:
                // Out: Blocco Sinistro (0,0) -> Lato Nord
                out = new Point(x + cell/2 - pSize/2, z);
                // In: Lato Sud (z+h)
                in1 = new Point(x + cell/2 - pSize/2, z + h - pSize); // Blocco Sinistro
                in2 = new Point(x + (cell*3)/2 - pSize/2, z + h - pSize); // Blocco Destro
                break;

            case SOUTH:
                // Out: Blocco Sinistro (Guardando Sud, Ã¨ a dx nello schermo) -> (1,0) -> Lato Sud
                out = new Point(x + (cell*3)/2 - pSize/2, z + h - pSize);
                // In: Lato Nord
                in1 = new Point(x + (cell*3)/2 - pSize/2, z);
                in2 = new Point(x + cell/2 - pSize/2, z);
                break;

            case EAST:
                // Out: Blocco Sinistro (Guardando Est, Ã¨ sopra) -> (0,0) -> Lato Est
                out = new Point(x + w - pSize, z + cell/2 - pSize/2);
                // In: Lato Ovest
                in1 = new Point(x, z + cell/2 - pSize/2);
                in2 = new Point(x, z + (cell*3)/2 - pSize/2);
                break;

            case WEST:
                // Out: Blocco Sinistro (Guardando Ovest, Ã¨ sotto) -> (0,1) -> Lato Ovest
                out = new Point(x, z + (cell*3)/2 - pSize/2);
                // In: Lato Est
                in1 = new Point(x + w - pSize, z + (cell*3)/2 - pSize/2);
                in2 = new Point(x + w - pSize, z + cell/2 - pSize/2);
                break;
        }

        if (out != null) {
            g.setColor(Color.GREEN); g.fillRect(out.x, out.y, pSize, pSize);
            g.setColor(Color.BLUE);  g.fillRect(in1.x, in1.y, pSize, pSize);
            g.setColor(Color.BLUE);  g.fillRect(in2.x, in2.y, pSize, pSize);
        }
    }

    private void drawStandardPorts(Graphics2D g, PlacedMachine m, int x, int z, int w, int h) {
        int pSize = 8;
        Point out = null, in = null;
        switch (m.getOrientation()) {
            case NORTH -> { out = new Point(x + w/2 - pSize/2, z); in = new Point(x + w/2 - pSize/2, z + h - pSize); }
            case SOUTH -> { out = new Point(x + w/2 - pSize/2, z + h - pSize); in = new Point(x + w/2 - pSize/2, z); }
            case EAST  -> { out = new Point(x + w - pSize, z + h/2 - pSize/2); in = new Point(x, z + h/2 - pSize/2); }
            case WEST  -> { out = new Point(x, z + h/2 - pSize/2); in = new Point(x + w - pSize, z + h/2 - pSize/2); }
        }
        if (out != null) { g.setColor(Color.GREEN); g.fillRect(out.x, out.y, pSize, pSize); }
        if (in != null && !m.getTypeId().equals("drill_mk1")) { g.setColor(Color.BLUE); g.fillRect(in.x, in.y, pSize, pSize); }
    }

    private Color getColorForType(String type) {
        return switch (type) {
            case "drill_mk1" -> Color.LIGHT_GRAY;
            case "conveyor_belt" -> Color.DARK_GRAY;
            case "nexus_core" -> new Color(150, 0, 150);
            case "chromator" -> new Color(255, 140, 0);
            case "color_mixer" -> new Color(0, 200, 200);
            default -> Color.RED;
        };
    }

    private void drawDirectionArrow(Graphics2D g, int x, int y, int w, int h, Direction dir) {
        g.setColor(Color.YELLOW);
        int cx = x + w / 2;
        int cy = y + h / 2;
        switch (dir) {
            case NORTH -> g.fillOval(cx - 3, y + 2, 6, 6);
            case SOUTH -> g.fillOval(cx - 3, y + h - 8, 6, 6);
            case EAST ->  g.fillOval(x + w - 8, cy - 3, 6, 6);
            case WEST ->  g.fillOval(x + 2, cy - 3, 6, 6);
        }
    }

    private int toScreenX(int gridX) { return OFFSET_X + (gridX * CELL_SIZE); }
    private int toScreenY(int gridZ) { return OFFSET_Y + (gridZ * CELL_SIZE); }
    private int toGridX(int screenX) { return (screenX - OFFSET_X) / CELL_SIZE; }
    private int toGridY(int screenY) { return (screenY - OFFSET_Y) / CELL_SIZE; }
}


--------------------------------
FILE: MatterWorksGUI.java
--------------------------------
package com.matterworks.core.infrastructure.swing;

import com.matterworks.core.domain.machines.BlockRegistry;
import com.matterworks.core.managers.GridManager;

import javax.swing.*;
import java.awt.*;
import java.util.UUID;
import java.util.function.Supplier;

public class MatterWorksGUI extends JFrame {

    private final FactoryPanel panel;
    private final JLabel lblTool;
    private final JLabel lblOrient;
    private final JLabel lblLayer;
    private final JLabel lblMoney;

    public MatterWorksGUI(GridManager gridManager, BlockRegistry registry, UUID playerUuid, Runnable onSave, Supplier<Double> moneyProvider) {
        setTitle("MatterWorks Architect (Java 25)");
        setSize(1280, 900);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);
        setLayout(new BorderLayout());

        // INFO LABELS
        lblTool = createLabel("TOOL: Drill");
        lblOrient = createLabel("DIR: NORTH");
        lblLayer = createLabel("LAYER Y: 0");
        lblLayer.setForeground(Color.CYAN);

        lblMoney = new JLabel("MONEY: $---");
        lblMoney.setFont(new Font("Monospaced", Font.BOLD, 16));
        lblMoney.setForeground(Color.GREEN);

        // GRID PANEL
        panel = new FactoryPanel(gridManager, registry, playerUuid, this::updateLabels);

        // --- LEFT TOOLBAR ---
        JPanel leftTools = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
        leftTools.setOpaque(false);

        JButton btnDrill = createButton("â› Drill", e -> setTool("drill_mk1"));
        JButton btnBelt = createButton("â¨  Belt", e -> setTool("conveyor_belt"));
        JButton btnChromator = createButton("ðŸŽ¨ Chromator", e -> setTool("chromator"));
        btnChromator.setBackground(new Color(255, 140, 0));
        btnChromator.setForeground(Color.BLACK);
        JButton btnMixer = createButton("ðŸŒ€ Mixer", e -> setTool("color_mixer"));
        btnMixer.setBackground(new Color(0, 200, 200));
        btnMixer.setForeground(Color.BLACK);
        JButton btnNexus = createButton("ðŸ”® Nexus", e -> setTool("nexus_core"));
        btnNexus.setBackground(new Color(100, 0, 150));
        btnNexus.setForeground(Color.WHITE);

        JSeparator sep1 = new JSeparator(SwingConstants.VERTICAL); sep1.setPreferredSize(new Dimension(5, 25));
        JButton btnLayerUp = createButton("â¬† Layer UP", e -> changeLayer(1));
        JButton btnLayerDown = createButton("â¬‡ Layer DOWN", e -> changeLayer(-1));
        JSeparator sep2 = new JSeparator(SwingConstants.VERTICAL); sep2.setPreferredSize(new Dimension(5, 25));
        JButton btnRotate = createButton("â†» Rotate (R)", e -> panel.rotate());

        leftTools.add(btnDrill);
        leftTools.add(btnBelt);
        leftTools.add(btnChromator);
        leftTools.add(btnMixer);
        leftTools.add(btnNexus);
        leftTools.add(sep1);
        leftTools.add(btnLayerDown);
        leftTools.add(btnLayerUp);
        leftTools.add(sep2);
        leftTools.add(btnRotate);

        // --- RIGHT SYSTEM BUTTONS ---
        JPanel rightSystem = new JPanel(new FlowLayout(FlowLayout.RIGHT, 10, 0));
        rightSystem.setOpaque(false);

        // SAVE
        JButton btnSave = createButton("ðŸ’¾ SAVE", e -> {
            onSave.run();
            JOptionPane.showMessageDialog(this, "Salvataggio Completato!", "Sistema", JOptionPane.INFORMATION_MESSAGE);
        });
        btnSave.setBackground(new Color(0, 100, 200));

        // NUOVO: RESET BUTTON
        JButton btnReset = createButton("âš ï¸ RESET", e -> {
            int choice = JOptionPane.showConfirmDialog(this,
                    "Sei sicuro di voler RESETTARE tutto?\nCancellerÃ  tutte le macchine e cambierÃ  posizione alle vene.\nNon si puÃ² annullare.",
                    "Conferma Reset",
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.WARNING_MESSAGE);

            if (choice == JOptionPane.YES_OPTION) {
                gridManager.resetUserPlot(playerUuid);
                // Aspetta un attimo per dare tempo al DB di resettare
                Timer t = new Timer(500, x -> {
                    panel.repaint();
                    JOptionPane.showMessageDialog(this, "Plot resettato e vene rigenerate!", "Reset", JOptionPane.INFORMATION_MESSAGE);
                });
                t.setRepeats(false);
                t.start();
            }
        });
        btnReset.setBackground(new Color(200, 0, 0));

        rightSystem.add(lblMoney);
        rightSystem.add(Box.createHorizontalStrut(20));
        rightSystem.add(btnSave);
        rightSystem.add(btnReset); // Aggiunto qui

        // LAYOUT ASSEMBLY
        JPanel topContainer = new JPanel(new BorderLayout());
        topContainer.setBackground(new Color(45, 45, 48));
        topContainer.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        topContainer.add(leftTools, BorderLayout.WEST);
        topContainer.add(rightSystem, BorderLayout.EAST);

        JPanel infoPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 20, 5));
        infoPanel.setBackground(new Color(60, 60, 65));
        infoPanel.add(lblTool);
        infoPanel.add(lblOrient);
        infoPanel.add(lblLayer);

        JPanel northGroup = new JPanel(new BorderLayout());
        northGroup.add(topContainer, BorderLayout.NORTH);
        northGroup.add(infoPanel, BorderLayout.SOUTH);

        add(northGroup, BorderLayout.NORTH);
        add(panel, BorderLayout.CENTER);

        // TIMERS
        new Timer(50, e -> panel.repaint()).start();
        new Timer(1000, e -> {
            double m = moneyProvider.get();
            lblMoney.setText(String.format("MONEY: $%,.2f", m));
        }).start();

        setVisible(true);
        panel.requestFocusInWindow();
        updateLabels();
    }

    private void setTool(String toolId) {
        panel.setTool(toolId);
        updateLabels();
    }

    private void changeLayer(int delta) {
        int newY = panel.getCurrentLayer() + delta;
        if (newY < 0) newY = 0;
        panel.setLayer(newY);
        updateLabels();
    }

    private void updateLabels() {
        if (lblTool != null && panel != null) {
            lblTool.setText("TOOL: " + panel.getCurrentToolName());
            lblOrient.setText("DIR: " + panel.getCurrentOrientationName());
            lblLayer.setText("LAYER Y: " + panel.getCurrentLayer());
        }
    }

    private JButton createButton(String text, java.awt.event.ActionListener action) {
        JButton btn = new JButton(text);
        btn.setFocusable(false);
        btn.addActionListener(action);
        btn.setBackground(new Color(70, 70, 70));
        btn.setForeground(Color.WHITE);
        btn.setFont(new Font("SansSerif", Font.PLAIN, 12));
        btn.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));
        return btn;
    }

    private JLabel createLabel(String text) {
        JLabel lbl = new JLabel(text);
        lbl.setForeground(Color.WHITE);
        lbl.setFont(new Font("Monospaced", Font.BOLD, 14));
        return lbl;
    }
}


--------------------------------
FILE: GridManager.java
--------------------------------
package com.matterworks.core.managers;

import com.matterworks.core.common.Direction;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.domain.factory.MachineFactory;
import com.matterworks.core.domain.machines.BlockRegistry;
import com.matterworks.core.domain.machines.DrillMachine;
import com.matterworks.core.domain.machines.PlacedMachine;
import com.matterworks.core.domain.matter.MatterColor;
import com.matterworks.core.domain.shop.MarketManager;
import com.matterworks.core.infrastructure.MariaDBAdapter;
import com.matterworks.core.model.PlotObject;
import com.matterworks.core.ports.IRepository;
import com.matterworks.core.ports.IWorldAccess;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class GridManager {

    private final IRepository repository;
    private final IWorldAccess worldAdapter;
    private final BlockRegistry blockRegistry;
    private final MarketManager marketManager;

    private final Map<UUID, Map<GridPosition, PlacedMachine>> playerGrids = new ConcurrentHashMap<>();
    private final Map<UUID, Map<GridPosition, MatterColor>> playerResources = new ConcurrentHashMap<>();
    private final List<PlacedMachine> tickingMachines = Collections.synchronizedList(new ArrayList<>());
    private final ExecutorService ioExecutor = Executors.newVirtualThreadPerTaskExecutor();

    public GridManager(IRepository repository, IWorldAccess worldAdapter, BlockRegistry registry) {
        this.repository = repository;
        this.worldAdapter = worldAdapter;
        this.blockRegistry = registry;
        this.marketManager = new MarketManager(repository);
    }

    // --- NUOVO METODO RESET ---
    public void resetUserPlot(UUID ownerId) {
        ioExecutor.submit(() -> {
            System.out.println("âš ï¸ RESET RICHIESTO PER " + ownerId);

            // 1. Pulisce memoria
            unloadPlot(ownerId);

            // 2. Pulisce DB (Macchine + Risorse)
            if (repository instanceof MariaDBAdapter dbAdapter) {
                dbAdapter.clearPlotData(ownerId);
            }

            // 3. Ricarica (Questo innescherÃ  la generazione di nuove risorse RANDOM)
            loadPlotFromDB(ownerId);
        });
    }

    public void loadPlotFromDB(UUID ownerId) {
        ioExecutor.submit(() -> {
            try {
                unloadPlot(ownerId);
                if (repository instanceof MariaDBAdapter dbAdapter) {
                    Long plotId = dbAdapter.getPlotId(ownerId);
                    if (plotId != null) {
                        Map<GridPosition, MatterColor> resources = dbAdapter.loadResources(plotId);

                        // SE VUOTO (Nuovo Plot o Appena Resettato) -> GENERA RISORSE
                        if (resources.isEmpty()) {
                            System.out.println("ðŸŒ Generazione NUOVE risorse per Plot " + plotId);
                            generateDefaultResources(dbAdapter, plotId, resources);
                        }

                        playerResources.put(ownerId, resources);
                        System.out.println("ðŸ’Ž Risorse caricate: " + resources.size() + " vene.");
                    }
                }

                // Carica macchine (dopo reset sarÃ  vuoto)
                List<PlotObject> dtos = repository.loadPlotMachines(ownerId);
                for (PlotObject dto : dtos) {
                    PlacedMachine machine = MachineFactory.createFromModel(dto, ownerId);
                    if (machine != null) internalAddMachine(ownerId, machine);
                }
            } catch (Exception e) { e.printStackTrace(); }
        });
    }

    // AGGIORNATO: Generazione Randomica ("Re-enroll")
    private void generateDefaultResources(MariaDBAdapter db, Long plotId, Map<GridPosition, MatterColor> cache) {
        Random rnd = new Random();

        // 2-3 Vene di RAW
        for (int i = 0; i < 3; i++) {
            createResource(db, plotId, cache, rnd.nextInt(15) + 2, 0, rnd.nextInt(15) + 2, MatterColor.RAW);
        }
        // 1 Vena ROSSA
        createResource(db, plotId, cache, rnd.nextInt(15) + 2, 0, rnd.nextInt(15) + 2, MatterColor.RED);
        // 1 Vena BLU
        createResource(db, plotId, cache, rnd.nextInt(15) + 2, 0, rnd.nextInt(15) + 2, MatterColor.BLUE);
    }

    private void createResource(MariaDBAdapter db, Long plotId, Map<GridPosition, MatterColor> cache, int x, int y, int z, MatterColor type) {
        // Evita sovrapposizioni nella generazione random
        if (cache.containsKey(new GridPosition(x, y, z))) return;

        db.saveResource(plotId, x, z, type);
        cache.put(new GridPosition(x, y, z), type);
    }

    private void unloadPlot(UUID ownerId) {
        playerGrids.remove(ownerId);
        playerResources.remove(ownerId);
        synchronized (tickingMachines) {
            tickingMachines.removeIf(m -> m.getOwnerId().equals(ownerId));
        }
    }

    // ... (Il resto dei metodi placeMachine, internalAddMachine, etc. RIMANE UGUALE) ...
    // Assicurati di copiare i metodi esistenti dal file precedente.

    public boolean placeMachine(UUID ownerId, GridPosition pos, String typeId, Direction orientation) {
        Vector3Int baseDim = blockRegistry.getDimensions(typeId);
        Vector3Int effectiveDim = baseDim;
        if (orientation == Direction.EAST || orientation == Direction.WEST) {
            effectiveDim = new Vector3Int(baseDim.z(), baseDim.y(), baseDim.x());
        }

        if (!isAreaClear(ownerId, pos, effectiveDim)) {
            System.out.println("âš ï¸ Area ostruita per " + typeId + " a " + pos);
            return false;
        }

        MatterColor resourceUnderDrill = null;
        if (typeId.equals("drill_mk1")) {
            if (pos.y() != 0) return false;
            Map<GridPosition, MatterColor> myResources = playerResources.get(ownerId);
            if (myResources != null) resourceUnderDrill = myResources.get(pos);
            if (resourceUnderDrill == null) {
                System.out.println("âš ï¸ Nessuna risorsa sotto la trivella a " + pos);
                return false;
            }
        }

        PlotObject newDto = new PlotObject(null, null, pos.x(), pos.y(), pos.z(), typeId, null);
        PlacedMachine newMachine = MachineFactory.createFromModel(newDto, ownerId);
        if (newMachine == null) return false;

        newMachine.setOrientation(orientation);
        if (newMachine instanceof DrillMachine drill && resourceUnderDrill != null) {
            drill.setResourceToMine(resourceUnderDrill);
        }

        internalAddMachine(ownerId, newMachine);
        newMachine.onPlace(worldAdapter);

        Long dbId = repository.createMachine(ownerId, newMachine);
        if (dbId != null) {
            newMachine.setDbId(dbId);
        }

        return true;
    }

    private void internalAddMachine(UUID ownerId, PlacedMachine machine) {
        machine.setGridContext(this);
        Map<GridPosition, PlacedMachine> myGrid = playerGrids.computeIfAbsent(ownerId, k -> new ConcurrentHashMap<>());
        Vector3Int dim = machine.getDimensions();
        GridPosition origin = machine.getPos();
        for (int x = 0; x < dim.x(); x++) {
            for (int y = 0; y < dim.y(); y++) {
                for (int z = 0; z < dim.z(); z++) {
                    myGrid.put(new GridPosition(origin.x() + x, origin.y() + y, origin.z() + z), machine);
                }
            }
        }
        tickingMachines.add(machine);
    }

    public PlacedMachine getMachineAt(UUID ownerId, GridPosition pos) {
        Map<GridPosition, PlacedMachine> myGrid = playerGrids.get(ownerId);
        return myGrid != null ? myGrid.get(pos) : null;
    }

    public boolean isAreaClear(UUID ownerId, GridPosition origin, Vector3Int dim) {
        Map<GridPosition, PlacedMachine> myGrid = playerGrids.get(ownerId);
        if (myGrid == null) return true;
        for (int x = 0; x < dim.x(); x++) {
            for (int y = 0; y < dim.y(); y++) {
                for (int z = 0; z < dim.z(); z++) {
                    if (myGrid.containsKey(new GridPosition(origin.x() + x, origin.y() + y, origin.z() + z))) return false;
                }
            }
        }
        return true;
    }

    public boolean rotateMachine(GridPosition pos, Direction newDir, UUID ownerId) {
        PlacedMachine machine = getMachineAt(ownerId, pos);
        if (machine == null) return false;
        Direction oldDir = machine.getOrientation();
        if (oldDir == newDir) return true;
        removeFromGridMap(ownerId, machine);
        machine.setOrientation(newDir);
        Vector3Int newDim = machine.getDimensions();
        if (isAreaClear(ownerId, pos, newDim)) {
            addToGridMap(ownerId, machine);
            return true;
        } else {
            machine.setOrientation(oldDir);
            addToGridMap(ownerId, machine);
            return false;
        }
    }

    public void removeComponent(UUID ownerId, GridPosition pos) {
        PlacedMachine target = getMachineAt(ownerId, pos);
        if (target == null) return;
        if (target.getDbId() != null) repository.deleteMachine(target.getDbId());
        removeFromGridMap(ownerId, target);
        synchronized (tickingMachines) { tickingMachines.remove(target); }
        target.onRemove();
    }

    private void addToGridMap(UUID ownerId, PlacedMachine m) {
        Map<GridPosition, PlacedMachine> grid = playerGrids.get(ownerId);
        if (grid == null) return;
        Vector3Int dim = m.getDimensions();
        GridPosition origin = m.getPos();
        for (int x = 0; x < dim.x(); x++) {
            for (int y = 0; y < dim.y(); y++) {
                for (int z = 0; z < dim.z(); z++) {
                    grid.put(new GridPosition(origin.x() + x, origin.y() + y, origin.z() + z), m);
                }
            }
        }
    }

    private void removeFromGridMap(UUID ownerId, PlacedMachine m) {
        Map<GridPosition, PlacedMachine> grid = playerGrids.get(ownerId);
        if (grid == null) return;
        Vector3Int dim = m.getDimensions();
        GridPosition origin = m.getPos();
        for (int x = 0; x < dim.x(); x++) {
            for (int y = 0; y < dim.y(); y++) {
                for (int z = 0; z < dim.z(); z++) {
                    grid.remove(new GridPosition(origin.x() + x, origin.y() + y, origin.z() + z));
                }
            }
        }
    }

    public void tick(long currentTick) {
        List<PlacedMachine> snapshot;
        synchronized (tickingMachines) { snapshot = new ArrayList<>(tickingMachines); }
        snapshot.forEach(m -> m.tick(currentTick));
    }

    public Map<GridPosition, PlacedMachine> getSnapshot(UUID ownerId) {
        Map<GridPosition, PlacedMachine> grid = playerGrids.get(ownerId);
        return grid != null ? new HashMap<>(grid) : Collections.emptyMap();
    }

    public Map<GridPosition, PlacedMachine> getAllMachinesSnapshot() {
        Map<GridPosition, PlacedMachine> all = new HashMap<>();
        for(var map : playerGrids.values()) { all.putAll(map); }
        return all;
    }

    public Map<GridPosition, MatterColor> getTerrainResources(UUID ownerId) {
        return playerResources.getOrDefault(ownerId, Collections.emptyMap());
    }

    public MarketManager getMarketManager() { return marketManager; }
}


--------------------------------
FILE: WorldIntegrityValidator.java
--------------------------------
package com.matterworks.core.managers;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.matterworks.core.common.Direction;
import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;
import com.matterworks.core.database.DatabaseManager;
import com.matterworks.core.domain.machines.BlockRegistry;
import com.matterworks.core.model.PlotObject;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.*;

public class WorldIntegrityValidator {

    private final DatabaseManager db;
    private final BlockRegistry registry;

    public WorldIntegrityValidator(DatabaseManager db, BlockRegistry registry) {
        this.db = db;
        this.registry = registry;
    }

    public boolean validateWorldIntegrity() {
        System.out.println("ðŸ” Esecuzione Validazione IntegritÃ  Mondo...");
        Map<Long, List<PlotObject>> machinesByPlot = loadAllMachines();
        boolean hasConflicts = false;

        for (Map.Entry<Long, List<PlotObject>> entry : machinesByPlot.entrySet()) {
            Long plotId = entry.getKey();
            List<PlotObject> machines = entry.getValue();
            if (!validatePlot(plotId, machines)) {
                hasConflicts = true;
            }
        }

        if (hasConflicts) {
            System.err.println("âŒ VALIDAZIONE FALLITA: Trovati conflitti di sovrapposizione!");
        } else {
            System.out.println("âœ… IntegritÃ  Mondo Verificata: Nessuna collisione rilevata.");
        }
        return !hasConflicts;
    }

    private boolean validatePlot(Long plotId, List<PlotObject> machines) {
        // Mappa: Posizione -> ID Macchina (per sapere CHI occupa cosa)
        Map<GridPosition, Long> occupiedCells = new HashMap<>();
        boolean plotValid = true;

        for (PlotObject machine : machines) {
            String typeId = machine.getTypeId();
            Vector3Int baseDim = registry.getDimensions(typeId);

            // --- FIX: CALCOLO DIMENSIONI REALI (ROTAZIONE) ---
            Vector3Int effectiveDim = baseDim;
            try {
                // Leggiamo la rotazione dai metadati grezzi
                if (machine.getMetaData() != null && machine.getMetaData().has("orientation")) {
                    String orStr = machine.getMetaData().get("orientation").getAsString();
                    Direction dir = Direction.valueOf(orStr);
                    if (dir == Direction.EAST || dir == Direction.WEST) {
                        effectiveDim = new Vector3Int(baseDim.z(), baseDim.y(), baseDim.x());
                    }
                }
            } catch (Exception e) {
                // Fallback a dimensioni base se json corrotto
            }

            GridPosition origin = new GridPosition(machine.getX(), machine.getY(), machine.getZ());

            for (int x = 0; x < effectiveDim.x(); x++) {
                for (int y = 0; y < effectiveDim.y(); y++) {
                    for (int z = 0; z < effectiveDim.z(); z++) {
                        GridPosition pos = new GridPosition(origin.x() + x, origin.y() + y, origin.z() + z);

                        if (occupiedCells.containsKey(pos)) {
                            Long otherId = occupiedCells.get(pos);
                            // Se ID diverso, Ã¨ conflitto
                            if (!otherId.equals(machine.getId())) {
                                System.err.println("   âš ï¸ CONFLITTO nel Plot ID " + plotId + ":");
                                System.err.println("      Macchina A (ID " + machine.getId() + ") " + typeId + " a " + origin);
                                System.err.println("      Macchina B (ID " + otherId + ") occupa giÃ  " + pos);
                                plotValid = false;
                            }
                        } else {
                            occupiedCells.put(pos, machine.getId());
                        }
                    }
                }
            }
        }
        return plotValid;
    }

    private Map<Long, List<PlotObject>> loadAllMachines() {
        Map<Long, List<PlotObject>> result = new HashMap<>();
        // FIX: Carichiamo anche i metadati per la rotazione!
        String sql = "SELECT id, plot_id, x, y, z, type_id, metadata FROM plot_machines";

        try (Connection conn = db.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql);
             ResultSet rs = ps.executeQuery()) {

            while (rs.next()) {
                PlotObject obj = new PlotObject();
                obj.setId(rs.getLong("id"));
                obj.setPlotId(rs.getLong("plot_id"));
                obj.setPosition(rs.getInt("x"), rs.getInt("y"), rs.getInt("z"));
                obj.setTypeId(rs.getString("type_id"));

                String metaStr = rs.getString("metadata");
                if (metaStr != null) obj.setMetaDataFromString(metaStr);

                result.computeIfAbsent(obj.getPlotId(), k -> new ArrayList<>()).add(obj);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }
}


--------------------------------
FILE: PlotObject.java
--------------------------------
package com.matterworks.core.model;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

public class PlotObject {

    private Long id;
    private Long plotId;
    private int x;
    private int y;
    private int z;
    private String typeId;
    private JsonObject metaData;

    // --- COSTRUTTORI ---

    // 1. Costruttore Vuoto (Richiesto dal Validator e da alcuni framework)
    public PlotObject() {
        this.metaData = new JsonObject();
    }

    // 2. Costruttore Completo
    public PlotObject(Long id, Long plotId, int x, int y, int z, String typeId, JsonObject metaData) {
        this.id = id;
        this.plotId = plotId;
        this.x = x;
        this.y = y;
        this.z = z;
        this.typeId = typeId;
        this.metaData = (metaData != null) ? metaData : new JsonObject();
    }

    // --- GETTERS & SETTERS ---

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getPlotId() { return plotId; }
    public void setPlotId(Long plotId) { this.plotId = plotId; }

    // Coordinate singole
    public int getX() { return x; }
    public void setX(int x) { this.x = x; }

    public int getY() { return y; }
    public void setY(int y) { this.y = y; }

    public int getZ() { return z; }
    public void setZ(int z) { this.z = z; }

    // Helper richiesto dal Validator
    public void setPosition(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    // Type ID
    public String getTypeId() { return typeId; }
    public void setTypeId(String typeId) { this.typeId = typeId; }

    // Metadata
    public JsonObject getMetaData() { return metaData; }
    public void setMetaData(JsonObject metaData) { this.metaData = metaData; }

    // --- METODI DI UTILITÃ€ ---

    public String getRawMetaData() {
        return this.metaData != null ? this.metaData.toString() : "{}";
    }

    public void setMetaDataFromString(String jsonString) {
        if (jsonString == null || jsonString.isEmpty()) {
            this.metaData = new JsonObject();
            return;
        }
        try {
            this.metaData = JsonParser.parseString(jsonString).getAsJsonObject();
        } catch (Exception e) {
            System.err.println("âš ï¸ Errore parsing JSON per PlotObject " + id + ": " + e.getMessage());
            this.metaData = new JsonObject();
        }
    }
}


--------------------------------
FILE: IMachineVisuals.java
--------------------------------
package com.matterworks.core.ports;

/**
 * Astrazione per effetti client-side (Particelle, Animazioni).
 * Definita nel namespace Core_Ports.
 */
public interface IMachineVisuals {
    void playAnimation(String animationName);
    void spawnParticle(String particleId);
}


--------------------------------
FILE: IRepository.java
--------------------------------
package com.matterworks.core.ports;

import com.matterworks.core.domain.machines.PlacedMachine;
import com.matterworks.core.domain.player.PlayerProfile;
import com.matterworks.core.model.PlotObject;

import java.util.List;
import java.util.UUID;

public interface IRepository {

    PlayerProfile loadPlayerProfile(UUID uuid);
    void savePlayerProfile(PlayerProfile profile);

    List<PlotObject> loadPlotMachines(UUID ownerId);

    // --- NUOVO METODO PER SALVARE NUOVE MACCHINE ---
    Long createMachine(UUID ownerId, PlacedMachine machine);

    void deleteMachine(Long dbId);
    void updateMachinesMetadata(List<PlacedMachine> machines);
}


--------------------------------
FILE: IWorldAccess.java
--------------------------------
package com.matterworks.core.ports;

import com.matterworks.core.common.GridPosition;
import com.matterworks.core.common.Vector3Int;

/**
 * Astrazione per toccare i blocchi di Hytale.
 * Definita nel namespace Core_Ports.
 */
public interface IWorldAccess {
    void setBlock(GridPosition pos, String blockId);
    boolean isBlockSolid(GridPosition pos);
    void createVisuals(GridPosition pos, String visualId);
    Vector3Int fetchExternalBlockDimensions(String blockId);
}


--------------------------------
FILE: FactoryLoop.java
--------------------------------
package com.matterworks.core.synchronization;

import com.matterworks.core.managers.GridManager;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Il Loop di Gioco.
 * - FactoryLoop.
 */
public class FactoryLoop {

    private final GridManager gridManager;
    private final ScheduledExecutorService scheduler;
    private final AtomicLong currentTick = new AtomicLong(0);
    private volatile boolean isRunning = false;

    public FactoryLoop(GridManager gridManager) {
        this.gridManager = gridManager;
        // Thread singolo dedicato al tick del gioco (per evitare race conditions nella logica)
        this.scheduler = Executors.newSingleThreadScheduledExecutor();
    }

    public void start() {
        if (isRunning) return;
        isRunning = true;

        // Hytale gira a 20 TPS (Ticks Per Second) -> 50ms per tick
        scheduler.scheduleAtFixedRate(this::runTick, 0, 50, TimeUnit.MILLISECONDS);
        System.out.println("ðŸ­ Factory Loop Started.");
    }

    public void stop() {
        isRunning = false;
        scheduler.shutdown();
    }

    /**
     * runTick
     */
    private void runTick() {
        try {
            long tick = currentTick.incrementAndGet();

            // 1. Tick della griglia (Macchine producono/consumano)
            gridManager.tick(tick);

            // TODO: Qui potremmo chiamare TechManager, CapManager, etc.

        } catch (Exception e) {
            System.err.println("CRITICAL: Exception in Factory Loop!");
            e.printStackTrace();
        }
    }
}


--------------------------------
FILE: GridSaverService.java
--------------------------------
package com.matterworks.core.synchronization;

import com.matterworks.core.common.GridPosition;
import com.matterworks.core.domain.machines.PlacedMachine;
import com.matterworks.core.managers.GridManager;
import com.matterworks.core.ports.IRepository;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

public class GridSaverService {

    private final GridManager gridManager;
    private final IRepository repository;

    public GridSaverService(GridManager gridManager, IRepository repository) {
        this.gridManager = gridManager;
        this.repository = repository;
    }

    public void autoSaveTask() {
        // FIX: Usa getAllMachinesSnapshot() invece di getSnapshot()
        // Questo recupera le macchine di TUTTI i giocatori per salvarle.
        Map<GridPosition, PlacedMachine> allMachines = gridManager.getAllMachinesSnapshot();

        List<PlacedMachine> dirtyMachines = allMachines.values().stream()
                .filter(PlacedMachine::isDirty)
                .distinct()
                .collect(Collectors.toList());

        if (dirtyMachines.isEmpty()) return;

        Map<UUID, List<PlacedMachine>> machinesByOwner = dirtyMachines.stream()
                .collect(Collectors.groupingBy(PlacedMachine::getOwnerId));

        System.out.println("ðŸ’¾ AutoSave: Saving dirty machines for " + machinesByOwner.size() + " plots.");

        for (Map.Entry<UUID, List<PlacedMachine>> entry : machinesByOwner.entrySet()) {
            List<PlacedMachine> toSave = entry.getValue();
            repository.updateMachinesMetadata(toSave);
            toSave.forEach(PlacedMachine::cleanDirty);
        }
    }
}
